'use strict';

var require$$0$1 = require('http');
var require$$2 = require('querystring');
var require$$0$3 = require('events');
var require$$0$2 = require('util');
var require$$0$4 = require('dns');
var require$$1 = require('net');
var require$$0$5 = require('crypto');
var require$$0$6 = require('stream');
var require$$2$1 = require('tls');
var require$$0$8 = require('os');
var require$$1$1 = require('path');
var require$$0$7 = require('fs');
var require$$0$a = require('https');
var require$$0$9 = require('zlib');
var require$$4 = require('url');
var require$$0$b = require('vm');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);
var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);
var require$$0__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$0$3);
var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$2);
var require$$0__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$0$4);
var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);
var require$$0__default$4 = /*#__PURE__*/_interopDefaultLegacy(require$$0$5);
var require$$0__default$5 = /*#__PURE__*/_interopDefaultLegacy(require$$0$6);
var require$$2__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$2$1);
var require$$0__default$7 = /*#__PURE__*/_interopDefaultLegacy(require$$0$8);
var require$$1__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$1$1);
var require$$0__default$6 = /*#__PURE__*/_interopDefaultLegacy(require$$0$7);
var require$$0__default$9 = /*#__PURE__*/_interopDefaultLegacy(require$$0$a);
var require$$0__default$8 = /*#__PURE__*/_interopDefaultLegacy(require$$0$9);
var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4);
var require$$0__default$a = /*#__PURE__*/_interopDefaultLegacy(require$$0$b);

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    };
  }

  return _get.apply(this, arguments);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function commonjsRequire (path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var runtime = {exports: {}};

(function (module) {
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    });
    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    define(Gp, iteratorSymbol, function () {
      return this;
    });
    define(Gp, "toString", function () {
      return "[object Generator]";
    });

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    }; // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.

    return exports;
  }( // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, in modern engines
    // we can explicitly access globalThis. In older engines we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
})(runtime);

var regeneratorRuntime$1 = runtime.exports;

function every (arr, cb) {
  var i = 0,
      len = arr.length;

  for (; i < len; i++) {
    if (!cb(arr[i], i, arr)) {
      return false;
    }
  }

  return true;
}

const SEP = '/';
// Types ~> static, param, any, optional
const STYPE=0, PTYPE=1, ATYPE=2, OTYPE=3;
// Char Codes ~> / : *
const SLASH=47, COLON=58, ASTER=42, QMARK=63;

function strip(str) {
	if (str === SEP) return str;
	(str.charCodeAt(0) === SLASH) && (str=str.substring(1));
	var len = str.length - 1;
	return str.charCodeAt(len) === SLASH ? str.substring(0, len) : str;
}

function split(str) {
	return (str=strip(str)) === SEP ? [SEP] : str.split(SEP);
}

function isMatch(arr, obj, idx) {
	idx = arr[idx];
	return (obj.val === idx && obj.type === STYPE) || (idx === SEP ? obj.type > PTYPE : obj.type !== STYPE && (idx || '').endsWith(obj.end));
}

function match$1(str, all) {
	var i=0, tmp, segs=split(str), len=segs.length, l;
	var fn = isMatch.bind(isMatch, segs);

	for (; i < all.length; i++) {
		tmp = all[i];
		if ((l=tmp.length) === len || (l < len && tmp[l-1].type === ATYPE) || (l > len && tmp[l-1].type === OTYPE)) {
			if (every(tmp, fn)) return tmp;
		}
	}

	return [];
}

function parse$2(str) {
	if (str === SEP) {
		return [{ old:str, type:STYPE, val:str, end:'' }];
	}

	var c, x, t, sfx, nxt=strip(str), i=-1, j=0, len=nxt.length, out=[];

	while (++i < len) {
		c = nxt.charCodeAt(i);

		if (c === COLON) {
			j = i + 1; // begining of param
			t = PTYPE; // set type
			x = 0; // reset mark
			sfx = '';

			while (i < len && nxt.charCodeAt(i) !== SLASH) {
				c = nxt.charCodeAt(i);
				if (c === QMARK) {
					x=i; t=OTYPE;
				} else if (c === 46 && sfx.length === 0) {
					sfx = nxt.substring(x=i);
				}
				i++; // move on
			}

			out.push({
				old: str,
				type: t,
				val: nxt.substring(j, x||i),
				end: sfx
			});

			// shorten string & update pointers
			nxt=nxt.substring(i); len-=i; i=0;

			continue; // loop
		} else if (c === ASTER) {
			out.push({
				old: str,
				type: ATYPE,
				val: nxt.substring(i),
				end: ''
			});
			continue; // loop
		} else {
			j = i;
			while (i < len && nxt.charCodeAt(i) !== SLASH) {
				++i; // skip to next slash
			}
			out.push({
				old: str,
				type: STYPE,
				val: nxt.substring(j, i),
				end: ''
			});
			// shorten string & update pointers
			nxt=nxt.substring(i); len-=i; i=j=0;
		}
	}

	return out;
}

function exec$1(str, arr) {
	var i=0, x, y, segs=split(str), out={};
	for (; i < arr.length; i++) {
		x=segs[i]; y=arr[i];
		if (x === SEP) continue;
		if (x !== void 0 && y.type | 2 === OTYPE) {
			out[ y.val ] = x.replace(y.end, '');
		}
	}
	return out;
}

var matchit = /*#__PURE__*/Object.freeze({
  __proto__: null,
  match: match$1,
  parse: parse$2,
  exec: exec$1
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(matchit);

var exec = require$$0.exec,
    match = require$$0.match,
    parse$1 = require$$0.parse;

var Trouter = /*#__PURE__*/function () {
  function Trouter(opts) {
    _classCallCheck(this, Trouter);

    this.opts = opts || {};
    this.routes = {};
    this.handlers = {};
    this.all = this.add.bind(this, '*');
    this.get = this.add.bind(this, 'GET');
    this.head = this.add.bind(this, 'HEAD');
    this.patch = this.add.bind(this, 'PATCH');
    this.options = this.add.bind(this, 'OPTIONS');
    this.connect = this.add.bind(this, 'CONNECT');
    this["delete"] = this.add.bind(this, 'DELETE');
    this.trace = this.add.bind(this, 'TRACE');
    this.post = this.add.bind(this, 'POST');
    this.put = this.add.bind(this, 'PUT');
  }

  _createClass(Trouter, [{
    key: "add",
    value: function add(method, pattern) {
      // Save decoded pattern info
      if (this.routes[method] === void 0) this.routes[method] = [];
      this.routes[method].push(parse$1(pattern)); // Save route handler(s)

      if (this.handlers[method] === void 0) this.handlers[method] = {};

      for (var _len = arguments.length, fns = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        fns[_key - 2] = arguments[_key];
      }

      this.handlers[method][pattern] = fns; // Allow chainable

      return this;
    }
  }, {
    key: "find",
    value: function find(method, url) {
      var arr = match(url, this.routes[method] || []);

      if (arr.length === 0) {
        arr = match(url, this.routes[method = '*'] || []);
        if (!arr.length) return false;
      }

      return {
        params: exec(url, arr),
        handlers: this.handlers[method][arr[0].old]
      };
    }
  }]);

  return Trouter;
}();

var trouter = Trouter;

var url = function url(req) {
  var url = req.url;
  if (url === void 0) return url;
  var obj = req._parsedUrl;
  if (obj && obj._raw === url) return obj;
  obj = {};
  obj.query = obj.search = null;
  obj.href = obj.path = obj.pathname = url;
  var idx = url.indexOf('?', 1);

  if (idx !== -1) {
    obj.search = url.substring(idx);
    obj.query = obj.search.substring(1);
    obj.pathname = url.substring(0, idx);
  }

  obj._raw = url;
  return req._parsedUrl = obj;
};

var http = require$$0__default["default"];
var Router = trouter;
var parse = require$$2__default["default"].parse;
var parser = url;

function lead(x) {
  return x.charCodeAt(0) === 47 ? x : '/' + x;
}

function value(x) {
  var y = x.indexOf('/', 1);
  return y > 1 ? x.substring(0, y) : x;
}

function mutate(str, req) {
  req.url = req.url.substring(str.length) || '/';
  req.path = req.path.substring(str.length) || '/';
}

function onError(err, req, res, next) {
  var code = res.statusCode = err.code || err.status || 500;
  res.end(err.length && err || err.message || http.STATUS_CODES[code]);
}

var Polka = /*#__PURE__*/function (_Router) {
  _inherits(Polka, _Router);

  var _super = _createSuper(Polka);

  function Polka() {
    var _this;

    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Polka);

    _this = _super.call(this, opts);
    _this.apps = {};
    _this.wares = [];
    _this.bwares = {};
    _this.parse = parser;
    _this.server = opts.server;
    _this.handler = _this.handler.bind(_assertThisInitialized(_this));
    _this.onError = opts.onError || onError; // catch-all handler

    _this.onNoMatch = opts.onNoMatch || _this.onError.bind(null, {
      code: 404
    });
    return _this;
  }

  _createClass(Polka, [{
    key: "add",
    value: function add(method, pattern) {
      var _get2;

      var base = lead(value(pattern));
      if (this.apps[base] !== void 0) throw new Error("Cannot mount \".".concat(method.toLowerCase(), "('").concat(lead(pattern), "')\" because a Polka application at \".use('").concat(base, "')\" already exists! You should move this handler into your Polka application instead."));

      for (var _len = arguments.length, fns = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        fns[_key - 2] = arguments[_key];
      }

      return (_get2 = _get(_getPrototypeOf(Polka.prototype), "add", this)).call.apply(_get2, [this, method, pattern].concat(fns));
    }
  }, {
    key: "use",
    value: function use(base) {
      var _this2 = this;

      for (var _len2 = arguments.length, fns = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        fns[_key2 - 1] = arguments[_key2];
      }

      if (typeof base === 'function') {
        this.wares = this.wares.concat(base, fns);
      } else if (base === '/') {
        this.wares = this.wares.concat(fns);
      } else {
        base = lead(base);
        fns.forEach(function (fn) {
          if (fn instanceof Polka) {
            _this2.apps[base] = fn;
          } else {
            var arr = _this2.bwares[base] || [];
            arr.length > 0 || arr.push(function (r, _, nxt) {
              return mutate(base, r), nxt();
            });
            _this2.bwares[base] = arr.concat(fn);
          }
        });
      }

      return this; // chainable
    }
  }, {
    key: "listen",
    value: function listen() {
      (this.server = this.server || http.createServer()).on('request', this.handler);
      this.server.listen.apply(this.server, arguments);
      return this;
    }
  }, {
    key: "handler",
    value: function handler(req, res, info) {
      var _this3 = this;

      info = info || this.parse(req);
      var fns = [],
          arr = this.wares,
          obj = this.find(req.method, info.pathname);
      req.originalUrl = req.originalUrl || req.url;
      var base = value(req.path = info.pathname);

      if (this.bwares[base] !== void 0) {
        arr = arr.concat(this.bwares[base]);
      }

      if (obj) {
        fns = obj.handlers;
        req.params = obj.params;
      } else if (this.apps[base] !== void 0) {
        mutate(base, req);
        info.pathname = req.path; //=> updates

        fns.push(this.apps[base].handler.bind(null, req, res, info));
      } else if (fns.length === 0) {
        fns.push(this.onNoMatch);
      } // Grab addl values from `info`


      req.search = info.search;
      req.query = parse(info.query); // Exit if only a single function

      var i = 0,
          len = arr.length,
          num = fns.length;
      if (len === i && num === 1) return fns[0](req, res); // Otherwise loop thru all middlware

      var next = function next(err) {
        return err ? _this3.onError(err, req, res, next) : loop();
      };

      var loop = function loop(_) {
        return res.finished || i < len && arr[i++](req, res, next);
      };

      arr = arr.concat(fns);
      len += num;
      loop(); // init
    }
  }]);

  return Polka;
}(Router);

var polka = function polka(opts) {
  return new Polka(opts);
};

var clientOptions$3 = {};

var policies$2 = {};

var addressResolution$1 = {};

var utils$V = {};

var errors$s = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$J = require$$0__default$1["default"];
/**
 * Contains the error classes exposed by the driver.
 * @module errors
 */

/**
 * Base Error
 * @private
 */

function DriverError(message) {
  Error.call(this, message);
  Error.captureStackTrace(this, this.constructor);
  this.name = this.constructor.name;
  this.info = 'Cassandra Driver Error'; // Explicitly set the message property as the Error.call() doesn't set the property on v8

  this.message = message;
}

util$J.inherits(DriverError, Error);
/**
 * Represents an error when a query cannot be performed because no host is available or could be reached by the driver.
 * @param {Object} innerErrors An object map containing the error per host tried
 * @param {String} [message]
 * @constructor
 */

function NoHostAvailableError(innerErrors, message) {
  DriverError.call(this, message);
  this.innerErrors = innerErrors;
  this.info = 'Represents an error when a query cannot be performed because no host is available or could be reached by the driver.';

  if (!message) {
    this.message = 'All host(s) tried for query failed.';

    if (innerErrors) {
      var hostList = Object.keys(innerErrors);

      if (hostList.length > 0) {
        var host = hostList[0];
        this.message += util$J.format(' First host tried, %s: %s. See innerErrors.', host, innerErrors[host]);
      }
    }
  }
}

util$J.inherits(NoHostAvailableError, DriverError);
/**
 * Represents an error message from the server
 * @param {Number} code Cassandra exception code
 * @param {String} message
 * @constructor
 */

function ResponseError(code, message) {
  DriverError.call(this, message);
  /**
   * The error code as defined in [responseErrorCodes]{@link module:types~responseErrorCodes}.
   * @type {Number}
   */

  this.code = code;
  this.info = 'Represents an error message from the server';
}

util$J.inherits(ResponseError, DriverError);
/**
 * Represents a bug inside the driver or in a Cassandra host.
 * @param {String} message
 * @constructor
 */

function DriverInternalError(message) {
  DriverError.call(this, message);
  this.info = 'Represents a bug inside the driver or in a Cassandra host.';
}

util$J.inherits(DriverInternalError, DriverError);
/**
 * Represents an error when trying to authenticate with auth-enabled host
 * @param {String} message
 * @constructor
 */

function AuthenticationError(message) {
  DriverError.call(this, message);
  this.info = 'Represents an authentication error from the driver or from a Cassandra node.';
}

util$J.inherits(AuthenticationError, DriverError);
/**
 * Represents an error that is raised when one of the arguments provided to a method is not valid
 * @param {String} message
 * @constructor
 */

function ArgumentError(message) {
  DriverError.call(this, message);
  this.info = 'Represents an error that is raised when one of the arguments provided to a method is not valid.';
}

util$J.inherits(ArgumentError, DriverError);
/**
 * Represents a client-side error that is raised when the client didn't hear back from the server within
 * {@link ClientOptions.socketOptions.readTimeout}.
 * @param {String} message The error message.
 * @param {String} [host] Address of the server host that caused the operation to time out.
 * @constructor
 */

function OperationTimedOutError(message, host) {
  DriverError.call(this, message, this.constructor);
  this.info = 'Represents a client-side error that is raised when the client did not hear back from the server ' + 'within socketOptions.readTimeout';
  /**
   * When defined, it gets the address of the host that caused the operation to time out.
   * @type {String|undefined}
   */

  this.host = host;
}

util$J.inherits(OperationTimedOutError, DriverError);
/**
 * Represents an error that is raised when a feature is not supported in the driver or in the current Cassandra version.
 * @param message
 * @constructor
 */

function NotSupportedError(message) {
  DriverError.call(this, message, this.constructor);
  this.info = 'Represents a feature that is not supported in the driver or in the Cassandra version.';
}

util$J.inherits(NotSupportedError, DriverError);
/**
 * Represents a client-side error indicating that all connections to a certain host have reached
 * the maximum amount of in-flight requests supported.
 * @param {String} address
 * @param {Number} maxRequestsPerConnection
 * @param {Number} connectionLength
 * @constructor
 */

function BusyConnectionError(address, maxRequestsPerConnection, connectionLength) {
  var message = util$J.format('All connections to host %s are busy, %d requests are in-flight on %s', address, maxRequestsPerConnection, connectionLength === 1 ? 'a single connection' : 'each connection');
  DriverError.call(this, message, this.constructor);
  this.info = 'Represents a client-side error indicating that all connections to a certain host have reached ' + 'the maximum amount of in-flight requests supported (pooling.maxRequestsPerConnection)';
}

util$J.inherits(BusyConnectionError, DriverError);
errors$s.ArgumentError = ArgumentError;
errors$s.AuthenticationError = AuthenticationError;
errors$s.BusyConnectionError = BusyConnectionError;
errors$s.DriverError = DriverError;
errors$s.OperationTimedOutError = OperationTimedOutError;
errors$s.DriverInternalError = DriverInternalError;
errors$s.NoHostAvailableError = NoHostAvailableError;
errors$s.NotSupportedError = NotSupportedError;
errors$s.ResponseError = ResponseError;

/**
 * Creates a non-clearable timer that resolves the promise once elapses.
 * @param {number} ms
 * @returns {Promise<void>}
 */


function delay(ms) {
  return new Promise(function (r) {
    return setTimeout(r, ms || 0);
  });
}
/**
 * Creates a Promise that gets resolved or rejected based on an event.
 * @param {object} emitter
 * @param {string} eventName
 * @returns {Promise}
 */


function fromEvent(emitter, eventName) {
  return new Promise(function (resolve, reject) {
    return emitter.once(eventName, function (err, result) {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}
/**
 * Creates a Promise from a callback based function.
 * @param {Function} fn
 * @returns {Promise}
 */


function fromCallback(fn) {
  return new Promise(function (resolve, reject) {
    return fn(function (err, result) {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}
/**
 * Gets a function that has the signature of a callback that invokes the appropriate promise handler parameters.
 * @param {Function} resolve
 * @param {Function} reject
 * @returns {Function}
 */


function getCallback(resolve, reject) {
  return function (err, result) {
    if (err) {
      reject(err);
    } else {
      resolve(result);
    }
  };
}

function invokeSequentially(_x, _x2, _x3) {
  return _invokeSequentially.apply(this, arguments);
}
/**
 * Invokes the new query plan of the load balancing policy and returns a Promise.
 * @param {LoadBalancingPolicy} lbp The load balancing policy.
 * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.
 * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.
 * @returns {Promise<Iterator>}
 */


function _invokeSequentially() {
  _invokeSequentially = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(info, length, fn) {
    var index;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!((index = info.counter++) < length)) {
              _context.next = 5;
              break;
            }

            _context.next = 3;
            return fn(index);

          case 3:
            _context.next = 0;
            break;

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _invokeSequentially.apply(this, arguments);
}

function newQueryPlan(lbp, keyspace, executionOptions) {
  return new Promise(function (resolve, reject) {
    lbp.newQueryPlan(keyspace, executionOptions, function (err, iterator) {
      if (err) {
        reject(err);
      } else {
        resolve(iterator);
      }
    });
  });
}
/**
 * Method that handles optional callbacks (dual promise and callback support).
 * When callback is undefined it returns the promise.
 * When using a callback, it will use it as handlers of the continuation of the promise.
 * @param {Promise} promise
 * @param {Function?} callback
 * @returns {Promise|undefined}
 */


function optionalCallback(promise, callback) {
  if (!callback) {
    return promise;
  }

  toCallback(promise, callback);
}
/**
 * Invokes the provided function multiple times, considering the concurrency level limit.
 * @param {Number} count
 * @param {Number} limit
 * @param {Function} fn
 * @returns {Promise}
 */


function times$1(count, limit, fn) {
  if (limit > count) {
    limit = count;
  }

  var promises = new Array(limit);
  var info = {
    counter: 0
  };

  for (var i = 0; i < limit; i++) {
    promises[i] = invokeSequentially(info, count, fn);
  }

  return Promise.all(promises);
}
/**
 * Deals with unexpected rejections in order to avoid the unhandled promise rejection warning or failure.
 * @param {Promise} promise
 * @returns {undefined}
 */


function toBackground(promise) {
  promise["catch"](function () {});
}
/**
 * Invokes the callback once outside the promise chain the promise is resolved or rejected.
 * @param {Promise} promise
 * @param {Function?} callback
 * @returns {undefined}
 */


function toCallback(promise, callback) {
  promise.then(function (result) {
    return process.nextTick(function () {
      return callback(null, result);
    });
  }, // Avoid marking the promise as rejected
  function (err) {
    return process.nextTick(function () {
      return callback(err);
    });
  });
}

var promiseUtils$e = {
  delay: delay,
  fromCallback: fromCallback,
  fromEvent: fromEvent,
  getCallback: getCallback,
  newQueryPlan: newQueryPlan,
  optionalCallback: optionalCallback,
  times: times$1,
  toBackground: toBackground,
  toCallback: toCallback
};

var util$I = require$$0__default$1["default"];
var net$2 = require$$1__default["default"];
var EventEmitter$2 = require$$0__default$2["default"].EventEmitter;
var errors$r = errors$s;
var promiseUtils$d = promiseUtils$e;
/**
 * Max int that can be accurately represented with 64-bit Number (2^53)
 * @type {number}
 * @const
 */

var maxInt = 9007199254740992;
var maxInt32$1 = 0x7fffffff;
var emptyObject = Object.freeze({});
var emptyArray = Object.freeze([]);

function noop() {}
/**
 * Forward-compatible allocation of buffer, filled with zeros.
 * @type {Function}
 */


var allocBuffer = Buffer.alloc || allocBufferFillDeprecated;
/**
 * Forward-compatible unsafe allocation of buffer.
 * @type {Function}
 */

var allocBufferUnsafe = Buffer.allocUnsafe || allocBufferDeprecated;
/**
 * Forward-compatible allocation of buffer to contain a string.
 * @type {Function}
 */

var allocBufferFromString = Int8Array.from !== Buffer.from && Buffer.from || allocBufferFromStringDeprecated;
/**
 * Forward-compatible allocation of buffer from an array of bytes
 * @type {Function}
 */

var allocBufferFromArray = Int8Array.from !== Buffer.from && Buffer.from || allocBufferFromArrayDeprecated;

function allocBufferDeprecated(size) {
  // eslint-disable-next-line
  return new Buffer(size);
}

function allocBufferFillDeprecated(size) {
  var b = allocBufferDeprecated(size);
  b.fill(0);
  return b;
}

function allocBufferFromStringDeprecated(text, encoding) {
  if (typeof text !== 'string') {
    throw new TypeError('Expected string, obtained ' + util$I.inspect(text));
  } // eslint-disable-next-line


  return new Buffer(text, encoding);
}

function allocBufferFromArrayDeprecated(arr) {
  if (!Array.isArray(arr)) {
    throw new TypeError('Expected Array, obtained ' + util$I.inspect(arr));
  } // eslint-disable-next-line


  return new Buffer(arr);
}
/**
 * @returns {Function} Returns a wrapper function that invokes the underlying callback only once.
 * @param {Function} callback
 */


function callbackOnce(callback) {
  var cb = callback;
  return function wrapperCallback(err, result) {
    cb(err, result);
    cb = noop;
  };
}
/**
 * Creates a copy of a buffer
 */


function copyBuffer(buf) {
  var targetBuffer = allocBufferUnsafe(buf.length);
  buf.copy(targetBuffer);
  return targetBuffer;
}
/**
 * Appends the original stack trace to the error after a tick of the event loop
 */


function fixStack(stackTrace, error) {
  if (stackTrace) {
    error.stack += '\n  (event loop)\n' + stackTrace.substr(stackTrace.indexOf("\n") + 1);
  }

  return error;
}
/**
 * Uses the logEmitter to emit log events
 * @param {String} type
 * @param {String} info
 * @param [furtherInfo]
 */


function log(type, info, furtherInfo) {
  if (!this.logEmitter) {
    if (!this.options || !this.options.logEmitter) {
      throw new Error('Log emitter not defined');
    }

    this.logEmitter = this.options.logEmitter;
  }

  this.logEmitter('log', type, this.constructor.name, info, furtherInfo || '');
}
/**
 * Gets the sum of the length of the items of an array
 */


function totalLength(arr) {
  if (arr.length === 1) {
    return arr[0].length;
  }

  var total = 0;
  arr.forEach(function (item) {
    var length = item.length;
    length = length ? length : 0;
    total += length;
  });
  return total;
}
/**
 * Merge the contents of two or more objects together into the first object. Similar to jQuery.extend / Object.assign.
 * The main difference between this method is that declared properties with an <code>undefined</code> value are not set
 * to the target.
 */


function extend$1(target) {
  var sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    var keys = Object.keys(source);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = source[key];

      if (value === undefined) {
        continue;
      }

      target[key] = value;
    }
  });
  return target;
}
/**
 * Returns a new object with the property names set to lowercase.
 */


function toLowerCaseProperties(obj) {
  var keys = Object.keys(obj);
  var result = {};

  for (var i = 0; i < keys.length; i++) {
    var k = keys[i];
    result[k.toLowerCase()] = obj[k];
  }

  return result;
}
/**
 * Extends the target by the most inner props of sources
 * @param {Object} target
 * @returns {Object}
 */


function deepExtend(target) {
  var sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function (source) {
    for (var prop in source) {
      // eslint-disable-next-line no-prototype-builtins
      if (!source.hasOwnProperty(prop)) {
        continue;
      }

      var targetProp = target[prop];

      var targetType = _typeof(targetProp); //target prop is
      // a native single type
      // or not existent
      // or is not an anonymous object (not class instance)


      if (!targetProp || targetType === 'number' || targetType === 'string' || Array.isArray(targetProp) || util$I.isDate(targetProp) || targetProp.constructor.name !== 'Object') {
        target[prop] = source[prop];
      } else {
        //inner extend
        target[prop] = deepExtend({}, targetProp, source[prop]);
      }
    }
  });
  return target;
}

function propCompare(propName) {
  return function (a, b) {
    if (a[propName] > b[propName]) {
      return 1;
    }

    if (a[propName] < b[propName]) {
      return -1;
    }

    return 0;
  };
}

function funcCompare(name, argArray) {
  return function (a, b) {
    if (typeof a[name] === 'undefined') {
      return 0;
    }

    var valA = a[name].apply(a, argArray);
    var valB = b[name].apply(b, argArray);

    if (valA > valB) {
      return 1;
    }

    if (valA < valB) {
      return -1;
    }

    return 0;
  };
}
/**
 * Uses the iterator protocol to go through the items of the Array
 * @param {Array} arr
 * @returns {Iterator}
 */


function arrayIterator(arr) {
  return arr[Symbol.iterator]();
}
/**
 * Convert the iterator values into an array
 * @param iterator
 * @returns {Array}
 */


function iteratorToArray$1(iterator) {
  var values = [];
  var item = iterator.next();

  while (!item.done) {
    values.push(item.value);
    item = iterator.next();
  }

  return values;
}
/**
 * Searches the specified Array for the provided key using the binary
 * search algorithm.  The Array must be sorted.
 * @param {Array} arr
 * @param key
 * @param {function} compareFunc
 * @returns {number} The position of the key in the Array, if it is found.
 * If it is not found, it returns a negative number which is the bitwise complement of the index of the first element that is larger than key.
 */


function binarySearch(arr, key, compareFunc) {
  var low = 0;
  var high = arr.length - 1;

  while (low <= high) {
    var mid = low + high >>> 1;
    var midVal = arr[mid];
    var cmp = compareFunc(midVal, key);

    if (cmp < 0) {
      low = mid + 1;
    } else if (cmp > 0) {
      high = mid - 1;
    } else {
      //The key was found in the Array
      return mid;
    }
  } // key not found


  return ~low;
}
/**
 * Inserts the value in the position determined by its natural order determined by the compare func
 * @param {Array} arr
 * @param item
 * @param {function} compareFunc
 */


function insertSorted(arr, item, compareFunc) {
  if (arr.length === 0) {
    return arr.push(item);
  }

  var position = binarySearch(arr, item, compareFunc);

  if (position < 0) {
    position = ~position;
  }

  arr.splice(position, 0, item);
}
/**
 * Validates the provided parameter is of type function.
 * @param {Function} fn The instance to validate.
 * @param {String} [name] Name of the function to use in the error message. Defaults to 'callback'.
 * @returns {Function}
 */


function validateFn(fn, name) {
  if (typeof fn !== 'function') {
    throw new errors$r.ArgumentError(util$I.format('%s is not a function', name || 'callback'));
  }

  return fn;
}
/**
 * Adapts the parameters based on the prepared metadata.
 * If the params are passed as an associative array (Object),
 * it adapts the object into an array with the same order as columns
 * @param {Array|Object} params
 * @param {Array} columns
 * @returns {Array} Returns an array of parameters.
 * @throws {Error} In case a parameter with a specific name is not defined
 */


function adaptNamedParamsPrepared(params, columns) {
  if (!params || Array.isArray(params) || !columns || columns.length === 0) {
    // params is an array or there aren't parameters
    return params;
  }

  var paramsArray = new Array(columns.length);
  params = toLowerCaseProperties(params);
  var keys = {};

  for (var i = 0; i < columns.length; i++) {
    var name = columns[i].name; // eslint-disable-next-line no-prototype-builtins

    if (!params.hasOwnProperty(name)) {
      throw new errors$r.ArgumentError(util$I.format('Parameter "%s" not defined', name));
    }

    paramsArray[i] = params[name];
    keys[name] = i;
  }

  return paramsArray;
}
/**
 * Adapts the associative-array of parameters and hints for simple statements
 * into Arrays based on the (arbitrary) position of the keys.
 * @param {Array|Object} params
 * @param {ExecutionOptions} execOptions
 * @returns {{ params: Array<{name, value}>, namedParameters: boolean, keyIndexes: object }} Returns an array of
 * parameters and the keys as an associative array.
 */


function adaptNamedParamsWithHints(params, execOptions) {
  if (!params || Array.isArray(params)) {
    //The parameters is an Array or there isn't parameter
    return {
      params: params,
      namedParameters: false,
      keyIndexes: null
    };
  }

  var keys = Object.keys(params);
  var paramsArray = new Array(keys.length);
  var hints = new Array(keys.length);
  var userHints = execOptions.getHints() || emptyObject;
  var keyIndexes = {};

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]; // As lower cased identifiers

    paramsArray[i] = {
      name: key.toLowerCase(),
      value: params[key]
    };
    hints[i] = userHints[key];
    keyIndexes[key] = i;
  }

  execOptions.setHints(hints);
  return {
    params: paramsArray,
    namedParameters: true,
    keyIndexes: keyIndexes
  };
}
/**
 * Returns a string with a value repeated n times
 * @param {String} val
 * @param {Number} times
 * @returns {String}
 */


function stringRepeat(val, times) {
  if (!times || times < 0) {
    return null;
  }

  if (times === 1) {
    return val;
  }

  return new Array(times + 1).join(val);
}
/**
 * Returns an array containing the values of the Object, similar to Object.values().
 * If obj is null or undefined, it will return an empty array.
 * @param {Object} obj
 * @returns {Array}
 */


function objectValues(obj) {
  if (!obj) {
    return emptyArray;
  }

  var keys = Object.keys(obj);
  var values = new Array(keys.length);

  for (var i = 0; i < keys.length; i++) {
    values[i] = obj[keys[i]];
  }

  return values;
}
/**
 * Wraps the callback-based method. When no originalCallback is not defined, it returns a Promise.
 * @param {ClientOptions} options
 * @param {Function} originalCallback
 * @param {Function} handler
 * @returns {Promise|undefined}
 */


function promiseWrapper(options, originalCallback, handler) {
  if (typeof originalCallback === 'function') {
    // Callback-based invocation
    handler.call(this, originalCallback);
    return undefined;
  }

  var factory = options.promiseFactory || defaultPromiseFactory;
  var self = this;
  return factory(function handlerWrapper(callback) {
    handler.call(self, callback);
  });
}
/**
 * @param {Function} handler
 * @returns {Promise}
 */


function defaultPromiseFactory(handler) {
  return new Promise(function executor(resolve, reject) {
    handler(function handlerCallback(err, result) {
      if (err) {
        return reject(err);
      }

      resolve(result);
    });
  });
}
/**
 * Returns the first not undefined param
 */


function ifUndefined$1(v1, v2) {
  return v1 !== undefined ? v1 : v2;
}
/**
 * Returns the first not undefined param
 */


function ifUndefined3$1(v1, v2, v3) {
  if (v1 !== undefined) {
    return v1;
  }

  return v2 !== undefined ? v2 : v3;
}
/**
 * Shuffles an Array in-place.
 * @param {Array} arr
 * @returns {Array}
 * @private
 */


function shuffleArray(arr) {
  // Fisher–Yates algorithm
  for (var i = arr.length - 1; i > 0; i--) {
    // Math.random() has an extremely short permutation cycle length but we don't care about collisions
    var j = Math.floor(Math.random() * (i + 1));
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }

  return arr;
} // Classes

/**
 * Represents a unique set of values.
 * @constructor
 */


function HashSet() {
  this.length = 0;
  this.items = {};
}
/**
 * Adds a new item to the set.
 * @param {Object} key
 * @returns {boolean} Returns true if it was added to the set; false if the key is already present.
 */


HashSet.prototype.add = function (key) {
  if (this.contains(key)) {
    return false;
  }

  this.items[key] = true;
  this.length++;
  return true;
};
/**
 * @returns {boolean} Returns true if the key is present in the set.
 */


HashSet.prototype.contains = function (key) {
  return this.length > 0 && this.items[key] === true;
};
/**
 * Removes the item from set.
 * @param key
 * @return {boolean} Returns true if the key existed and was removed, otherwise it returns false.
 */


HashSet.prototype.remove = function (key) {
  if (!this.contains(key)) {
    return false;
  }

  delete this.items[key];
  this.length--;
};
/**
 * Returns an array containing the set items.
 * @returns {Array}
 */


HashSet.prototype.toArray = function () {
  return Object.keys(this.items);
};
/**
 * Utility class that resolves host names into addresses.
 */


var AddressResolver = /*#__PURE__*/function () {
  /**
   * Creates a new instance of the resolver.
   * @param {Object} options
   * @param {String} options.nameOrIp
   * @param {Object} [options.dns]
   */
  function AddressResolver(options) {
    _classCallCheck(this, AddressResolver);

    if (!options || !options.nameOrIp || !options.dns) {
      throw new Error('nameOrIp and dns lib must be provided as part of the options');
    }

    this._resolve4 = util$I.promisify(options.dns.resolve4);
    this._nameOrIp = options.nameOrIp;
    this._isIp = net$2.isIP(options.nameOrIp);
    this._index = 0;
    this._addresses = null;
    this._refreshing = null;
  }
  /**
   * Resolves the addresses for the host name.
   */


  _createClass(AddressResolver, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._isIp) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                _context.next = 4;
                return this._resolve();

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
    /**
     * Tries to resolve the addresses for the host name.
     */

  }, {
    key: "refresh",
    value: function () {
      var _refresh = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this._isIp) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                if (!this._refreshing) {
                  _context2.next = 6;
                  break;
                }

                _context2.next = 5;
                return promiseUtils$d.fromEvent(this._refreshing, 'finished');

              case 5:
                return _context2.abrupt("return", _context2.sent);

              case 6:
                this._refreshing = new EventEmitter$2().setMaxListeners(0);
                _context2.prev = 7;
                _context2.next = 10;
                return this._resolve();

              case 10:
                _context2.next = 14;
                break;

              case 12:
                _context2.prev = 12;
                _context2.t0 = _context2["catch"](7);

              case 14:
                this._refreshing.emit('finished');

                this._refreshing = null;

              case 16:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[7, 12]]);
      }));

      function refresh() {
        return _refresh.apply(this, arguments);
      }

      return refresh;
    }()
  }, {
    key: "_resolve",
    value: function () {
      var _resolve2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var arr;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._resolve4(this._nameOrIp);

              case 2:
                arr = _context3.sent;

                if (!(!arr || arr.length === 0)) {
                  _context3.next = 5;
                  break;
                }

                throw new Error("".concat(this._nameOrIp, " could not be resolved"));

              case 5:
                this._addresses = arr;

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _resolve() {
        return _resolve2.apply(this, arguments);
      }

      return _resolve;
    }()
    /**
     * Returns resolved ips in a round-robin fashion.
     */

  }, {
    key: "getIp",
    value: function getIp() {
      if (this._isIp) {
        return this._nameOrIp;
      }

      var item = this._addresses[this._index % this._addresses.length];
      this._index = this._index !== maxInt32$1 ? this._index + 1 : 0;
      return item;
    }
  }]);

  return AddressResolver;
}();
/**
 * @param {Array} arr
 * @param {Function} fn
 * @param {Function} [callback]
 */


function each(arr, fn, callback) {
  if (!Array.isArray(arr)) {
    throw new TypeError('First parameter is not an Array');
  }

  callback = callback || noop;
  var length = arr.length;

  if (length === 0) {
    return callback();
  }

  var completed = 0;

  for (var i = 0; i < length; i++) {
    fn(arr[i], next);
  }

  function next(err) {
    if (err) {
      var cb = callback;
      callback = noop;
      cb(err);
      return;
    }

    if (++completed !== length) {
      return;
    }

    callback();
  }
}
/**
 * @param {Array} arr
 * @param {Function} fn
 * @param {Function} [callback]
 */


function eachSeries(arr, fn, callback) {
  if (!Array.isArray(arr)) {
    throw new TypeError('First parameter is not an Array');
  }

  callback = callback || noop;
  var length = arr.length;

  if (length === 0) {
    return callback();
  }

  var sync;
  var index = 1;
  fn(arr[0], next);

  if (sync === undefined) {
    sync = false;
  }

  function next(err) {
    if (err) {
      return callback(err);
    }

    if (index >= length) {
      return callback();
    }

    if (sync === undefined) {
      sync = true;
    }

    if (sync) {
      return process.nextTick(function () {
        fn(arr[index++], next);
      });
    }

    fn(arr[index++], next);
  }
}
/**
 * @param {Array} arr
 * @param {Function} fn
 * @param {Function} [callback]
 */


function forEachOf(arr, fn, callback) {
  return mapEach(arr, fn, true, callback);
}
/**
 * @param {Array} arr
 * @param {Function} fn
 * @param {Function} [callback]
 */


function map(arr, fn, callback) {
  return mapEach(arr, fn, false, callback);
}

function mapEach(arr, fn, useIndex, callback) {
  if (!Array.isArray(arr)) {
    throw new TypeError('First parameter must be an Array');
  }

  callback = callback || noop;
  var length = arr.length;

  if (length === 0) {
    return callback(null, []);
  }

  var result = new Array(length);
  var completed = 0;
  var invoke = useIndex ? invokeWithIndex : invokeWithoutIndex;

  for (var i = 0; i < length; i++) {
    invoke(i);
  }

  function invokeWithoutIndex(i) {
    fn(arr[i], function mapItemCallback(err, transformed) {
      result[i] = transformed;
      next(err);
    });
  }

  function invokeWithIndex(i) {
    fn(arr[i], i, function mapItemCallback(err, transformed) {
      result[i] = transformed;
      next(err);
    });
  }

  function next(err) {
    if (err) {
      var cb = callback;
      callback = noop;
      cb(err);
      return;
    }

    if (++completed !== length) {
      return;
    }

    callback(null, result);
  }
}
/**
 * @param {Array} arr
 * @param {Function} fn
 * @param {Function} [callback]
 */


function mapSeries(arr, fn, callback) {
  if (!Array.isArray(arr)) {
    throw new TypeError('First parameter must be an Array');
  }

  callback = callback || noop;
  var length = arr.length;

  if (length === 0) {
    return callback(null, []);
  }

  var result = new Array(length);
  var index = 0;
  var sync;
  invoke(0);

  if (sync === undefined) {
    sync = false;
  }

  function invoke(i) {
    fn(arr[i], function mapItemCallback(err, transformed) {
      result[i] = transformed;
      next(err);
    });
  }

  function next(err) {
    if (err) {
      return callback(err);
    }

    if (++index === length) {
      return callback(null, result);
    }

    if (sync === undefined) {
      sync = true;
    }

    var i = index;

    if (sync) {
      return process.nextTick(function () {
        invoke(i);
      });
    }

    invoke(index);
  }
}
/**
 * @param {Array.<Function>} arr
 * @param {Function} [callback]
 */


function parallel(arr, callback) {
  if (!Array.isArray(arr)) {
    throw new TypeError('First parameter must be an Array');
  }

  callback = callback || noop;
  var length = arr.length;
  var completed = 0;

  for (var i = 0; i < length; i++) {
    arr[i](next);
  }

  function next(err) {
    if (err) {
      var cb = callback;
      callback = noop;
      return cb(err);
    }

    if (++completed !== length) {
      return;
    }

    callback();
  }
}
/**
 * Similar to async.series(), but instead accumulating the result in an Array, it callbacks with the result of the last
 * function in the array.
 * @param {Array.<Function>} arr
 * @param {Function} [callback]
 */


function series(arr, callback) {
  if (!Array.isArray(arr)) {
    throw new TypeError('First parameter must be an Array');
  }

  callback = callback || noop;
  var index = 0;
  var sync;
  next();

  function next(err, result) {
    if (err) {
      return callback(err);
    }

    if (index === arr.length) {
      return callback(null, result);
    }

    if (sync) {
      return process.nextTick(function () {
        sync = true;
        arr[index++](next);
        sync = false;
      });
    }

    sync = true;
    arr[index++](next);
    sync = false;
  }
}
/**
 * @param {Number} count
 * @param {Function} iteratorFunc
 * @param {Function} [callback]
 */


function times(count, iteratorFunc, callback) {
  callback = callback || noop;
  count = +count;

  if (isNaN(count) || count === 0) {
    return callback();
  }

  var completed = 0;

  for (var i = 0; i < count; i++) {
    iteratorFunc(i, next);
  }

  function next(err) {
    if (err) {
      var cb = callback;
      callback = noop;
      return cb(err);
    }

    if (++completed !== count) {
      return;
    }

    callback();
  }
}
/**
 * @param {Number} count
 * @param {Number} limit
 * @param {Function} iteratorFunc
 * @param {Function} [callback]
 */


function timesLimit(count, limit, iteratorFunc, callback) {
  var sync = undefined;
  callback = callback || noop;
  limit = Math.min(limit, count);
  var index = limit - 1;
  var i;
  var completed = 0;

  for (i = 0; i < limit; i++) {
    iteratorFunc(i, next);
  }

  i = -1;

  function next(err) {
    if (err) {
      var cb = callback;
      callback = noop;
      cb(err);
      return;
    }

    if (++completed === count) {
      return callback();
    }

    index++;

    if (index >= count) {
      return;
    }

    if (sync === undefined) {
      sync = i >= 0;
    }

    if (sync) {
      var captureIndex = index;
      return process.nextTick(function () {
        iteratorFunc(captureIndex, next);
      });
    }

    iteratorFunc(index, next);
  }
}
/**
 * @param {Number} count
 * @param {Function} iteratorFunction
 * @param {Function} callback
 */


function timesSeries(count, iteratorFunction, callback) {
  count = +count;

  if (isNaN(count) || count < 1) {
    return callback();
  }

  var index = 1;
  var sync;
  iteratorFunction(0, next);

  if (sync === undefined) {
    sync = false;
  }

  function next(err) {
    if (err) {
      return callback(err);
    }

    if (index === count) {
      return callback();
    }

    if (sync === undefined) {
      sync = true;
    }

    var i = index++;

    if (sync) {
      //Prevent "Maximum call stack size exceeded"
      return process.nextTick(function () {
        iteratorFunction(i, next);
      });
    } //do a sync call as the callback is going to call on a future tick


    iteratorFunction(i, next);
  }
}
/**
 * @param {Function} condition
 * @param {Function} fn
 * @param {Function} callback
 */


function whilst(condition, fn, callback) {
  var sync = 0;
  next();

  function next(err) {
    if (err) {
      return callback(err);
    }

    if (!condition()) {
      return callback();
    }

    if (sync === 0) {
      sync = 1;
      fn(function (err) {
        if (sync === 1) {
          //sync function
          sync = 4;
        }

        next(err);
      });

      if (sync === 1) {
        //async function
        sync = 2;
      }

      return;
    }

    if (sync === 4) {
      //Prevent "Maximum call stack size exceeded"
      return process.nextTick(function () {
        fn(next);
      });
    } //do a sync call as the callback is going to call on a future tick


    fn(next);
  }
}

utils$V.adaptNamedParamsPrepared = adaptNamedParamsPrepared;
utils$V.adaptNamedParamsWithHints = adaptNamedParamsWithHints;
utils$V.AddressResolver = AddressResolver;
utils$V.allocBuffer = allocBuffer;
utils$V.allocBufferUnsafe = allocBufferUnsafe;
utils$V.allocBufferFromArray = allocBufferFromArray;
utils$V.allocBufferFromString = allocBufferFromString;
utils$V.arrayIterator = arrayIterator;
utils$V.binarySearch = binarySearch;
utils$V.callbackOnce = callbackOnce;
utils$V.copyBuffer = copyBuffer;
utils$V.deepExtend = deepExtend;
utils$V.each = each;
utils$V.eachSeries = eachSeries;
/** @const */

utils$V.emptyArray = Object.freeze([]);
/** @const */

utils$V.emptyObject = emptyObject;
utils$V.extend = extend$1;
utils$V.fixStack = fixStack;
utils$V.forEachOf = forEachOf;
utils$V.funcCompare = funcCompare;
utils$V.ifUndefined = ifUndefined$1;
utils$V.ifUndefined3 = ifUndefined3$1;
utils$V.insertSorted = insertSorted;
utils$V.iteratorToArray = iteratorToArray$1;
utils$V.log = log;
utils$V.map = map;
utils$V.mapSeries = mapSeries;
utils$V.maxInt = maxInt;
utils$V.noop = noop;
utils$V.objectValues = objectValues;
utils$V.parallel = parallel;
utils$V.promiseWrapper = promiseWrapper;
utils$V.propCompare = propCompare;
utils$V.series = series;
utils$V.shuffleArray = shuffleArray;
utils$V.stringRepeat = stringRepeat;
utils$V.times = times;
utils$V.timesLimit = timesLimit;
utils$V.timesSeries = timesSeries;
utils$V.totalLength = totalLength;
utils$V.validateFn = validateFn;
utils$V.whilst = whilst;
utils$V.HashSet = HashSet;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var dns$2 = require$$0__default$3["default"];
var util$H = require$$0__default$1["default"];
var utils$U = utils$V;
/** @module policies/addressResolution */

/**
 * @class
 * @classdesc
 * Translates IP addresses received from Cassandra nodes into locally queryable
 * addresses.
 * <p>
 * The driver auto-detects new Cassandra nodes added to the cluster through server
 * side pushed notifications and through checking the system tables. For each
 * node, the address received will correspond to the address set as
 * <code>rpc_address</code> in the node yaml file. In most case, this is the correct
 * address to use by the driver and that is what is used by default. However,
 * sometimes the addresses received through this mechanism will either not be
 * reachable directly by the driver or should not be the preferred address to use
 * to reach the node (for instance, the <code>rpc_address</code> set on Cassandra nodes
 * might be a private IP, but some clients  may have to use a public IP, or
 * pass by a router to reach that node). This interface allows to deal with
 * such cases, by allowing to translate an address as sent by a Cassandra node
 * to another address to be used by the driver for connection.
 * <p>
 * Please note that the contact points addresses provided while creating the
 * {@link Client} instance are not "translated", only IP address retrieve from or sent
 * by Cassandra nodes to the driver are.
 * @constructor
 */

function AddressTranslator() {}
/**
 * Translates a Cassandra <code>rpc_address</code> to another address if necessary.
 * @param {String} address the address of a node as returned by Cassandra.
 * <p>
 * Note that if the <code>rpc_address</code> of a node has been configured to <code>0.0.0.0</code>
 * server side, then the provided address will be the node <code>listen_address</code>,
 * *not* <code>0.0.0.0</code>.
 * </p>
 * @param {Number} port The port number, as specified in the [protocolOptions]{@link ClientOptions} at Client instance creation (9042 by default).
 * @param {Function} callback Callback to invoke with endpoint as first parameter.
 * The endpoint is an string composed of the IP address and the port number in the format <code>ipAddress:port</code>.
 */


AddressTranslator.prototype.translate = function (address, port, callback) {
  callback(address + ':' + port);
};
/**
 * @class
 * @classdesc
 * {@link AddressTranslator} implementation for multi-region EC2 deployments <strong>where clients are also deployed in EC2</strong>.
 * <p>
 * Its distinctive feature is that it translates addresses according to the location of the Cassandra host:
 * </p>
 * <ul>
 *  <li>addresses in different EC2 regions (than the client) are unchanged</li>
 *  <li>addresses in the same EC2 region are <strong>translated to private IPs</strong></li>
 * </ul>
 * <p>
 * This optimizes network costs, because Amazon charges more for communication over public IPs.
 * </p>
 * @constructor
 */


function EC2MultiRegionTranslator() {}

util$H.inherits(EC2MultiRegionTranslator, AddressTranslator);
/**
 * Addresses in the same EC2 region are translated to private IPs and addresses in
 * different EC2 regions (than the client) are unchanged
 */

EC2MultiRegionTranslator.prototype.translate = function (address, port, callback) {
  var newAddress = address;
  var self = this;
  var name;
  utils$U.series([function resolve(next) {
    dns$2.reverse(address, function (err, hostNames) {
      if (err) {
        return next(err);
      }

      if (!hostNames) {
        return next();
      }

      name = hostNames[0];
      next();
    });
  }, function lookup(next) {
    if (!name) {
      return next();
    }

    dns$2.lookup(name, function (err, lookupAddress) {
      if (err) {
        return next(err);
      }

      newAddress = lookupAddress;
      next();
    });
  }], function (err) {
    if (err) {
      //there was an issue while doing dns resolution
      self.logError(address, err);
    }

    callback(newAddress + ':' + port);
  });
};
/**
 * Log method called to log errors that occurred while performing dns resolution.
 * You can assign your own method to the class instance to do proper logging.
 * @param {String} address
 * @param {Error} err
 */


EC2MultiRegionTranslator.prototype.logError = function (address, err) {//Do nothing by default
};

addressResolution$1.AddressTranslator = AddressTranslator;
addressResolution$1.EC2MultiRegionTranslator = EC2MultiRegionTranslator;

var types$u = {};

var Long$9 = {exports: {}};

/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

(function (module) {
  /**
   * @license Long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/Long.js for details
   */
  (function (global, factory) {
    /* AMD */
    if (typeof commonjsRequire === 'function' && 'object' === "object" && module && module["exports"]) module["exports"] = factory();
    /* Global */
    else (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();
  })(commonjsGlobal, function () {
    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */

    function Long(low, high, unsigned) {
      /**
       * The low 32 bits as a signed value.
       * @type {number}
       * @expose
       */
      this.low = low | 0;
      /**
       * The high 32 bits as a signed value.
       * @type {number}
       * @expose
       */

      this.high = high | 0;
      /**
       * Whether unsigned or not.
       * @type {boolean}
       * @expose
       */

      this.unsigned = !!unsigned;
    } // The internal representation of a long is the two given signed, 32-bit values.
    Object.defineProperty(Long.prototype, "__isLong__", {
      value: true,
      enumerable: false,
      configurable: false
    });
    /**
     * Tests if the specified object is a Long.
     * @param {*} obj Object
     * @returns {boolean}
     * @expose
     */

    Long.isLong = function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    };
    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */


    var INT_CACHE = {};
    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */

    var UINT_CACHE = {};
    /**
     * Returns a Long representing the given 32 bit integer value.
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */

    Long.fromInt = function fromInt(value, unsigned) {
      var obj, cachedObj;

      if (!unsigned) {
        value = value | 0;

        if (-128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj) return cachedObj;
        }

        obj = new Long(value, value < 0 ? -1 : 0, false);
        if (-128 <= value && value < 128) INT_CACHE[value] = obj;
        return obj;
      } else {
        value = value >>> 0;

        if (0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj) return cachedObj;
        }

        obj = new Long(value, (value | 0) < 0 ? -1 : 0, true);
        if (0 <= value && value < 256) UINT_CACHE[value] = obj;
        return obj;
      }
    };
    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */


    Long.fromNumber = function fromNumber(value, unsigned) {
      unsigned = !!unsigned;
      if (isNaN(value) || !isFinite(value)) return Long.ZERO;
      if (!unsigned && value <= -TWO_PWR_63_DBL) return Long.MIN_VALUE;
      if (!unsigned && value + 1 >= TWO_PWR_63_DBL) return Long.MAX_VALUE;
      if (unsigned && value >= TWO_PWR_64_DBL) return Long.MAX_UNSIGNED_VALUE;
      if (value < 0) return Long.fromNumber(-value, unsigned).negate();
      return new Long(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    };
    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     * @expose
     */


    Long.fromBits = function fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    };
    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     * @expose
     */


    Long.fromString = function fromString(str, unsigned, radix) {
      if (str.length === 0) throw Error('number format error: empty string');
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return Long.ZERO;
      if (typeof unsigned === 'number') // For goog.math.long compatibility
        radix = unsigned, unsigned = false;
      radix = radix || 10;
      if (radix < 2 || 36 < radix) throw Error('radix out of range: ' + radix);
      var p;
      if ((p = str.indexOf('-')) > 0) throw Error('number format error: interior "-" character: ' + str);else if (p === 0) return Long.fromString(str.substring(1), unsigned, radix).negate(); // Do several (8) digits each time through the loop, so as to
      // minimize the calls to the very expensive emulated div.

      var radixToPower = Long.fromNumber(Math.pow(radix, 8));
      var result = Long.ZERO;

      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);

        if (size < 8) {
          var power = Long.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Long.fromNumber(value));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Long.fromNumber(value));
        }
      }

      result.unsigned = unsigned;
      return result;
    };
    /**
     * Converts the specified value to a Long.
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     * @expose
     */


    Long.fromValue = function fromValue(val) {
      if (val
      /* is compatible */
      instanceof Long) return val;
      if (typeof val === 'number') return Long.fromNumber(val);
      if (typeof val === 'string') return Long.fromString(val); // Throws for non-objects, converts non-instanceof Long:

      return new Long(val.low, val.high, val.unsigned);
    }; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */


    var TWO_PWR_16_DBL = 1 << 16;
    /**
     * @type {number}
     * @const
     * @inner
     */

    var TWO_PWR_24_DBL = 1 << 24;
    /**
     * @type {number}
     * @const
     * @inner
     */

    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    /**
     * @type {number}
     * @const
     * @inner
     */

    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    /**
     * @type {number}
     * @const
     * @inner
     */

    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    /**
     * @type {!Long}
     * @const
     * @inner
     */

    var TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);
    /**
     * Signed zero.
     * @type {!Long}
     * @expose
     */

    Long.ZERO = Long.fromInt(0);
    /**
     * Unsigned zero.
     * @type {!Long}
     * @expose
     */

    Long.UZERO = Long.fromInt(0, true);
    /**
     * Signed one.
     * @type {!Long}
     * @expose
     */

    Long.ONE = Long.fromInt(1);
    /**
     * Unsigned one.
     * @type {!Long}
     * @expose
     */

    Long.UONE = Long.fromInt(1, true);
    /**
     * Signed negative one.
     * @type {!Long}
     * @expose
     */

    Long.NEG_ONE = Long.fromInt(-1);
    /**
     * Maximum signed value.
     * @type {!Long}
     * @expose
     */

    Long.MAX_VALUE = Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
    /**
     * Maximum unsigned value.
     * @type {!Long}
     * @expose
     */

    Long.MAX_UNSIGNED_VALUE = Long.fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
    /**
     * Minimum signed value.
     * @type {!Long}
     * @expose
     */

    Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);
    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     * @expose
     */

    Long.prototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     * @expose
     */


    Long.prototype.toNumber = function toNumber() {
      if (this.unsigned) {
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      }

      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     * @expose
     */


    Long.prototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix) throw RangeError('radix out of range: ' + radix);
      if (this.isZero()) return '0';
      var rem;

      if (this.isNegative()) {
        // Unsigned Longs are never negative
        if (this.equals(Long.MIN_VALUE)) {
          // We need to change the Long value before it can be negated, so we remove
          // the bottom-most digit in this base and then recurse to do the rest.
          var radixLong = Long.fromNumber(radix);
          var div = this.divide(radixLong);
          rem = div.multiply(radixLong).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else return '-' + this.negate().toString(radix);
      } // Do several (6) digits each time through the loop, so as to
      // minimize the calls to the very expensive emulated div.


      var radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);
      rem = this;
      var result = '';

      while (true) {
        var remDiv = rem.divide(radixToPower),
            intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) return digits + result;else {
          while (digits.length < 6) {
            digits = '0' + digits;
          }

          result = '' + digits + result;
        }
      }
    };
    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     * @expose
     */


    Long.prototype.getHighBits = function getHighBits() {
      return this.high;
    };
    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     * @expose
     */


    Long.prototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     * @expose
     */


    Long.prototype.getLowBits = function getLowBits() {
      return this.low;
    };
    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     * @expose
     */


    Long.prototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     * @expose
     */


    Long.prototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative()) // Unsigned Longs are never negative
        return this.equals(Long.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;

      for (var bit = 31; bit > 0; bit--) {
        if ((val & 1 << bit) != 0) break;
      }

      return this.high != 0 ? bit + 33 : bit + 1;
    };
    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     * @expose
     */


    Long.prototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     * @expose
     */


    Long.prototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     * @expose
     */


    Long.prototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     * @expose
     */


    Long.prototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     * @expose
     */


    Long.prototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */


    Long.prototype.equals = function equals(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
      return this.high === other.high && this.low === other.low;
    };
    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */


    Long.eq = Long.prototype.equals;
    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

    Long.prototype.notEquals = function notEquals(other) {
      return !this.equals(
      /* validates */
      other);
    };
    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */


    Long.neq = Long.prototype.notEquals;
    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

    Long.prototype.lessThan = function lessThan(other) {
      return this.compare(
      /* validates */
      other) < 0;
    };
    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */


    Long.prototype.lt = Long.prototype.lessThan;
    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

    Long.prototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.compare(
      /* validates */
      other) <= 0;
    };
    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */


    Long.prototype.lte = Long.prototype.lessThanOrEqual;
    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

    Long.prototype.greaterThan = function greaterThan(other) {
      return this.compare(
      /* validates */
      other) > 0;
    };
    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */


    Long.prototype.gt = Long.prototype.greaterThan;
    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

    Long.prototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.compare(
      /* validates */
      other) >= 0;
    };
    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     * @expose
     */


    Long.prototype.gte = Long.prototype.greaterThanOrEqual;
    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     * @expose
     */

    Long.prototype.compare = function compare(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      if (this.equals(other)) return 0;
      var thisNeg = this.isNegative(),
          otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) return -1;
      if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same

      if (!this.unsigned) return this.subtract(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned

      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     * @expose
     */


    Long.prototype.negate = function negate() {
      if (!this.unsigned && this.equals(Long.MIN_VALUE)) return Long.MIN_VALUE;
      return this.not().add(Long.ONE);
    };
    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     * @expose
     */


    Long.prototype.neg = Long.prototype.negate;
    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     * @expose
     */

    Long.prototype.add = function add(addend) {
      if (!Long.isLong(addend)) addend = Long.fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

      var a48 = this.high >>> 16;
      var a32 = this.high & 0xFFFF;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xFFFF;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 0xFFFF;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 0xFFFF;
      var c48 = 0,
          c32 = 0,
          c16 = 0,
          c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xFFFF;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c48 += a48 + b48;
      c48 &= 0xFFFF;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     * @expose
     */


    Long.prototype.subtract = function subtract(subtrahend) {
      if (!Long.isLong(subtrahend)) subtrahend = Long.fromValue(subtrahend);
      return this.add(subtrahend.negate());
    };
    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     * @expose
     */


    Long.prototype.sub = Long.prototype.subtract;
    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     * @expose
     */

    Long.prototype.multiply = function multiply(multiplier) {
      if (this.isZero()) return Long.ZERO;
      if (!Long.isLong(multiplier)) multiplier = Long.fromValue(multiplier);
      if (multiplier.isZero()) return Long.ZERO;
      if (this.equals(Long.MIN_VALUE)) return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (multiplier.equals(Long.MIN_VALUE)) return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;

      if (this.isNegative()) {
        if (multiplier.isNegative()) return this.negate().multiply(multiplier.negate());else return this.negate().multiply(multiplier).negate();
      } else if (multiplier.isNegative()) return this.multiply(multiplier.negate()).negate(); // If both longs are small, use float multiplication


      if (this.lessThan(TWO_PWR_24) && multiplier.lessThan(TWO_PWR_24)) return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
      // We can skip products that would overflow.

      var a48 = this.high >>> 16;
      var a32 = this.high & 0xFFFF;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xFFFF;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 0xFFFF;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 0xFFFF;
      var c48 = 0,
          c32 = 0,
          c16 = 0,
          c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 0xFFFF;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 0xFFFF;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     * @expose
     */


    Long.prototype.mul = Long.prototype.multiply;
    /**
     * Returns this Long divided by the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     * @expose
     */

    Long.prototype.divide = function divide(divisor) {
      if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);
      if (divisor.isZero()) throw new Error('division by zero');
      if (this.isZero()) return this.unsigned ? Long.UZERO : Long.ZERO;
      var approx, rem, res;

      if (this.equals(Long.MIN_VALUE)) {
        if (divisor.equals(Long.ONE) || divisor.equals(Long.NEG_ONE)) return Long.MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
        else if (divisor.equals(Long.MIN_VALUE)) return Long.ONE;else {
          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
          var halfThis = this.shiftRight(1);
          approx = halfThis.divide(divisor).shiftLeft(1);

          if (approx.equals(Long.ZERO)) {
            return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;
          } else {
            rem = this.subtract(divisor.multiply(approx));
            res = approx.add(rem.divide(divisor));
            return res;
          }
        }
      } else if (divisor.equals(Long.MIN_VALUE)) return this.unsigned ? Long.UZERO : Long.ZERO;

      if (this.isNegative()) {
        if (divisor.isNegative()) return this.negate().divide(divisor.negate());
        return this.negate().divide(divisor).negate();
      } else if (divisor.isNegative()) return this.divide(divisor.negate()).negate(); // Repeat the following until the remainder is less than other:  find a
      // floating-point that approximates remainder / other *from below*, add this
      // into the result, and subtract it from the remainder.  It is critical that
      // the approximate value is less than or equal to the real value so that the
      // remainder never becomes negative.


      res = Long.ZERO;
      rem = this;

      while (rem.greaterThanOrEqual(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.

        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48),
            // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
        approxRes = Long.fromNumber(approx),
            approxRem = approxRes.multiply(divisor);

        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Long.fromNumber(approx, this.unsigned);
          approxRem = approxRes.multiply(divisor);
        } // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.


        if (approxRes.isZero()) approxRes = Long.ONE;
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }

      return res;
    };
    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     * @expose
     */


    Long.prototype.div = Long.prototype.divide;
    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     * @expose
     */

    Long.prototype.modulo = function modulo(divisor) {
      if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);
      return this.subtract(this.divide(divisor).multiply(divisor));
    };
    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     * @expose
     */


    Long.prototype.mod = Long.prototype.modulo;
    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     * @expose
     */

    Long.prototype.not = function not() {
      return Long.fromBits(~this.low, ~this.high, this.unsigned);
    };
    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */


    Long.prototype.and = function and(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */


    Long.prototype.or = function or(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     * @expose
     */


    Long.prototype.xor = function xor(other) {
      if (!Long.isLong(other)) other = Long.fromValue(other);
      return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */


    Long.prototype.shiftLeft = function shiftLeft(numBits) {
      if (Long.isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;else if (numBits < 32) return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return Long.fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */


    Long.prototype.shl = Long.prototype.shiftLeft;
    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */

    Long.prototype.shiftRight = function shiftRight(numBits) {
      if (Long.isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;else if (numBits < 32) return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */


    Long.prototype.shr = Long.prototype.shiftRight;
    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */

    Long.prototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (Long.isLong(numBits)) numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0) return this;else {
        var high = this.high;

        if (numBits < 32) {
          var low = this.low;
          return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32) return Long.fromBits(high, 0, this.unsigned);else return Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     * @expose
     */


    Long.prototype.shru = Long.prototype.shiftRightUnsigned;
    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     * @expose
     */

    Long.prototype.toSigned = function toSigned() {
      if (!this.unsigned) return this;
      return new Long(this.low, this.high, false);
    };
    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     * @expose
     */


    Long.prototype.toUnsigned = function toUnsigned() {
      if (this.unsigned) return this;
      return new Long(this.low, this.high, true);
    };

    return Long;
  });
})(Long$9);

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var crypto$1 = require$$0__default$4["default"];
var utils$T = utils$V;
/** @module types */

/**
 * Creates a new instance of Uuid based on a Buffer
 * @class
 * @classdesc Represents an immutable universally unique identifier (UUID). A UUID represents a 128-bit value.
 * @param {Buffer} buffer The 16-length buffer.
 * @constructor
 */

function Uuid$2(buffer) {
  if (!buffer || buffer.length !== 16) {
    throw new Error('You must provide a buffer containing 16 bytes');
  }

  this.buffer = buffer;
}
/**
 * Parses a string representation of a Uuid
 * @param {String} value
 * @returns {Uuid}
 */


Uuid$2.fromString = function (value) {
  //36 chars: 32 + 4 hyphens
  if (typeof value !== 'string' || value.length !== 36) {
    throw new Error('Invalid string representation of Uuid, it should be in the 00000000-0000-0000-0000-000000000000');
  }

  return new Uuid$2(utils$T.allocBufferFromString(value.replace(/-/g, ''), 'hex'));
};
/**
 * Creates a new random (version 4) Uuid.
 * @param {function} [callback] Optional callback to be invoked with the error as first parameter and the created Uuid as
 * second parameter.
 * @returns {Uuid}
 */


Uuid$2.random = function (callback) {
  if (callback) {
    getRandomBytes$1(function (err, buffer) {
      if (err) {
        return callback(err);
      }

      return callback(null, createUuidFromBuffer(buffer));
    });
  } else {
    var buffer = getRandomBytes$1();
    return createUuidFromBuffer(buffer);
  }
};
/**
 * Gets the bytes representation of a Uuid
 * @returns {Buffer}
 */


Uuid$2.prototype.getBuffer = function () {
  return this.buffer;
};
/**
 * Compares this object to the specified object.
 * The result is true if and only if the argument is not null, is a UUID object, and contains the same value, bit for bit, as this UUID.
 * @param {Uuid} other The other value to test for equality.
 */


Uuid$2.prototype.equals = function (other) {
  return other instanceof Uuid$2 && this.buffer.equals(other.buffer);
};
/**
 * Returns a string representation of the value of this Uuid instance.
 * 32 hex separated by hyphens, in the form of 00000000-0000-0000-0000-000000000000.
 * @returns {String}
 */


Uuid$2.prototype.toString = function () {
  //32 hex representation of the Buffer
  var hexValue = getHex(this);
  return hexValue.substr(0, 8) + '-' + hexValue.substr(8, 4) + '-' + hexValue.substr(12, 4) + '-' + hexValue.substr(16, 4) + '-' + hexValue.substr(20, 12);
};
/**
 * Provide the name of the constructor and the string representation
 * @returns {string}
 */


Uuid$2.prototype.inspect = function () {
  return this.constructor.name + ': ' + this.toString();
};
/**
 * Returns the string representation.
 * Method used by the native JSON.stringify() to serialize this instance.
 */


Uuid$2.prototype.toJSON = function () {
  return this.toString();
};
/**
 * Returns new Uuid
 * @private
 * @returns {Uuid}
 */


function createUuidFromBuffer(buffer) {
  //clear the version
  buffer[6] &= 0x0f; //set the version 4

  buffer[6] |= 0x40; //clear the variant

  buffer[8] &= 0x3f; //set the IETF variant

  buffer[8] |= 0x80;
  return new Uuid$2(buffer);
}
/**
 * @private
 * @returns {String} 32 hex representation of the instance, without separators
 */


function getHex(uuid) {
  return uuid.buffer.toString('hex');
}
/**
 * Gets a crypto generated 16 bytes
 * @private
 * @returns {Buffer}
 */


function getRandomBytes$1(cb) {
  return crypto$1.randomBytes(16, cb);
}

var uuid$1 = Uuid$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$G = require$$0__default$1["default"];
var crypto = require$$0__default$4["default"];
var Long$8 = Long$9.exports;
var Uuid$1 = uuid$1;
var utils$S = utils$V;
/** @module types */

/**
 * Oct 15, 1582 in milliseconds since unix epoch
 * @const
 * @private
 */

var _unixToGregorian = 12219292800000;
/**
 * 10,000 ticks in a millisecond
 * @const
 * @private
 */

var _ticksInMs = 10000;
var minNodeId = utils$S.allocBufferFromString('808080808080', 'hex');
var minClockId = utils$S.allocBufferFromString('8080', 'hex');
var maxNodeId = utils$S.allocBufferFromString('7f7f7f7f7f7f', 'hex');
var maxClockId = utils$S.allocBufferFromString('7f7f', 'hex');
/**
 * Counter used to generate up to 10000 different timeuuid values with the same Date
 * @private
 * @type {number}
 */

var _ticks = 0;
/**
 * Counter used to generate ticks for the current time
 * @private
 * @type {number}
 */

var _ticksForCurrentTime = 0;
/**
 * Remember the last time when a ticks for the current time so that it can be reset
 * @private
 * @type {number}
 */

var _lastTimestamp = 0;
/**
 * Creates a new instance of Uuid based on the parameters provided according to rfc4122.
 * If any of the arguments is not provided, it will be randomly generated, except for the date that will use the current
 * date.
 * <p>
 *   Note that when nodeId and/or clockId portions are not provided, the constructor will generate them using
 *   <code>crypto.randomBytes()</code>. As it's possible that <code>crypto.randomBytes()</code> might block, it's
 *   recommended that you use the callback-based version of the static methods <code>fromDate()</code> or
 *   <code>now()</code> in that case.
 * </p>
 * @class
 * @classdesc Represents an immutable version 1 universally unique identifier (UUID). A UUID represents a 128-bit value.
 * <p>Usage: <code>TimeUuid.now()</code></p>
 * @extends module:types~Uuid
 * @param {Date} [value] The datetime for the instance, if not provided, it will use the current Date.
 * @param {Number} [ticks] A number from 0 to 10000 representing the 100-nanoseconds units for this instance to fill in the information not available in the Date,
 * as Ecmascript Dates have only milliseconds precision.
 * @param {String|Buffer} [nodeId] A 6-length Buffer or string of 6 ascii characters representing the node identifier, ie: 'host01'.
 * @param {String|Buffer} [clockId] A 2-length Buffer or string of 6 ascii characters representing the clock identifier.
 * @constructor
 */

function TimeUuid$1(value, ticks, nodeId, clockId) {
  var buffer;

  if (value instanceof Buffer) {
    if (value.length !== 16) {
      throw new Error('Buffer for v1 uuid not valid');
    }

    buffer = value;
  } else {
    buffer = generateBuffer(value, ticks, nodeId, clockId);
  }

  Uuid$1.call(this, buffer);
}

util$G.inherits(TimeUuid$1, Uuid$1);
/**
 * Generates a TimeUuid instance based on the Date provided using random node and clock values.
 * @param {Date} date Date to generate the v1 uuid.
 * @param {Number} [ticks] A number from 0 to 10000 representing the 100-nanoseconds units for this instance to fill in the information not available in the Date,
 * as Ecmascript Dates have only milliseconds precision.
 * @param {String|Buffer} [nodeId] A 6-length Buffer or string of 6 ascii characters representing the node identifier, ie: 'host01'.
 * If not provided, a random nodeId will be generated.
 * @param {String|Buffer} [clockId] A 2-length Buffer or string of 6 ascii characters representing the clock identifier.
 * If not provided a random clockId will be generated.
 * @param {Function} [callback] An optional callback to be invoked with the error as first parameter and the created
 * <code>TimeUuid</code> as second parameter. When a callback is provided, the random portions of the
 * <code>TimeUuid</code> instance are created asynchronously.
 * <p>
 *   When nodeId and/or clockId portions are not provided, this method will generate them using
 *   <code>crypto.randomBytes()</code>. As it's possible that <code>crypto.randomBytes()</code> might block, it's
 *   recommended that you use the callback-based version of this method in that case.
 * </p>
 * @example <caption>Generate a TimeUuid from a ECMAScript Date</caption>
 * const timeuuid = TimeUuid.fromDate(new Date());
 * @example <caption>Generate a TimeUuid from a Date with ticks portion</caption>
 * const timeuuid = TimeUuid.fromDate(new Date(), 1203);
 * @example <caption>Generate a TimeUuid from a Date without any random portion</caption>
 * const timeuuid = TimeUuid.fromDate(new Date(), 1203, 'host01', '02');
 * @example <caption>Generate a TimeUuid from a Date with random node and clock identifiers</caption>
 * TimeUuid.fromDate(new Date(), 1203, function (err, timeuuid) {
 *   // do something with the generated timeuuid
 * });
 */

TimeUuid$1.fromDate = function (date, ticks, nodeId, clockId, callback) {
  if (typeof ticks === 'function') {
    callback = ticks;
    ticks = nodeId = clockId = null;
  } else if (typeof nodeId === 'function') {
    callback = nodeId;
    nodeId = clockId = null;
  } else if (typeof clockId === 'function') {
    callback = clockId;
    clockId = null;
  }

  if (!callback) {
    return new TimeUuid$1(date, ticks, nodeId, clockId);
  }

  utils$S.parallel([function (next) {
    return getOrGenerateRandom(nodeId, 6, function (err, buffer) {
      return next(err, nodeId = buffer);
    });
  }, function (next) {
    return getOrGenerateRandom(clockId, 2, function (err, buffer) {
      return next(err, clockId = buffer);
    });
  }], function (err) {
    if (err) {
      return callback(err);
    }

    var timeUuid;

    try {
      timeUuid = new TimeUuid$1(date, ticks, nodeId, clockId);
    } catch (e) {
      return callback(e);
    }

    callback(null, timeUuid);
  });
};
/**
 * Parses a string representation of a TimeUuid
 * @param {String} value
 * @returns {TimeUuid}
 */


TimeUuid$1.fromString = function (value) {
  return new TimeUuid$1(Uuid$1.fromString(value).getBuffer());
};
/**
 * Returns the smaller possible type 1 uuid with the provided Date.
 */


TimeUuid$1.min = function (date, ticks) {
  return new TimeUuid$1(date, ticks, minNodeId, minClockId);
};
/**
 * Returns the biggest possible type 1 uuid with the provided Date.
 */


TimeUuid$1.max = function (date, ticks) {
  return new TimeUuid$1(date, ticks, maxNodeId, maxClockId);
};
/**
 * Generates a TimeUuid instance based on the current date using random node and clock values.
 * @param {String|Buffer} [nodeId] A 6-length Buffer or string of 6 ascii characters representing the node identifier, ie: 'host01'.
 * If not provided, a random nodeId will be generated.
 * @param {String|Buffer} [clockId] A 2-length Buffer or string of 6 ascii characters representing the clock identifier.
 * If not provided a random clockId will be generated.
 * @param {Function} [callback] An optional callback to be invoked with the error as first parameter and the created
 * <code>TimeUuid</code> as second parameter. When a callback is provided, the random portions of the
 * <code>TimeUuid</code> instance are created asynchronously.
 * <p>
 *   When nodeId and/or clockId portions are not provided, this method will generate them using
 *   <code>crypto.randomBytes()</code>. As it's possible that <code>crypto.randomBytes()</code> might block, it's
 *   recommended that you use the callback-based version of this method in that case.
 * </p>
 * @example <caption>Generate a TimeUuid from a Date without any random portion</caption>
 * const timeuuid = TimeUuid.now('host01', '02');
 * @example <caption>Generate a TimeUuid with random node and clock identifiers</caption>
 * TimeUuid.now(function (err, timeuuid) {
 *   // do something with the generated timeuuid
 * });
 * @example <caption>Generate a TimeUuid based on the current date (might block)</caption>
 * const timeuuid = TimeUuid.now();
 */


TimeUuid$1.now = function (nodeId, clockId, callback) {
  return TimeUuid$1.fromDate(null, null, nodeId, clockId, callback);
};
/**
 * Gets the Date and 100-nanoseconds units representation of this instance.
 * @returns {{date: Date, ticks: Number}}
 */


TimeUuid$1.prototype.getDatePrecision = function () {
  var timeLow = this.buffer.readUInt32BE(0);
  var timeHigh = 0;
  timeHigh |= (this.buffer[4] & 0xff) << 8;
  timeHigh |= this.buffer[5] & 0xff;
  timeHigh |= (this.buffer[6] & 0x0f) << 24;
  timeHigh |= (this.buffer[7] & 0xff) << 16;
  var val = Long$8.fromBits(timeLow, timeHigh);
  var ticksInMsLong = Long$8.fromNumber(_ticksInMs);
  var ticks = val.modulo(ticksInMsLong);
  var time = val.div(ticksInMsLong).subtract(Long$8.fromNumber(_unixToGregorian));
  return {
    date: new Date(time.toNumber()),
    ticks: ticks.toNumber()
  };
};
/**
 * Gets the Date representation of this instance.
 * @returns {Date}
 */


TimeUuid$1.prototype.getDate = function () {
  return this.getDatePrecision().date;
};
/**
 * Returns the node id this instance
 * @returns {Buffer}
 */


TimeUuid$1.prototype.getNodeId = function () {
  return this.buffer.slice(10);
};
/**
 * Returns the clock id this instance, with the variant applied (first 2 msb being 1 and 0).
 * @returns {Buffer}
 */


TimeUuid$1.prototype.getClockId = function () {
  return this.buffer.slice(8, 10);
};
/**
 * Returns the node id this instance as an ascii string
 * @returns {String}
 */


TimeUuid$1.prototype.getNodeIdString = function () {
  return this.buffer.slice(10).toString('ascii');
};

function writeTime(buffer, time, ticks) {
  //value time expressed in ticks precision
  var val = Long$8.fromNumber(time + _unixToGregorian).multiply(Long$8.fromNumber(10000)).add(Long$8.fromNumber(ticks));
  var timeHigh = val.getHighBitsUnsigned();
  buffer.writeUInt32BE(val.getLowBitsUnsigned(), 0);
  buffer.writeUInt16BE(timeHigh & 0xffff, 4);
  buffer.writeUInt16BE(timeHigh >>> 16 & 0xffff, 6);
}
/**
 * Returns a buffer of length 2 representing the clock identifier
 * @param {String|Buffer} clockId
 * @returns {Buffer}
 * @private
 */


function getClockId(clockId) {
  var buffer = clockId;

  if (typeof clockId === 'string') {
    buffer = utils$S.allocBufferFromString(clockId, 'ascii');
  }

  if (!(buffer instanceof Buffer)) {
    //Generate
    buffer = getRandomBytes(2);
  } else if (buffer.length !== 2) {
    throw new Error('Clock identifier must have 2 bytes');
  }

  return buffer;
}
/**
 * Returns a buffer of length 6 representing the clock identifier
 * @param {String|Buffer} nodeId
 * @returns {Buffer}
 * @private
 */


function getNodeId(nodeId) {
  var buffer = nodeId;

  if (typeof nodeId === 'string') {
    buffer = utils$S.allocBufferFromString(nodeId, 'ascii');
  }

  if (!(buffer instanceof Buffer)) {
    //Generate
    buffer = getRandomBytes(6);
  } else if (buffer.length !== 6) {
    throw new Error('Node identifier must have 6 bytes');
  }

  return buffer;
}
/**
 * Returns the ticks portion of a timestamp.  If the ticks are not provided an internal counter is used that gets reset at 10000.
 * @private
 * @param {Number} [ticks] 
 * @returns {Number} 
 */


function getTicks(ticks) {
  if (typeof ticks !== 'number' || ticks >= _ticksInMs) {
    _ticks++;

    if (_ticks >= _ticksInMs) {
      _ticks = 0;
    }

    ticks = _ticks;
  }

  return ticks;
}
/**
 * Returns an object with the time representation of the date expressed in milliseconds since unix epoch 
 * and a ticks property for the 100-nanoseconds precision.
 * @private
 * @returns {{time: Number, ticks: Number}} 
 */


function getTimeWithTicks(date, ticks) {
  if (!(date instanceof Date) || isNaN(date.getTime())) {
    // time with ticks for the current time
    date = new Date();
    var time = date.getTime();
    _ticksForCurrentTime++;

    if (_ticksForCurrentTime > _ticksInMs || time > _lastTimestamp) {
      _ticksForCurrentTime = 0;
      _lastTimestamp = time;
    }

    ticks = _ticksForCurrentTime;
  }

  return {
    time: date.getTime(),
    ticks: getTicks(ticks)
  };
}

function getRandomBytes(length) {
  return crypto.randomBytes(length);
}

function getOrGenerateRandom(id, length, callback) {
  if (id) {
    return callback(null, id);
  }

  crypto.randomBytes(length, callback);
}
/**
 * Generates a 16-length Buffer instance
 * @private
 * @param {Date} date
 * @param {Number} ticks
 * @param {String|Buffer} nodeId
 * @param {String|Buffer} clockId
 * @returns {Buffer}
 */


function generateBuffer(date, ticks, nodeId, clockId) {
  var timeWithTicks = getTimeWithTicks(date, ticks);
  nodeId = getNodeId(nodeId);
  clockId = getClockId(clockId);
  var buffer = utils$S.allocBufferUnsafe(16); //Positions 0-7 Timestamp

  writeTime(buffer, timeWithTicks.time, timeWithTicks.ticks); //Position 8-9 Clock

  clockId.copy(buffer, 8, 0); //Positions 10-15 Node

  nodeId.copy(buffer, 10, 0); //Version Byte: Time based
  //0001xxxx
  //turn off first 4 bits

  buffer[6] = buffer[6] & 0x0f; //turn on fifth bit

  buffer[6] = buffer[6] | 0x10; //IETF Variant Byte: 1.0.x
  //10xxxxxx
  //turn off first 2 bits

  buffer[8] = buffer[8] & 0x3f; //turn on first bit

  buffer[8] = buffer[8] | 0x80;
  return buffer;
}

var timeUuid = TimeUuid$1;

var _versionPattern = /(\d+)\.(\d+)(?:\.(\d+))?(?:\.(\d+)?)?(?:[-~]([\w+]*(?:-\w[.\w]*)*))?(?:\+([.\w]+))?/;
/**
 * Represents a version number in the form of X.Y.Z with optional pre-release and build metadata.
 *
 * Version numbers compare the usual way, the major version number (X) is compared first, then
 * the minor one (Y) and then the patch level one (Z).  If pre-release or other build metadata
 * is present for a version, that version is considered less than an otherwise equivalent version
 * that doesn't have these labels, otherwise they are considered equal.
 *
 * As of initial implementation versions are only compared against those with at most patch versions
 * more refined comparisons are not needed.
 *
 * @property {Number} major The major version, X of X.Y.Z.
 * @property {Number} minor The minor version, Y of X.Y.Z.
 * @property {Number} patch The patch version, Z of X.Y.Z.
 * @property {Number} dsePatch The dsePatch version, A of X.Y.Z.A or undefined if not present.
 * @property {String[]} preReleases Prerelease indicators if present, i.e. SNAPSHOT of X.Y.Z-SNAPSHOT.
 * @property {String} build Build string if present, i.e. build1 of X.Y.Z+build1.
 *
 * @ignore
 */

var VersionNumber$2 = /*#__PURE__*/function () {
  function VersionNumber(major, minor, patch, dsePatch, preReleases, build) {
    _classCallCheck(this, VersionNumber);

    this.major = major;
    this.minor = minor;
    this.patch = patch;
    this.dsePatch = dsePatch;
    this.preReleases = preReleases;
    this.build = build;
  }
  /**
   * @return {String} String representation of this version.
   */


  _createClass(VersionNumber, [{
    key: "toString",
    value: function toString() {
      var str = this.major + '.' + this.minor;

      if (this.patch !== undefined) {
        str += '.' + this.patch;
      }

      if (this.dsePatch !== undefined) {
        str += '.' + this.dsePatch;
      }

      if (this.preReleases !== undefined) {
        this.preReleases.forEach(function (preRelease) {
          str += '-' + preRelease;
        });
      }

      if (this.build) {
        str += '+' + this.build;
      }

      return str;
    }
    /**
     * Compares this version with the provided version. 
     * @param {VersionNumber} other 
     * @return {Number} -1 if less than other, 0 if equal, 1 if greater than.
     */

  }, {
    key: "compare",
    value: function compare(other) {
      if (this.major < other.major) {
        return -1;
      } else if (this.major > other.major) {
        return 1;
      } else if (this.minor < other.minor) {
        return -1;
      } else if (this.minor > other.minor) {
        return 1;
      } // sanitize patch by setting to 0 if undefined.


      var thisPatch = this.patch || 0;
      var otherPatch = other.patch || 0;

      if (thisPatch < otherPatch) {
        return -1;
      } else if (thisPatch > otherPatch) {
        return 1;
      } // if dsePatch is set in one case, but not other, consider the one where it is set as greater.


      if (this.dsePatch === undefined) {
        if (other.dsePatch !== undefined) {
          return -1;
        }
      } else if (other.dsePatch === undefined) {
        return 1;
      } else {
        if (this.dsePatch < other.dsePatch) {
          return -1;
        } else if (this.dsePatch > other.dsePatch) {
          return 1;
        }
      } // If prereleases are present, consider less than those that don't have any.


      if (this.preReleases === undefined) {
        if (other.preReleases !== undefined) {
          return 1;
        }
      } else if (other.preReleases === undefined) {
        return -1;
      } // Don't consider build.


      return 0;
    }
  }], [{
    key: "parse",
    value: function parse(version) {
      if (!version) {
        return null;
      }

      var match = version.match(_versionPattern);

      if (match) {
        var major = parseInt(match[1], 10);
        var minor = parseInt(match[2], 10);
        var patch = match[3] ? parseInt(match[3], 10) : undefined;
        var dsePatch = match[4] ? parseInt(match[4], 10) : undefined;
        var preReleases = match[5] ? match[5].split('-') : undefined;
        var build = match[6];
        return new VersionNumber(major, minor, patch, dsePatch, preReleases, build);
      }

      throw new TypeError('Could not extract version from \'' + version + '\'');
    }
  }]);

  return VersionNumber;
}();

var versionNumber = VersionNumber$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var utils$R = utils$V;
var VersionNumber$1 = versionNumber;
var v200 = VersionNumber$1.parse('2.0.0');
var v210 = VersionNumber$1.parse('2.1.0');
var v220 = VersionNumber$1.parse('2.2.0');
var v300 = VersionNumber$1.parse('3.0.0');
var v510 = VersionNumber$1.parse('5.1.0');
var v600 = VersionNumber$1.parse('6.0.0');
/**
 * Contains information for the different protocol versions supported by the driver.
 * @type {Object}
 * @property {Number} v1 Cassandra protocol v1, supported in Apache Cassandra 1.2-->2.2.
 * @property {Number} v2 Cassandra protocol v2, supported in Apache Cassandra 2.0-->2.2.
 * @property {Number} v3 Cassandra protocol v3, supported in Apache Cassandra 2.1-->3.x.
 * @property {Number} v4 Cassandra protocol v4, supported in Apache Cassandra 2.2-->3.x.
 * @property {Number} v5 Cassandra protocol v5, in beta from Apache Cassandra 3.x+. Currently not supported by the
 * driver.
 * @property {Number} dseV1 DataStax Enterprise protocol v1, DSE 5.1+
 * @property {Number} dseV2 DataStax Enterprise protocol v2, DSE 6.0+
 * @property {Number} maxSupported Returns the higher protocol version that is supported by this driver.
 * @property {Number} minSupported Returns the lower protocol version that is supported by this driver.
 * @property {Function} isSupported A function that returns a boolean determining whether a given protocol version
 * is supported.
 * @alias module:types~protocolVersion
 */

var protocolVersion$1 = {
  // Strict equality operators to compare versions are allowed, other comparison operators are discouraged. Instead,
  // use a function that checks if a functionality is present on a certain version, for maintainability purposes.
  v1: 0x01,
  v2: 0x02,
  v3: 0x03,
  v4: 0x04,
  v5: 0x05,
  v6: 0x06,
  dseV1: 0x41,
  dseV2: 0x42,
  maxSupported: 0x42,
  minSupported: 0x01,

  /**
   * Determines whether the protocol version is a DSE-specific protocol version.
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  isDse: function isDse(version) {
    return version >= this.dseV1 && version <= this.dseV2;
  },

  /**
   * Returns true if the protocol version represents a version of Cassandra
   * supported by this driver, false otherwise
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  isSupportedCassandra: function isSupportedCassandra(version) {
    return version <= 0x04 && version >= 0x01;
  },

  /**
   * Determines whether the protocol version is supported by this driver.
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  isSupported: function isSupported(version) {
    return this.isDse(version) || this.isSupportedCassandra(version);
  },

  /**
   * Determines whether the protocol includes flags for PREPARE messages.
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  supportsPrepareFlags: function supportsPrepareFlags(version) {
    return version === this.dseV2;
  },

  /**
   * Determines whether the protocol supports sending the keyspace as part of PREPARE, QUERY, EXECUTE, and BATCH.
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  supportsKeyspaceInRequest: function supportsKeyspaceInRequest(version) {
    return version === this.dseV2;
  },

  /**
   * Determines whether the protocol supports result_metadata_id on `prepared` response and
   * and `execute` request.
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  supportsResultMetadataId: function supportsResultMetadataId(version) {
    return version === this.dseV2;
  },

  /**
   * Determines whether the protocol supports partition key indexes in the `prepared` RESULT responses.
   * @param {Number} version
   * @returns {Boolean}
   * @ignore
   */
  supportsPreparedPartitionKey: function supportsPreparedPartitionKey(version) {
    return version >= this.v4;
  },

  /**
   * Determines whether the protocol supports up to 4 strings (ie: change_type, target, keyspace and table) in the
   * schema change responses.
   * @param version
   * @return {boolean}
   * @ignore
   */
  supportsSchemaChangeFullMetadata: function supportsSchemaChangeFullMetadata(version) {
    return version >= this.v3;
  },

  /**
   * Determines whether the protocol supports continuous paging.
   * @param version
   * @return {boolean}
   * @ignore
   */
  supportsContinuousPaging: function supportsContinuousPaging(version) {
    return this.isDse(version);
  },

  /**
   * Determines whether the protocol supports paging state and serial consistency parameters in QUERY and EXECUTE
   * requests.
   * @param version
   * @return {boolean}
   * @ignore
   */
  supportsPaging: function supportsPaging(version) {
    return version >= this.v2;
  },

  /**
   * Determines whether the protocol supports timestamps parameters in BATCH, QUERY and EXECUTE requests.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  supportsTimestamp: function supportsTimestamp(version) {
    return version >= this.v3;
  },

  /**
   * Determines whether the protocol supports named parameters in QUERY and EXECUTE requests.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  supportsNamedParameters: function supportsNamedParameters(version) {
    return version >= this.v3;
  },

  /**
   * Determines whether the protocol supports unset parameters.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  supportsUnset: function supportsUnset(version) {
    return version >= this.v4;
  },

  /**
   * Determines whether the protocol provides a reason map for read and write failure errors.
   * @param version
   * @return {boolean}
   * @ignore
   */
  supportsFailureReasonMap: function supportsFailureReasonMap(version) {
    return version >= this.v5;
  },

  /**
   * Determines whether the protocol supports timestamp and serial consistency parameters in BATCH requests.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  uses2BytesStreamIds: function uses2BytesStreamIds(version) {
    return version >= this.v3;
  },

  /**
   * Determines whether the collection length is encoded using 32 bits.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  uses4BytesCollectionLength: function uses4BytesCollectionLength(version) {
    return version >= this.v3;
  },

  /**
   * Determines whether the QUERY, EXECUTE and BATCH flags are encoded using 32 bits.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  uses4BytesQueryFlags: function uses4BytesQueryFlags(version) {
    return this.isDse(version);
  },

  /**
   * Startup responses using protocol v4+ can be a SERVER_ERROR wrapping a ProtocolException, this method returns true
   * when is possible to receive such error.
   * @param {Number} version
   * @return {boolean}
   * @ignore
   */
  canStartupResponseErrorBeWrapped: function canStartupResponseErrorBeWrapped(version) {
    return version >= this.v4;
  },

  /**
   * Gets the first version number that is supported, lower than the one provided.
   * Returns zero when there isn't a lower supported version.
   * @param {Number} version
   * @return {Number}
   * @ignore
   */
  getLowerSupported: function getLowerSupported(version) {
    if (version >= this.v5) {
      return this.v4;
    }

    if (version <= this.v1) {
      return 0;
    }

    return version - 1;
  },

  /**
   * Computes the highest supported protocol version collectively by the given hosts.
   *
   * Considers the cassandra_version of the input hosts to determine what protocol versions
   * are supported and uses the highest common protocol version among them.
   *
   * If hosts >= C* 3.0 are detected, any hosts older than C* 2.1 will not be considered
   * as those cannot be connected to.  In general this will not be a problem as C* does
   * not support clusters with nodes that have versions that are more than one major
   * version away from each other.
   * @param {Connection} connection Connection hosts were discovered from.
   * @param {Array.<Host>} hosts The hosts to determine highest protocol version from.
   * @return {Number} Highest supported protocol version among hosts.
   */
  getHighestCommon: function getHighestCommon(connection, hosts) {
    var _this = this;

    var log = connection.log ? connection.log.bind(connection) : utils$R.noop;
    var maxVersion = connection.protocolVersion; // whether or not protocol v3 is required (nodes detected that don't support < 3).

    var v3Requirement = false; // track the common protocol version >= v3 in case we encounter older versions.

    var maxVersionWith3OrMore = maxVersion;
    hosts.forEach(function (h) {
      var dseVersion = null;

      if (h.dseVersion) {
        // As of DSE 5.1, DSE has it's own specific protocol versions.  If we detect 5.1+
        // consider those protocol versions.
        dseVersion = VersionNumber$1.parse(h.dseVersion);
        log('verbose', "Encountered host ".concat(h.address, " with dse version ").concat(dseVersion));

        if (dseVersion.compare(v510) >= 0) {
          v3Requirement = true;

          if (dseVersion.compare(v600) >= 0) {
            maxVersion = Math.min(_this.dseV2, maxVersion);
          } else {
            maxVersion = Math.min(_this.dseV1, maxVersion);
          }

          maxVersionWith3OrMore = maxVersion;
          return;
        } // If DSE < 5.1, we fall back on the cassandra protocol logic.

      }

      if (!h.cassandraVersion || h.cassandraVersion.length === 0) {
        log('warning', 'Encountered host ' + h.address + ' with no cassandra version,' + ' skipping as part of protocol version evaluation');
        return;
      }

      try {
        var cassandraVersion = VersionNumber$1.parse(h.cassandraVersion);

        if (!dseVersion) {
          log('verbose', 'Encountered host ' + h.address + ' with cassandra version ' + cassandraVersion);
        }

        if (cassandraVersion.compare(v300) >= 0) {
          // Anything 3.0.0+ has a max protocol version of V4 and requires at least V3.
          v3Requirement = true;
          maxVersion = Math.min(_this.v4, maxVersion);
          maxVersionWith3OrMore = maxVersion;
        } else if (cassandraVersion.compare(v220) >= 0) {
          // Cassandra 2.2.x has a max protocol version of V4.
          maxVersion = Math.min(_this.v4, maxVersion);
          maxVersionWith3OrMore = maxVersion;
        } else if (cassandraVersion.compare(v210) >= 0) {
          // Cassandra 2.1.x has a max protocol version of V3.
          maxVersion = Math.min(_this.v3, maxVersion);
          maxVersionWith3OrMore = maxVersion;
        } else if (cassandraVersion.compare(v200) >= 0) {
          // Cassandra 2.0.x has a max protocol version of V2.
          maxVersion = Math.min(_this.v2, maxVersion);
        } else {
          // Anything else is < 2.x and requires protocol version V1.
          maxVersion = _this.v1;
        }
      } catch (e) {
        log('warning', 'Encountered host ' + h.address + ' with unparseable cassandra version ' + h.cassandraVersion + ' skipping as part of protocol version evaluation');
      }
    });

    if (v3Requirement && maxVersion < this.v3) {
      var addendum = '. This should not be possible as nodes within a cluster can\'t be separated by more than one major version';

      if (maxVersionWith3OrMore < this.v3) {
        log('error', 'Detected hosts that require at least protocol version 0x3, but currently connected to ' + connection.address + ':' + connection.port + ' using protocol version 0x' + maxVersionWith3OrMore + '. Will not be able to connect to these hosts' + addendum);
      } else {
        log('error', 'Detected hosts with maximum protocol version of 0x' + maxVersion.toString(16) + ' but there are some hosts that require at least version 0x3. Will not be able to connect to these older hosts' + addendum);
      }

      maxVersion = maxVersionWith3OrMore;
    }

    log('verbose', 'Resolved protocol version 0x' + maxVersion.toString(16) + ' as the highest common protocol version among hosts');
    return maxVersion;
  },

  /**
   * Determines if the protocol is a BETA version of the protocol.
   * @param {Number} version
   * @return {Number}
   */
  isBeta: function isBeta(version) {
    return version === this.v5;
  }
};
var protocolVersion_1 = protocolVersion$1;

//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/** @module types */

var utils$Q = utils$V;
/**
 * Constructs a two's-complement integer an array containing bits of the
 * integer in 32-bit (signed) pieces, given in little-endian order (i.e.,
 * lowest-order bits in the first piece), and the sign of -1 or 0.
 *
 * See the from* functions below for other convenient ways of constructing
 * Integers.
 *
 * The internal representation of an integer is an array of 32-bit signed
 * pieces, along with a sign (0 or -1) that indicates the contents of all the
 * other 32-bit pieces out to infinity.  We use 32-bit pieces because these are
 * the size of integers on which Javascript performs bit-operations.  For
 * operations like addition and multiplication, we split each number into 16-bit
 * pieces, which can easily be multiplied within Javascript's floating-point
 * representation without overflow or change in sign.
 *
 * @constructor
 * @param {Array.<number>} bits Array containing the bits of the number.
 * @param {number} sign The sign of the number: -1 for negative and 0 positive.
 * @final
 */

function Integer$3(bits, sign) {
  /**
   * @type {!Array.<number>}
   * @private
   */
  this.bits_ = [];
  /**
   * @type {number}
   * @private
   */

  this.sign_ = sign; // Copy the 32-bit signed integer values passed in.  We prune out those at the
  // top that equal the sign since they are redundant.

  var top = true;

  for (var i = bits.length - 1; i >= 0; i--) {
    var val = bits[i] | 0;

    if (!top || val != sign) {
      this.bits_[i] = val;
      top = false;
    }
  }
} // NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
// from* methods on which they depend.

/**
 * A cache of the Integer representations of small integer values.
 * @type {!Object}
 * @private
 */


Integer$3.IntCache_ = {};
/**
 * Returns an Integer representing the given (32-bit) integer value.
 * @param {number} value A 32-bit integer value.
 * @return {!Integer} The corresponding Integer value.
 */

Integer$3.fromInt = function (value) {
  if (-128 <= value && value < 128) {
    var cachedObj = Integer$3.IntCache_[value];

    if (cachedObj) {
      return cachedObj;
    }
  }

  var obj = new Integer$3([value | 0], value < 0 ? -1 : 0);

  if (-128 <= value && value < 128) {
    Integer$3.IntCache_[value] = obj;
  }

  return obj;
};
/**
 * Returns an Integer representing the given value, provided that it is a finite
 * number.  Otherwise, zero is returned.
 * @param {number} value The value in question.
 * @return {!Integer} The corresponding Integer value.
 */


Integer$3.fromNumber = function (value) {
  if (isNaN(value) || !isFinite(value)) {
    return Integer$3.ZERO;
  } else if (value < 0) {
    return Integer$3.fromNumber(-value).negate();
  } else {
    var bits = [];
    var pow = 1;

    for (var i = 0; value >= pow; i++) {
      bits[i] = value / pow | 0;
      pow *= Integer$3.TWO_PWR_32_DBL_;
    }

    return new Integer$3(bits, 0);
  }
};
/**
 * Returns a Integer representing the value that comes by concatenating the
 * given entries, each is assumed to be 32 signed bits, given in little-endian
 * order (lowest order bits in the lowest index), and sign-extending the highest
 * order 32-bit value.
 * @param {Array.<number>} bits The bits of the number, in 32-bit signed pieces,
 *     in little-endian order.
 * @return {!Integer} The corresponding Integer value.
 */


Integer$3.fromBits = function (bits) {
  var high = bits[bits.length - 1]; //noinspection JSBitwiseOperatorUsage

  return new Integer$3(bits, high & 1 << 31 ? -1 : 0);
};
/**
 * Returns an Integer representation of the given string, written using the
 * given radix.
 * @param {string} str The textual representation of the Integer.
 * @param {number=} opt_radix The radix in which the text is written.
 * @return {!Integer} The corresponding Integer value.
 */


Integer$3.fromString = function (str, opt_radix) {
  if (str.length == 0) {
    throw TypeError('number format error: empty string');
  }

  var radix = opt_radix || 10;

  if (radix < 2 || 36 < radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (str.charAt(0) == '-') {
    return Integer$3.fromString(str.substring(1), radix).negate();
  } else if (str.indexOf('-') >= 0) {
    throw TypeError('number format error: interior "-" character');
  } // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.


  var radixToPower = Integer$3.fromNumber(Math.pow(radix, 8));
  var result = Integer$3.ZERO;

  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i);
    var value = parseInt(str.substring(i, i + size), radix);

    if (size < 8) {
      var power = Integer$3.fromNumber(Math.pow(radix, size));
      result = result.multiply(power).add(Integer$3.fromNumber(value));
    } else {
      result = result.multiply(radixToPower);
      result = result.add(Integer$3.fromNumber(value));
    }
  }

  return result;
};
/**
 * Returns an Integer representation of a given big endian Buffer.
 * The internal representation of bits contains bytes in groups of 4
 * @param {Buffer} buf
 * @returns {Integer}
 */


Integer$3.fromBuffer = function (buf) {
  var bits = new Array(Math.ceil(buf.length / 4)); //noinspection JSBitwiseOperatorUsage

  var sign = buf[0] & 1 << 7 ? -1 : 0;

  for (var i = 0; i < bits.length; i++) {
    var offset = buf.length - (i + 1) * 4;
    var value;

    if (offset < 0) {
      //The buffer length is not multiple of 4
      offset = offset + 4;
      value = 0;

      for (var j = 0; j < offset; j++) {
        var _byte = buf[j];

        if (sign === -1) {
          //invert the bits
          _byte = ~_byte & 0xff;
        }

        value = value | _byte << (offset - j - 1) * 8;
      }

      if (sign === -1) {
        //invert all the bits
        value = ~value;
      }
    } else {
      value = buf.readInt32BE(offset);
    }

    bits[i] = value;
  }

  return new Integer$3(bits, sign);
};
/**
 * Returns a big endian buffer representation of an Integer.
 * Internally the bits are represented using 4 bytes groups (numbers),
 * in the Buffer representation there might be the case where we need less than the 4 bytes.
 * For example: 0x00000001 -> '01', 0xFFFFFFFF -> 'FF', 0xFFFFFF01 -> 'FF01'
 * @param {Integer} value
 * @returns {Buffer}
*/


Integer$3.toBuffer = function (value) {
  var sign = value.sign_;
  var bits = value.bits_;

  if (bits.length === 0) {
    //[0] or [0xffffffff]
    return utils$Q.allocBufferFromArray([value.sign_]);
  } //the high bits might need to be represented in less than 4 bytes


  var highBits = bits[bits.length - 1];

  if (sign === -1) {
    highBits = ~highBits;
  }

  var high = [];

  if (highBits >>> 24 > 0) {
    high.push(highBits >> 24 & 0xff);
  }

  if (highBits >>> 16 > 0) {
    high.push(highBits >> 16 & 0xff);
  }

  if (highBits >>> 8 > 0) {
    high.push(highBits >> 8 & 0xff);
  }

  high.push(highBits & 0xff);

  if (sign === -1) {
    //The byte containing the sign bit got removed
    if (high[0] >> 7 !== 0) {
      //it is going to be negated
      high.unshift(0);
    }
  } else if (high[0] >> 7 !== 0) {
    //its positive but it lost the byte containing the sign bit
    high.unshift(0);
  }

  var buf = utils$Q.allocBufferUnsafe(high.length + (bits.length - 1) * 4);

  for (var j = 0; j < high.length; j++) {
    var b = high[j];

    if (sign === -1) {
      buf[j] = ~b;
    } else {
      buf[j] = b;
    }
  }

  for (var i = 0; i < bits.length - 1; i++) {
    var group = bits[bits.length - 2 - i];
    var offset = high.length + i * 4;
    buf.writeInt32BE(group, offset);
  }

  return buf;
};
/**
 * A number used repeatedly in calculations.  This must appear before the first
 * call to the from* functions below.
 * @type {number}
 * @private
 */


Integer$3.TWO_PWR_32_DBL_ = (1 << 16) * (1 << 16);
/** @type {!Integer} */

Integer$3.ZERO = Integer$3.fromInt(0);
/** @type {!Integer} */

Integer$3.ONE = Integer$3.fromInt(1);
/**
 * @type {!Integer}
 * @private
 */

Integer$3.TWO_PWR_24_ = Integer$3.fromInt(1 << 24);
/**
 * Returns the value, assuming it is a 32-bit integer.
 * @return {number} The corresponding int value.
 */

Integer$3.prototype.toInt = function () {
  return this.bits_.length > 0 ? this.bits_[0] : this.sign_;
};
/** @return {number} The closest floating-point representation to this value. */


Integer$3.prototype.toNumber = function () {
  if (this.isNegative()) {
    return -this.negate().toNumber();
  } else {
    var val = 0;
    var pow = 1;

    for (var i = 0; i < this.bits_.length; i++) {
      val += this.getBitsUnsigned(i) * pow;
      pow *= Integer$3.TWO_PWR_32_DBL_;
    }

    return val;
  }
};
/**
 * @param {number=} opt_radix The radix in which the text should be written.
 * @return {string} The textual representation of this value.
 * @override
 */


Integer$3.prototype.toString = function (opt_radix) {
  var radix = opt_radix || 10;

  if (radix < 2 || 36 < radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (this.isZero()) {
    return '0';
  } else if (this.isNegative()) {
    return '-' + this.negate().toString(radix);
  } // Do several (6) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.


  var radixToPower = Integer$3.fromNumber(Math.pow(radix, 6));
  var rem = this;
  var result = '';

  while (true) {
    var remDiv = rem.divide(radixToPower);
    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
    var digits = intval.toString(radix);
    rem = remDiv;

    if (rem.isZero()) {
      return digits + result;
    } else {
      while (digits.length < 6) {
        digits = '0' + digits;
      }

      result = '' + digits + result;
    }
  }
};
/**
 * Returns the index-th 32-bit (signed) piece of the Integer according to
 * little-endian order (i.e., index 0 contains the smallest bits).
 * @param {number} index The index in question.
 * @return {number} The requested 32-bits as a signed number.
 */


Integer$3.prototype.getBits = function (index) {
  if (index < 0) {
    return 0; // Allowing this simplifies bit shifting operations below...
  } else if (index < this.bits_.length) {
    return this.bits_[index];
  } else {
    return this.sign_;
  }
};
/**
 * Returns the index-th 32-bit piece as an unsigned number.
 * @param {number} index The index in question.
 * @return {number} The requested 32-bits as an unsigned number.
 */


Integer$3.prototype.getBitsUnsigned = function (index) {
  var val = this.getBits(index);
  return val >= 0 ? val : Integer$3.TWO_PWR_32_DBL_ + val;
};
/** @return {number} The sign bit of this number, -1 or 0. */


Integer$3.prototype.getSign = function () {
  return this.sign_;
};
/** @return {boolean} Whether this value is zero. */


Integer$3.prototype.isZero = function () {
  if (this.sign_ != 0) {
    return false;
  }

  for (var i = 0; i < this.bits_.length; i++) {
    if (this.bits_[i] != 0) {
      return false;
    }
  }

  return true;
};
/** @return {boolean} Whether this value is negative. */


Integer$3.prototype.isNegative = function () {
  return this.sign_ == -1;
};
/** @return {boolean} Whether this value is odd. */


Integer$3.prototype.isOdd = function () {
  return this.bits_.length == 0 && this.sign_ == -1 || this.bits_.length > 0 && (this.bits_[0] & 1) != 0;
};
/**
 * @param {Integer} other Integer to compare against.
 * @return {boolean} Whether this Integer equals the other.
 */


Integer$3.prototype.equals = function (other) {
  if (this.sign_ != other.sign_) {
    return false;
  }

  var len = Math.max(this.bits_.length, other.bits_.length);

  for (var i = 0; i < len; i++) {
    if (this.getBits(i) != other.getBits(i)) {
      return false;
    }
  }

  return true;
};
/**
 * @param {Integer} other Integer to compare against.
 * @return {boolean} Whether this Integer does not equal the other.
 */


Integer$3.prototype.notEquals = function (other) {
  return !this.equals(other);
};
/**
 * @param {Integer} other Integer to compare against.
 * @return {boolean} Whether this Integer is greater than the other.
 */


Integer$3.prototype.greaterThan = function (other) {
  return this.compare(other) > 0;
};
/**
 * @param {Integer} other Integer to compare against.
 * @return {boolean} Whether this Integer is greater than or equal to the other.
 */


Integer$3.prototype.greaterThanOrEqual = function (other) {
  return this.compare(other) >= 0;
};
/**
 * @param {Integer} other Integer to compare against.
 * @return {boolean} Whether this Integer is less than the other.
 */


Integer$3.prototype.lessThan = function (other) {
  return this.compare(other) < 0;
};
/**
 * @param {Integer} other Integer to compare against.
 * @return {boolean} Whether this Integer is less than or equal to the other.
 */


Integer$3.prototype.lessThanOrEqual = function (other) {
  return this.compare(other) <= 0;
};
/**
 * Compares this Integer with the given one.
 * @param {Integer} other Integer to compare against.
 * @return {number} 0 if they are the same, 1 if the this is greater, and -1
 *     if the given one is greater.
 */


Integer$3.prototype.compare = function (other) {
  var diff = this.subtract(other);

  if (diff.isNegative()) {
    return -1;
  } else if (diff.isZero()) {
    return 0;
  } else {
    return +1;
  }
};
/**
 * Returns an integer with only the first numBits bits of this value, sign
 * extended from the final bit.
 * @param {number} numBits The number of bits by which to shift.
 * @return {!Integer} The shorted integer value.
 */


Integer$3.prototype.shorten = function (numBits) {
  var arr_index = numBits - 1 >> 5;
  var bit_index = (numBits - 1) % 32;
  var bits = [];

  for (var i = 0; i < arr_index; i++) {
    bits[i] = this.getBits(i);
  }

  var sigBits = bit_index == 31 ? 0xFFFFFFFF : (1 << bit_index + 1) - 1;
  var val = this.getBits(arr_index) & sigBits; //noinspection JSBitwiseOperatorUsage

  if (val & 1 << bit_index) {
    val |= 0xFFFFFFFF - sigBits;
    bits[arr_index] = val;
    return new Integer$3(bits, -1);
  } else {
    bits[arr_index] = val;
    return new Integer$3(bits, 0);
  }
};
/** @return {!Integer} The negation of this value. */


Integer$3.prototype.negate = function () {
  return this.not().add(Integer$3.ONE);
};
/**
 * Returns the sum of this and the given Integer.
 * @param {Integer} other The Integer to add to this.
 * @return {!Integer} The Integer result.
 */


Integer$3.prototype.add = function (other) {
  var len = Math.max(this.bits_.length, other.bits_.length);
  var arr = [];
  var carry = 0;

  for (var i = 0; i <= len; i++) {
    var a1 = this.getBits(i) >>> 16;
    var a0 = this.getBits(i) & 0xFFFF;
    var b1 = other.getBits(i) >>> 16;
    var b0 = other.getBits(i) & 0xFFFF;
    var c0 = carry + a0 + b0;
    var c1 = (c0 >>> 16) + a1 + b1;
    carry = c1 >>> 16;
    c0 &= 0xFFFF;
    c1 &= 0xFFFF;
    arr[i] = c1 << 16 | c0;
  }

  return Integer$3.fromBits(arr);
};
/**
 * Returns the difference of this and the given Integer.
 * @param {Integer} other The Integer to subtract from this.
 * @return {!Integer} The Integer result.
 */


Integer$3.prototype.subtract = function (other) {
  return this.add(other.negate());
};
/**
 * Returns the product of this and the given Integer.
 * @param {Integer} other The Integer to multiply against this.
 * @return {!Integer} The product of this and the other.
 */


Integer$3.prototype.multiply = function (other) {
  if (this.isZero()) {
    return Integer$3.ZERO;
  } else if (other.isZero()) {
    return Integer$3.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().multiply(other.negate());
    } else {
      return this.negate().multiply(other).negate();
    }
  } else if (other.isNegative()) {
    return this.multiply(other.negate()).negate();
  } // If both numbers are small, use float multiplication


  if (this.lessThan(Integer$3.TWO_PWR_24_) && other.lessThan(Integer$3.TWO_PWR_24_)) {
    return Integer$3.fromNumber(this.toNumber() * other.toNumber());
  } // Fill in an array of 16-bit products.


  var len = this.bits_.length + other.bits_.length;
  var arr = [];

  for (var i = 0; i < 2 * len; i++) {
    arr[i] = 0;
  }

  for (var i = 0; i < this.bits_.length; i++) {
    for (var j = 0; j < other.bits_.length; j++) {
      var a1 = this.getBits(i) >>> 16;
      var a0 = this.getBits(i) & 0xFFFF;
      var b1 = other.getBits(j) >>> 16;
      var b0 = other.getBits(j) & 0xFFFF;
      arr[2 * i + 2 * j] += a0 * b0;
      Integer$3.carry16_(arr, 2 * i + 2 * j);
      arr[2 * i + 2 * j + 1] += a1 * b0;
      Integer$3.carry16_(arr, 2 * i + 2 * j + 1);
      arr[2 * i + 2 * j + 1] += a0 * b1;
      Integer$3.carry16_(arr, 2 * i + 2 * j + 1);
      arr[2 * i + 2 * j + 2] += a1 * b1;
      Integer$3.carry16_(arr, 2 * i + 2 * j + 2);
    }
  } // Combine the 16-bit values into 32-bit values.


  for (var i = 0; i < len; i++) {
    arr[i] = arr[2 * i + 1] << 16 | arr[2 * i];
  }

  for (var i = len; i < 2 * len; i++) {
    arr[i] = 0;
  }

  return new Integer$3(arr, 0);
};
/**
 * Carries any overflow from the given index into later entries.
 * @param {Array.<number>} bits Array of 16-bit values in little-endian order.
 * @param {number} index The index in question.
 * @private
 */


Integer$3.carry16_ = function (bits, index) {
  while ((bits[index] & 0xFFFF) != bits[index]) {
    bits[index + 1] += bits[index] >>> 16;
    bits[index] &= 0xFFFF;
  }
};
/**
 * Returns this Integer divided by the given one.
 * @param {Integer} other Th Integer to divide this by.
 * @return {!Integer} This value divided by the given one.
 */


Integer$3.prototype.divide = function (other) {
  if (other.isZero()) {
    throw Error('division by zero');
  } else if (this.isZero()) {
    return Integer$3.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().divide(other.negate());
    } else {
      return this.negate().divide(other).negate();
    }
  } else if (other.isNegative()) {
    return this.divide(other.negate()).negate();
  } // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.


  var res = Integer$3.ZERO;
  var rem = this;

  while (rem.greaterThanOrEqual(other)) {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.

    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
    var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48); // Decrease the approximation until it is smaller than the remainder.  Note
    // that if it is too large, the product overflows and is negative.

    var approxRes = Integer$3.fromNumber(approx);
    var approxRem = approxRes.multiply(other);

    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
      approx -= delta;
      approxRes = Integer$3.fromNumber(approx);
      approxRem = approxRes.multiply(other);
    } // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.


    if (approxRes.isZero()) {
      approxRes = Integer$3.ONE;
    }

    res = res.add(approxRes);
    rem = rem.subtract(approxRem);
  }

  return res;
};
/**
 * Returns this Integer modulo the given one.
 * @param {Integer} other The Integer by which to mod.
 * @return {!Integer} This value modulo the given one.
 */


Integer$3.prototype.modulo = function (other) {
  return this.subtract(this.divide(other).multiply(other));
};
/** @return {!Integer} The bitwise-NOT of this value. */


Integer$3.prototype.not = function () {
  var len = this.bits_.length;
  var arr = [];

  for (var i = 0; i < len; i++) {
    arr[i] = ~this.bits_[i];
  }

  return new Integer$3(arr, ~this.sign_);
};
/**
 * Returns the bitwise-AND of this Integer and the given one.
 * @param {Integer} other The Integer to AND with this.
 * @return {!Integer} The bitwise-AND of this and the other.
 */


Integer$3.prototype.and = function (other) {
  var len = Math.max(this.bits_.length, other.bits_.length);
  var arr = [];

  for (var i = 0; i < len; i++) {
    arr[i] = this.getBits(i) & other.getBits(i);
  }

  return new Integer$3(arr, this.sign_ & other.sign_);
};
/**
 * Returns the bitwise-OR of this Integer and the given one.
 * @param {Integer} other The Integer to OR with this.
 * @return {!Integer} The bitwise-OR of this and the other.
 */


Integer$3.prototype.or = function (other) {
  var len = Math.max(this.bits_.length, other.bits_.length);
  var arr = [];

  for (var i = 0; i < len; i++) {
    arr[i] = this.getBits(i) | other.getBits(i);
  }

  return new Integer$3(arr, this.sign_ | other.sign_);
};
/**
 * Returns the bitwise-XOR of this Integer and the given one.
 * @param {Integer} other The Integer to XOR with this.
 * @return {!Integer} The bitwise-XOR of this and the other.
 */


Integer$3.prototype.xor = function (other) {
  var len = Math.max(this.bits_.length, other.bits_.length);
  var arr = [];

  for (var i = 0; i < len; i++) {
    arr[i] = this.getBits(i) ^ other.getBits(i);
  }

  return new Integer$3(arr, this.sign_ ^ other.sign_);
};
/**
 * Returns this value with bits shifted to the left by the given amount.
 * @param {number} numBits The number of bits by which to shift.
 * @return {!Integer} This shifted to the left by the given amount.
 */


Integer$3.prototype.shiftLeft = function (numBits) {
  var arr_delta = numBits >> 5;
  var bit_delta = numBits % 32;
  var len = this.bits_.length + arr_delta + (bit_delta > 0 ? 1 : 0);
  var arr = [];

  for (var i = 0; i < len; i++) {
    if (bit_delta > 0) {
      arr[i] = this.getBits(i - arr_delta) << bit_delta | this.getBits(i - arr_delta - 1) >>> 32 - bit_delta;
    } else {
      arr[i] = this.getBits(i - arr_delta);
    }
  }

  return new Integer$3(arr, this.sign_);
};
/**
 * Returns this value with bits shifted to the right by the given amount.
 * @param {number} numBits The number of bits by which to shift.
 * @return {!Integer} This shifted to the right by the given amount.
 */


Integer$3.prototype.shiftRight = function (numBits) {
  var arr_delta = numBits >> 5;
  var bit_delta = numBits % 32;
  var len = this.bits_.length - arr_delta;
  var arr = [];

  for (var i = 0; i < len; i++) {
    if (bit_delta > 0) {
      arr[i] = this.getBits(i + arr_delta) >>> bit_delta | this.getBits(i + arr_delta + 1) << 32 - bit_delta;
    } else {
      arr[i] = this.getBits(i + arr_delta);
    }
  }

  return new Integer$3(arr, this.sign_);
};
/**
 * Provide the name of the constructor and the string representation
 * @returns {string}
 */


Integer$3.prototype.inspect = function () {
  return this.constructor.name + ': ' + this.toString();
};
/**
 * Returns a Integer whose value is the absolute value of this
 * @returns {Integer}
 */


Integer$3.prototype.abs = function () {
  return this.sign_ === 0 ? this : this.negate();
};
/**
 * Returns the string representation.
 * Method used by the native JSON.stringify() to serialize this instance.
 */


Integer$3.prototype.toJSON = function () {
  return this.toString();
};

var integer = Integer$3;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Integer$2 = integer;
var utils$P = utils$V;
/** @module types */

/**
 * Constructs an immutable arbitrary-precision signed decimal number.
 * A <code>BigDecimal</code> consists of an [arbitrary precision integer]{@link module:types~Integer}
 * <i>unscaled value</i> and a 32-bit integer <i>scale</i>.  If zero
 * or positive, the scale is the number of digits to the right of the
 * decimal point.  If negative, the unscaled value of the number is
 * multiplied by ten to the power of the negation of the scale.  The
 * value of the number represented by the <code>BigDecimal</code> is
 * therefore <tt>(unscaledValue &times; 10<sup>-scale</sup>)</tt>.
 * @class
 * @classdesc The <code>BigDecimal</code> class provides operations for
 * arithmetic, scale manipulation, rounding, comparison and
 * format conversion.  The {@link #toString} method provides a
 * canonical representation of a <code>BigDecimal</code>.
 * @param {Integer|Number} unscaledValue The integer part of the decimal.
 * @param {Number} scale The scale of the decimal.
 * @constructor
 */

function BigDecimal$1(unscaledValue, scale) {
  if (typeof unscaledValue === 'number') {
    unscaledValue = Integer$2.fromNumber(unscaledValue);
  }
  /**
   * @type {Integer}
   * @private
   */


  this._intVal = unscaledValue;
  /**
   * @type {Number}
   * @private
   */

  this._scale = scale;
}
/**
 * Returns the BigDecimal representation of a buffer composed of the scale (int32BE) and the unsigned value (varint BE)
 * @param {Buffer} buf
 * @returns {BigDecimal}
 */


BigDecimal$1.fromBuffer = function (buf) {
  var scale = buf.readInt32BE(0);
  var unscaledValue = Integer$2.fromBuffer(buf.slice(4));
  return new BigDecimal$1(unscaledValue, scale);
};
/**
 * Returns a buffer representation composed of the scale as a BE int 32 and the unsigned value as a BE varint
 * @param {BigDecimal} value
 * @returns {Buffer}
 */


BigDecimal$1.toBuffer = function (value) {
  var unscaledValueBuffer = Integer$2.toBuffer(value._intVal);
  var scaleBuffer = utils$P.allocBufferUnsafe(4);
  scaleBuffer.writeInt32BE(value._scale, 0);
  return Buffer.concat([scaleBuffer, unscaledValueBuffer], scaleBuffer.length + unscaledValueBuffer.length);
};
/**
 * Returns a BigDecimal representation of the string
 * @param {String} value
 * @returns {BigDecimal}
 */


BigDecimal$1.fromString = function (value) {
  if (!value) {
    throw new TypeError('Invalid null or undefined value');
  }

  value = value.trim();
  var scaleIndex = value.indexOf('.');
  var scale = 0;

  if (scaleIndex >= 0) {
    scale = value.length - 1 - scaleIndex;
    value = value.substr(0, scaleIndex) + value.substr(scaleIndex + 1);
  }

  return new BigDecimal$1(Integer$2.fromString(value), scale);
};
/**
 * Returns a BigDecimal representation of the Number
 * @param {Number} value
 * @returns {BigDecimal}
 */


BigDecimal$1.fromNumber = function (value) {
  if (isNaN(value)) {
    return new BigDecimal$1(Integer$2.ZERO, 0);
  }

  var textValue = value.toString();

  if (textValue.indexOf('e') >= 0) {
    //get until scale 20
    textValue = value.toFixed(20);
  }

  return BigDecimal$1.fromString(textValue);
};
/**
 * Returns true if the value of the BigDecimal instance and other are the same
 * @param {BigDecimal} other
 * @returns {Boolean}
 */


BigDecimal$1.prototype.equals = function (other) {
  return other instanceof BigDecimal$1 && this.compare(other) === 0;
};

BigDecimal$1.prototype.inspect = function () {
  return this.constructor.name + ': ' + this.toString();
};
/**
 * @param {BigDecimal} other
 * @returns {boolean}
 */


BigDecimal$1.prototype.notEquals = function (other) {
  return !this.equals(other);
};
/**
 * Compares this BigDecimal with the given one.
 * @param {BigDecimal} other Integer to compare against.
 * @return {number} 0 if they are the same, 1 if the this is greater, and -1
 *     if the given one is greater.
 */


BigDecimal$1.prototype.compare = function (other) {
  var diff = this.subtract(other);

  if (diff.isNegative()) {
    return -1;
  }

  if (diff.isZero()) {
    return 0;
  }

  return +1;
};
/**
 * Returns the difference of this and the given BigDecimal.
 * @param {BigDecimal} other The BigDecimal to subtract from this.
 * @return {!BigDecimal} The BigDecimal result.
 */


BigDecimal$1.prototype.subtract = function (other) {
  var first = this;

  if (first._scale === other._scale) {
    return new BigDecimal$1(first._intVal.subtract(other._intVal), first._scale);
  }

  var diffScale;
  var unscaledValue;

  if (first._scale < other._scale) {
    //The scale of this is lower
    diffScale = other._scale - first._scale; //multiple this unScaledValue to compare in the same scale

    unscaledValue = first._intVal.multiply(Integer$2.fromNumber(Math.pow(10, diffScale))).subtract(other._intVal);
    return new BigDecimal$1(unscaledValue, other._scale);
  } //The scale of this is higher


  diffScale = first._scale - other._scale; //multiple this unScaledValue to compare in the same scale

  unscaledValue = first._intVal.subtract(other._intVal.multiply(Integer$2.fromNumber(Math.pow(10, diffScale))));
  return new BigDecimal$1(unscaledValue, first._scale);
};
/**
 * Returns the sum of this and the given <code>BigDecimal</code>.
 * @param {BigDecimal} other The BigDecimal to sum to this.
 * @return {!BigDecimal} The BigDecimal result.
 */


BigDecimal$1.prototype.add = function (other) {
  var first = this;

  if (first._scale === other._scale) {
    return new BigDecimal$1(first._intVal.add(other._intVal), first._scale);
  }

  var diffScale;
  var unscaledValue;

  if (first._scale < other._scale) {
    //The scale of this is lower
    diffScale = other._scale - first._scale; //multiple this unScaledValue to compare in the same scale

    unscaledValue = first._intVal.multiply(Integer$2.fromNumber(Math.pow(10, diffScale))).add(other._intVal);
    return new BigDecimal$1(unscaledValue, other._scale);
  } //The scale of this is higher


  diffScale = first._scale - other._scale; //multiple this unScaledValue to compare in the same scale

  unscaledValue = first._intVal.add(other._intVal.multiply(Integer$2.fromNumber(Math.pow(10, diffScale))));
  return new BigDecimal$1(unscaledValue, first._scale);
};
/**
 * Returns true if the current instance is greater than the other
 * @param {BigDecimal} other
 * @returns {boolean}
 */


BigDecimal$1.prototype.greaterThan = function (other) {
  return this.compare(other) === 1;
};
/** @return {boolean} Whether this value is negative. */


BigDecimal$1.prototype.isNegative = function () {
  return this._intVal.isNegative();
};
/** @return {boolean} Whether this value is zero. */


BigDecimal$1.prototype.isZero = function () {
  return this._intVal.isZero();
};
/**
 * Returns the string representation of this <code>BigDecimal</code>
 * @returns {string}
 */


BigDecimal$1.prototype.toString = function () {
  var intString = this._intVal.toString();

  if (this._scale === 0) {
    return intString;
  }

  var signSymbol = '';

  if (intString.charAt(0) === '-') {
    signSymbol = '-';
    intString = intString.substr(1);
  }

  var separatorIndex = intString.length - this._scale;

  if (separatorIndex <= 0) {
    //add zeros at the beginning, plus an additional zero
    intString = utils$P.stringRepeat('0', -separatorIndex + 1) + intString;
    separatorIndex = intString.length - this._scale;
  }

  return signSymbol + intString.substr(0, separatorIndex) + '.' + intString.substr(separatorIndex);
};
/**
 * Returns a Number representation of this <code>BigDecimal</code>.
 * @returns {Number}
 */


BigDecimal$1.prototype.toNumber = function () {
  return parseFloat(this.toString());
};
/**
 * Returns the string representation.
 * Method used by the native JSON.stringify() to serialize this instance.
 */


BigDecimal$1.prototype.toJSON = function () {
  return this.toString();
};

var bigDecimal = BigDecimal$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Long$7 = Long$9.exports;
var util$F = require$$0__default$1["default"];
var utils$O = utils$V;
/** @module types */
// Reuse the same buffers that should perform slightly better than built-in buffer pool

var reusableBuffers = {
  months: utils$O.allocBuffer(9),
  days: utils$O.allocBuffer(9),
  nanoseconds: utils$O.allocBuffer(9)
};
var maxInt32 = 0x7FFFFFFF;
var longOneThousand = Long$7.fromInt(1000);
var nanosPerMicro = longOneThousand;
var nanosPerMilli = longOneThousand.multiply(nanosPerMicro);
var nanosPerSecond = longOneThousand.multiply(nanosPerMilli);
var nanosPerMinute = Long$7.fromInt(60).multiply(nanosPerSecond);
var nanosPerHour = Long$7.fromInt(60).multiply(nanosPerMinute);
var daysPerWeek = 7;
var monthsPerYear = 12;
var standardRegex = /(\d+)(y|mo|w|d|h|s|ms|us|µs|ns|m)/gi;
var iso8601Regex = /P((\d+)Y)?((\d+)M)?((\d+)D)?(T((\d+)H)?((\d+)M)?((\d+)S)?)?/;
var iso8601WeekRegex = /P(\d+)W/;
var iso8601AlternateRegex = /P(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/;
/**
 * Creates a new instance of {@link Duration}.
 * @classdesc
 * Represents a duration. A duration stores separately months, days, and seconds due to the fact that the number of
 * days in a month varies, and a day can have 23 or 25 hours if a daylight saving is involved.
 * @param {Number} months The number of months.
 * @param {Number} days The number of days.
 * @param {Number|Long} nanoseconds The number of nanoseconds.
 * @constructor
 */

function Duration(months, days, nanoseconds) {
  /**
   * Gets the number of months.
   * @type {Number}
   */
  this.months = months;
  /**
   * Gets the number of days.
   * @type {Number}
   */

  this.days = days;
  /**
   * Gets the number of nanoseconds represented as a <code>int64</code>.
   * @type {Long}
   */

  this.nanoseconds = typeof nanoseconds === 'number' ? Long$7.fromNumber(nanoseconds) : nanoseconds;
}

Duration.prototype.equals = function (other) {
  if (!(other instanceof Duration)) {
    return false;
  }

  return this.months === other.months && this.days === other.days && this.nanoseconds.equals(other.nanoseconds);
};
/**
 * Serializes the duration and returns the representation of the value in bytes.
 * @returns {Buffer}
 */


Duration.prototype.toBuffer = function () {
  var lengthMonths = VIntCoding.writeVInt(Long$7.fromNumber(this.months), reusableBuffers.months);
  var lengthDays = VIntCoding.writeVInt(Long$7.fromNumber(this.days), reusableBuffers.days);
  var lengthNanoseconds = VIntCoding.writeVInt(this.nanoseconds, reusableBuffers.nanoseconds);
  var buffer = utils$O.allocBufferUnsafe(lengthMonths + lengthDays + lengthNanoseconds);
  reusableBuffers.months.copy(buffer, 0, 0, lengthMonths);
  var offset = lengthMonths;
  reusableBuffers.days.copy(buffer, offset, 0, lengthDays);
  offset += lengthDays;
  reusableBuffers.nanoseconds.copy(buffer, offset, 0, lengthNanoseconds);
  return buffer;
};
/**
 * Returns the string representation of the value.
 * @return {string}
 */


Duration.prototype.toString = function () {
  var value = '';

  function append(dividend, divisor, unit) {
    if (dividend === 0 || dividend < divisor) {
      return dividend;
    } // string concatenation is supposed to be fasted than join()


    value += (dividend / divisor).toFixed(0) + unit;
    return dividend % divisor;
  }

  function append64(dividend, divisor, unit) {
    if (dividend.equals(Long$7.ZERO) || dividend.lessThan(divisor)) {
      return dividend;
    } // string concatenation is supposed to be fasted than join()


    value += dividend.divide(divisor).toString() + unit;
    return dividend.modulo(divisor);
  }

  if (this.months < 0 || this.days < 0 || this.nanoseconds.isNegative()) {
    value = '-';
  }

  var remainder = append(Math.abs(this.months), monthsPerYear, "y");
  append(remainder, 1, "mo");
  append(Math.abs(this.days), 1, "d");

  if (!this.nanoseconds.equals(Long$7.ZERO)) {
    var nanos = this.nanoseconds.isNegative() ? this.nanoseconds.negate() : this.nanoseconds;
    remainder = append64(nanos, nanosPerHour, "h");
    remainder = append64(remainder, nanosPerMinute, "m");
    remainder = append64(remainder, nanosPerSecond, "s");
    remainder = append64(remainder, nanosPerMilli, "ms");
    remainder = append64(remainder, nanosPerMicro, "us");
    append64(remainder, Long$7.ONE, "ns");
  }

  return value;
};
/**
 * Creates a new {@link Duration} instance from the binary representation of the value.
 * @param {Buffer} buffer
 * @returns {Duration}
 */


Duration.fromBuffer = function (buffer) {
  var offset = {
    value: 0
  };
  var months = VIntCoding.readVInt(buffer, offset).toNumber();
  var days = VIntCoding.readVInt(buffer, offset).toNumber();
  var nanoseconds = VIntCoding.readVInt(buffer, offset);
  return new Duration(months, days, nanoseconds);
};
/**
 * Creates a new {@link Duration} instance from the string representation of the value.
 * <p>
 *   Accepted formats:
 * </p>
 * <ul>
 * <li>multiple digits followed by a time unit like: 12h30m where the time unit can be:
 *   <ul>
 *     <li>{@code y}: years</li>
 *     <li>{@code m}: months</li>
 *     <li>{@code w}: weeks</li>
 *     <li>{@code d}: days</li>
 *     <li>{@code h}: hours</li>
 *     <li>{@code m}: minutes</li>
 *     <li>{@code s}: seconds</li>
 *     <li>{@code ms}: milliseconds</li>
 *     <li>{@code us} or {@code µs}: microseconds</li>
 *     <li>{@code ns}: nanoseconds</li>
 *   </ul>
 * </li>
 * <li>ISO 8601 format:  <code>P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W</code></li>
 * <li>ISO 8601 alternative format: <code>P[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss]</code></li>
 * </ul>
 * @param {String} input
 * @returns {Duration}
 */


Duration.fromString = function (input) {
  var isNegative = input.charAt(0) === '-';
  var source = isNegative ? input.substr(1) : input;

  if (source.charAt(0) === 'P') {
    if (source.charAt(source.length - 1) === 'W') {
      return parseIso8601WeekFormat(isNegative, source);
    }

    if (source.indexOf('-') > 0) {
      return parseIso8601AlternativeFormat(isNegative, source);
    }

    return parseIso8601Format(isNegative, source);
  }

  return parseStandardFormat(isNegative, source);
};
/**
 * @param {Boolean} isNegative
 * @param {String} source
 * @returns {Duration}
 * @private
 */


function parseStandardFormat(isNegative, source) {
  var builder = new Builder(isNegative);
  standardRegex.lastIndex = 0;
  var matches;

  while ((matches = standardRegex.exec(source)) && matches.length <= 3) {
    builder.add(matches[1], matches[2]);
  }

  return builder.build();
}
/**
 * @param {Boolean} isNegative
 * @param {String} source
 * @returns {Duration}
 * @private
 */


function parseIso8601Format(isNegative, source) {
  var matches = iso8601Regex.exec(source);

  if (!matches || matches[0] !== source) {
    throw new TypeError(util$F.format("Unable to convert '%s' to a duration", source));
  }

  var builder = new Builder(isNegative);

  if (matches[1]) {
    builder.addYears(matches[2]);
  }

  if (matches[3]) {
    builder.addMonths(matches[4]);
  }

  if (matches[5]) {
    builder.addDays(matches[6]);
  }

  if (matches[7]) {
    if (matches[8]) {
      builder.addHours(matches[9]);
    }

    if (matches[10]) {
      builder.addMinutes(matches[11]);
    }

    if (matches[12]) {
      builder.addSeconds(matches[13]);
    }
  }

  return builder.build();
}
/**
 * @param {Boolean} isNegative
 * @param {String} source
 * @returns {Duration}
 * @private
 */


function parseIso8601WeekFormat(isNegative, source) {
  var matches = iso8601WeekRegex.exec(source);

  if (!matches || matches[0] !== source) {
    throw new TypeError(util$F.format("Unable to convert '%s' to a duration", source));
  }

  return new Builder(isNegative).addWeeks(matches[1]).build();
}
/**
 * @param {Boolean} isNegative
 * @param {String} source
 * @returns {Duration}
 * @private
 */


function parseIso8601AlternativeFormat(isNegative, source) {
  var matches = iso8601AlternateRegex.exec(source);

  if (!matches || matches[0] !== source) {
    throw new TypeError(util$F.format("Unable to convert '%s' to a duration", source));
  }

  return new Builder(isNegative).addYears(matches[1]).addMonths(matches[2]).addDays(matches[3]).addHours(matches[4]).addMinutes(matches[5]).addSeconds(matches[6]).build();
}
/**
 * @param {Boolean} isNegative
 * @private
 * @constructor
 */


function Builder(isNegative) {
  this._isNegative = isNegative;
  this._unitIndex = 0;
  this._months = 0;
  this._days = 0;
  this._nanoseconds = Long$7.ZERO;
  this._addMethods = {
    'y': this.addYears,
    'mo': this.addMonths,
    'w': this.addWeeks,
    'd': this.addDays,
    'h': this.addHours,
    'm': this.addMinutes,
    's': this.addSeconds,
    'ms': this.addMillis,
    // µs
    "\xB5s": this.addMicros,
    'us': this.addMicros,
    'ns': this.addNanos
  };
  this._unitByIndex = [null, 'years', 'months', 'weeks', 'days', 'hours', 'minutes', 'seconds', 'milliseconds', 'microseconds', 'nanoseconds'];
}

Builder.prototype._validateOrder = function (unitIndex) {
  if (unitIndex === this._unitIndex) {
    throw new TypeError(util$F.format("Invalid duration. The %s are specified multiple times", this._getUnitName(unitIndex)));
  }

  if (unitIndex <= this._unitIndex) {
    throw new TypeError(util$F.format("Invalid duration. The %s should be after %s", this._getUnitName(this._unitIndex), this._getUnitName(unitIndex)));
  }

  this._unitIndex = unitIndex;
};
/**
 * @param {Number} units
 * @param {Number} monthsPerUnit
 */


Builder.prototype._validateMonths = function (units, monthsPerUnit) {
  this._validate32(units, (maxInt32 - this._months) / monthsPerUnit, "months");
};
/**
 * @param {Number} units
 * @param {Number} daysPerUnit
 */


Builder.prototype._validateDays = function (units, daysPerUnit) {
  this._validate32(units, (maxInt32 - this._days) / daysPerUnit, "days");
};
/**
 * @param {Long} units
 * @param {Long} nanosPerUnit
 */


Builder.prototype._validateNanos = function (units, nanosPerUnit) {
  this._validate64(units, Long$7.MAX_VALUE.subtract(this._nanoseconds).divide(nanosPerUnit), "nanoseconds");
};
/**
 * @param {Number} units
 * @param {Number} limit
 * @param {String} unitName
 */


Builder.prototype._validate32 = function (units, limit, unitName) {
  if (units > limit) {
    throw new TypeError(util$F.format('Invalid duration. The total number of %s must be less or equal to %s', unitName, maxInt32));
  }
};
/**
 * @param {Long} units
 * @param {Long} limit
 * @param {String} unitName
 */


Builder.prototype._validate64 = function (units, limit, unitName) {
  if (units.greaterThan(limit)) {
    throw new TypeError(util$F.format('Invalid duration. The total number of %s must be less or equal to %s', unitName, Long$7.MAX_VALUE.toString()));
  }
};

Builder.prototype._getUnitName = function (unitIndex) {
  var name = this._unitByIndex[+unitIndex];

  if (!name) {
    throw new Error('unknown unit index: ' + unitIndex);
  }

  return name;
};

Builder.prototype.add = function (textValue, symbol) {
  var addMethod = this._addMethods[symbol.toLowerCase()];

  if (!addMethod) {
    throw new TypeError(util$F.format("Unknown duration symbol '%s'", symbol));
  }

  return addMethod.call(this, textValue);
};
/**
 * @param {String|Number} years
 * @return {Builder}
 */


Builder.prototype.addYears = function (years) {
  var value = +years;

  this._validateOrder(1);

  this._validateMonths(value, monthsPerYear);

  this._months += value * monthsPerYear;
  return this;
};
/**
 * @param {String|Number} months
 * @return {Builder}
 */


Builder.prototype.addMonths = function (months) {
  var value = +months;

  this._validateOrder(2);

  this._validateMonths(value, 1);

  this._months += value;
  return this;
};
/**
 * @param {String|Number} weeks
 * @return {Builder}
 */


Builder.prototype.addWeeks = function (weeks) {
  var value = +weeks;

  this._validateOrder(3);

  this._validateDays(value, daysPerWeek);

  this._days += value * daysPerWeek;
  return this;
};
/**
 * @param {String|Number} days
 * @return {Builder}
 */


Builder.prototype.addDays = function (days) {
  var value = +days;

  this._validateOrder(4);

  this._validateDays(value, 1);

  this._days += value;
  return this;
};
/**
 * @param {String|Long} hours
 * @return {Builder}
 */


Builder.prototype.addHours = function (hours) {
  var value = typeof hours === 'string' ? Long$7.fromString(hours) : hours;

  this._validateOrder(5);

  this._validateNanos(value, nanosPerHour);

  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerHour));
  return this;
};
/**
 * @param {String|Long} minutes
 * @return {Builder}
 */


Builder.prototype.addMinutes = function (minutes) {
  var value = typeof minutes === 'string' ? Long$7.fromString(minutes) : minutes;

  this._validateOrder(6);

  this._validateNanos(value, nanosPerMinute);

  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerMinute));
  return this;
};
/**
 * @param {String|Long} seconds
 * @return {Builder}
 */


Builder.prototype.addSeconds = function (seconds) {
  var value = typeof seconds === 'string' ? Long$7.fromString(seconds) : seconds;

  this._validateOrder(7);

  this._validateNanos(value, nanosPerSecond);

  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerSecond));
  return this;
};
/**
 * @param {String|Long} millis
 * @return {Builder}
 */


Builder.prototype.addMillis = function (millis) {
  var value = typeof millis === 'string' ? Long$7.fromString(millis) : millis;

  this._validateOrder(8);

  this._validateNanos(value, nanosPerMilli);

  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerMilli));
  return this;
};
/**
 * @param {String|Long} micros
 * @return {Builder}
 */


Builder.prototype.addMicros = function (micros) {
  var value = typeof micros === 'string' ? Long$7.fromString(micros) : micros;

  this._validateOrder(9);

  this._validateNanos(value, nanosPerMicro);

  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerMicro));
  return this;
};
/**
 * @param {String|Long} nanos
 * @return {Builder}
 */


Builder.prototype.addNanos = function (nanos) {
  var value = typeof nanos === 'string' ? Long$7.fromString(nanos) : nanos;

  this._validateOrder(10);

  this._validateNanos(value, Long$7.ONE);

  this._nanoseconds = this._nanoseconds.add(value);
  return this;
};
/** @return {Duration} */


Builder.prototype.build = function () {
  return this._isNegative ? new Duration(-this._months, -this._days, this._nanoseconds.negate()) : new Duration(this._months, this._days, this._nanoseconds);
};
/**
 * Contains the methods for reading and writing vints into binary format.
 * Exposes only 2 internal methods, the rest are hidden.
 * @private
 */


var VIntCoding = function () {
  /** @param {Long} n */
  function encodeZigZag64(n) {
    //     (n << 1) ^ (n >> 63);
    return n.toUnsigned().shiftLeft(1).xor(n.shiftRight(63));
  }
  /** @param {Long} n */


  function decodeZigZag64(n) {
    //     (n >>> 1) ^ -(n & 1);
    return n.shiftRightUnsigned(1).xor(n.and(Long$7.ONE).negate());
  }
  /**
   * @param {Long} value
   * @param {Buffer} buffer
   * @returns {Number}
   */


  function writeVInt(value, buffer) {
    return writeUnsignedVInt(encodeZigZag64(value), buffer);
  }
  /**
   * @param {Long} value
   * @param {Buffer} buffer
   * @returns {number}
   */


  function writeUnsignedVInt(value, buffer) {
    var size = computeUnsignedVIntSize(value);

    if (size === 1) {
      buffer[0] = value.getLowBits();
      return 1;
    }

    encodeVInt(value, size, buffer);
    return size;
  }
  /**
   * @param {Long} value
   * @returns {number}
   */


  function computeUnsignedVIntSize(value) {
    var magnitude = numberOfLeadingZeros(value.or(Long$7.ONE));
    return 639 - magnitude * 9 >> 6;
  }
  /**
   * @param {Long} value
   * @param {Number} size
   * @param {Buffer} buffer
   */


  function encodeVInt(value, size, buffer) {
    var extraBytes = size - 1;
    var intValue = value.getLowBits();
    var i;
    var intBytes = 4;

    for (i = extraBytes; i >= 0 && intBytes-- > 0; i--) {
      buffer[i] = 0xFF & intValue;
      intValue >>= 8;
    }

    intValue = value.getHighBits();

    for (; i >= 0; i--) {
      buffer[i] = 0xFF & intValue;
      intValue >>= 8;
    }

    buffer[0] |= encodeExtraBytesToRead(extraBytes);
  }
  /**
   * Returns the number of zero bits preceding the highest-order one-bit in the binary representation of the value.
   * @param {Long} value
   * @returns {Number}
   */


  function numberOfLeadingZeros(value) {
    if (value.equals(Long$7.ZERO)) {
      return 64;
    }

    var n = 1;
    var x = value.getHighBits();

    if (x === 0) {
      n += 32;
      x = value.getLowBits();
    }

    if (x >>> 16 === 0) {
      n += 16;
      x <<= 16;
    }

    if (x >>> 24 === 0) {
      n += 8;
      x <<= 8;
    }

    if (x >>> 28 === 0) {
      n += 4;
      x <<= 4;
    }

    if (x >>> 30 === 0) {
      n += 2;
      x <<= 2;
    }

    n -= x >>> 31;
    return n;
  }

  function encodeExtraBytesToRead(extraBytesToRead) {
    return ~(0xff >> extraBytesToRead);
  }
  /**
   * @param {Buffer} buffer
   * @param {{value: number}} offset
   * @returns {Long}
   */


  function readVInt(buffer, offset) {
    return decodeZigZag64(readUnsignedVInt(buffer, offset));
  }
  /**
   * @param {Buffer} input
   * @param {{ value: number}} offset
   * @returns {Long}
   */


  function readUnsignedVInt(input, offset) {
    var firstByte = input[offset.value++];

    if ((firstByte & 0x80) === 0) {
      return Long$7.fromInt(firstByte);
    }

    var sByteInt = fromSignedByteToInt(firstByte);
    var size = numberOfExtraBytesToRead(sByteInt);
    var result = Long$7.fromInt(sByteInt & firstByteValueMask(size));

    for (var ii = 0; ii < size; ii++) {
      var b = Long$7.fromInt(input[offset.value++]); //       (result << 8) | b

      result = result.shiftLeft(8).or(b);
    }

    return result;
  }

  function fromSignedByteToInt(value) {
    if (value > 0x7f) {
      return value - 0x0100;
    }

    return value;
  }

  function numberOfLeadingZerosInt32(i) {
    if (i === 0) {
      return 32;
    }

    var n = 1;

    if (i >>> 16 === 0) {
      n += 16;
      i <<= 16;
    }

    if (i >>> 24 === 0) {
      n += 8;
      i <<= 8;
    }

    if (i >>> 28 === 0) {
      n += 4;
      i <<= 4;
    }

    if (i >>> 30 === 0) {
      n += 2;
      i <<= 2;
    }

    n -= i >>> 31;
    return n;
  }
  /**
   * @param {Number} firstByte
   * @returns {Number}
   */


  function numberOfExtraBytesToRead(firstByte) {
    // Instead of counting 1s of the byte, we negate and count 0 of the byte
    return numberOfLeadingZerosInt32(~firstByte) - 24;
  }
  /**
   * @param {Number} extraBytesToRead
   * @returns {Number}
   */


  function firstByteValueMask(extraBytesToRead) {
    return 0xff >> extraBytesToRead;
  }

  return {
    readVInt: readVInt,
    writeVInt: writeVInt
  };
}();

var duration = Duration;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var utils$N = utils$V;
/** @module types */

/**
 * Creates a new instance of InetAddress
 * @class
 * @classdesc Represents an v4 or v6 Internet Protocol (IP) address.
 * @param {Buffer} buffer
 * @constructor
 */

function InetAddress(buffer) {
  if (!(buffer instanceof Buffer) || buffer.length !== 4 && buffer.length !== 16) {
    throw new TypeError('The ip address must contain 4 or 16 bytes');
  }
  /**
   * Immutable buffer that represents the IP address 
   * @type Array
   */


  this.buffer = buffer;
  /**
   * Returns the length of the underlying buffer
   * @type Number
   */

  this.length = buffer.length;
  /**
   * Returns the Ip version (4 or 6)
   * @type Number
   */

  this.version = buffer.length === 4 ? 4 : 6;
}
/**
 * Parses the string representation and returns an Ip address
 * @param {String} value
 */


InetAddress.fromString = function (value) {
  if (!value) {
    return new InetAddress(utils$N.allocBufferFromArray([0, 0, 0, 0]));
  }

  var ipv4Pattern = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
  var ipv6Pattern = /^[\da-f:.]+$/i;
  var parts;

  if (ipv4Pattern.test(value)) {
    parts = value.split('.');
    return new InetAddress(utils$N.allocBufferFromArray(parts));
  }

  if (!ipv6Pattern.test(value)) {
    throw new TypeError('Value could not be parsed as InetAddress: ' + value);
  }

  parts = value.split(':');

  if (parts.length < 3) {
    throw new TypeError('Value could not be parsed as InetAddress: ' + value);
  }

  var buffer = utils$N.allocBufferUnsafe(16);
  var filling = 8 - parts.length + 1;
  var applied = false;
  var offset = 0;
  var embeddedIp4 = ipv4Pattern.test(parts[parts.length - 1]);

  if (embeddedIp4) {
    // Its IPv6 address with an embedded IPv4 address:
    // subtract 1 from the potential empty filling as ip4 contains 4 bytes instead of 2 of a ipv6 section
    filling -= 1;
  }

  function writeItem(uIntValue) {
    buffer.writeUInt8(+uIntValue, offset++);
  }

  for (var i = 0; i < parts.length; i++) {
    var item = parts[i];

    if (item) {
      if (embeddedIp4 && i === parts.length - 1) {
        item.split('.').forEach(writeItem);
        break;
      }

      buffer.writeUInt16BE(parseInt(item, 16), offset);
      offset = offset + 2;
      continue;
    } //its an empty string


    if (applied) {
      //there could be 2 occurrences of empty string
      filling = 1;
    }

    applied = true;

    for (var j = 0; j < filling; j++) {
      buffer[offset++] = 0;
      buffer[offset++] = 0;
    }
  }

  if (embeddedIp4 && !isValidIPv4Mapped(buffer)) {
    throw new TypeError('Only IPv4-Mapped IPv6 addresses are allowed as IPv6 address with embedded IPv4 address');
  }

  return new InetAddress(buffer);
};
/**
 * Compares 2 addresses and returns true if the underlying bytes are the same
 * @param {InetAddress} other
 * @returns {Boolean}
 */


InetAddress.prototype.equals = function (other) {
  if (!(other instanceof InetAddress)) {
    return false;
  }

  return this.buffer.length === other.buffer.length && this.buffer.toString('hex') === other.buffer.toString('hex');
};
/**
 * Returns the underlying buffer
 * @returns {Buffer}
 */


InetAddress.prototype.getBuffer = function () {
  return this.buffer;
};
/**
 * Provide the name of the constructor and the string representation
 * @returns {string}
 */


InetAddress.prototype.inspect = function () {
  return this.constructor.name + ': ' + this.toString();
};
/**
 * Returns the string representation of the IP address.
 * <p>For v4 IP addresses, a string in the form of d.d.d.d is returned.</p>
 * <p>
 *   For v6 IP addresses, a string in the form of x:x:x:x:x:x:x:x is returned, where the 'x's are the hexadecimal
 *   values of the eight 16-bit pieces of the address, according to rfc5952.
 *   In cases where there is more than one field of only zeros, it can be shortened. For example, 2001:0db8:0:0:0:1:0:1
 *   will be expressed as 2001:0db8::1:0:1.
 * </p>
 * @param {String} [encoding]
 * @returns {String}
 */


InetAddress.prototype.toString = function (encoding) {
  if (encoding === 'hex') {
    //backward compatibility: behave in the same way as the buffer
    return this.buffer.toString('hex');
  }

  if (this.buffer.length === 4) {
    return this.buffer[0] + '.' + this.buffer[1] + '.' + this.buffer[2] + '.' + this.buffer[3];
  }

  var start = -1;
  var longest = {
    length: 0,
    start: -1
  };

  function checkLongest(i) {
    if (start >= 0) {
      //close the group
      var length = i - start;

      if (length > longest.length) {
        longest.length = length;
        longest.start = start;
        start = -1;
      }
    }
  } //get the longest 16-bit group of zeros


  for (var i = 0; i < this.buffer.length; i = i + 2) {
    if (this.buffer[i] === 0 && this.buffer[i + 1] === 0) {
      //its a group of zeros
      if (start < 0) {
        start = i;
      } // at the end of the buffer, make a final call to checkLongest.


      if (i === this.buffer.length - 2) {
        checkLongest(i + 2);
      }

      continue;
    } //its a group of non-zeros


    checkLongest(i);
  }

  var address = '';

  for (var h = 0; h < this.buffer.length; h = h + 2) {
    if (h === longest.start) {
      address += ':';
      continue;
    }

    if (h < longest.start + longest.length && h > longest.start) {
      //its a group of zeros
      continue;
    }

    if (address.length > 0) {
      address += ':';
    }

    address += (this.buffer[h] << 8 | this.buffer[h + 1]).toString(16);
  }

  if (address.charAt(address.length - 1) === ':') {
    address += ':';
  }

  return address;
};
/**
 * Returns the string representation.
 * Method used by the native JSON.stringify() to serialize this instance.
 */


InetAddress.prototype.toJSON = function () {
  return this.toString();
};
/**
 * Validates for a IPv4-Mapped IPv6 according to https://tools.ietf.org/html/rfc4291#section-2.5.5
 * @private
 * @param {Buffer} buffer
 */


function isValidIPv4Mapped(buffer) {
  // check the form
  // |      80 bits   | 16 |   32 bits
  // +----------------+----+-------------
  // |0000........0000|FFFF| IPv4 address
  for (var i = 0; i < buffer.length - 6; i++) {
    if (buffer[i] !== 0) {
      return false;
    }
  }

  return !(buffer[10] !== 255 || buffer[11] !== 255);
}

var inetAddress = InetAddress;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$E = require$$0__default$1["default"];
var utils$M = utils$V;
/** @module types */

/**
 * @private
 * @const
 */

var millisecondsPerDay = 86400000;
/**
 * @private
 */

var dateCenter = Math.pow(2, 31);
/**
 *
 * Creates a new instance of LocalDate.
 * @class
 * @classdesc A date without a time-zone in the ISO-8601 calendar system, such as 2010-08-05.
 * <p>
 *   LocalDate is an immutable object that represents a date, often viewed as year-month-day. For example, the value "1st October 2014" can be stored in a LocalDate.
 * </p>
 * <p>
 *   This class does not store or represent a time or time-zone. Instead, it is a description of the date, as used for birthdays. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.
 * </p>
 * <p>
 *   Note that this type can represent dates in the range [-5877641-06-23; 5881580-07-17] while the ES5 date type can only represent values in the range of [-271821-04-20; 275760-09-13].
 *   In the event that year, month, day parameters do not fall within the ES5 date range an Error will be thrown.  If you wish to represent a date outside of this range, pass a single
 *   parameter indicating the days since epoch.  For example, -1 represents 1969-12-31.
 * </p>
 * @param {Number} year The year or days since epoch.  If days since epoch, month and day should not be provided.
 * @param {Number} month Between 1 and 12 inclusive.
 * @param {Number} day Between 1 and the number of days in the given month of the given year.
 *
 * @property {Date} date The date representation if falls within a range of an ES5 data type, otherwise an invalid date.
 *
 * @constructor
 */

function LocalDate(year, month, day) {
  //implementation detail: internally uses a UTC based date
  if (typeof year === 'number' && typeof month === 'number' && typeof day === 'number') {
    // Use setUTCFullYear as if there is a 2 digit year, Date.UTC() assumes
    // that is the 20th century.
    this.date = new Date();
    this.date.setUTCHours(0, 0, 0, 0);
    this.date.setUTCFullYear(year, month - 1, day);

    if (isNaN(this.date.getTime())) {
      throw new Error(util$E.format('%d-%d-%d does not form a valid ES5 date!', year, month, day));
    }
  } else if (typeof month === 'undefined' && typeof day === 'undefined') {
    if (typeof year === 'number') {
      //in days since epoch.
      if (year < -2147483648 || year > 2147483647) {
        throw new Error('You must provide a valid value for days since epoch (-2147483648 <= value <= 2147483647).');
      }

      this.date = new Date(year * millisecondsPerDay);
    }
  }

  if (typeof this.date === 'undefined') {
    throw new Error('You must provide a valid year, month and day');
  }
  /** 
   * If date cannot be represented yet given a valid days since epoch, track
   * it internally.
   */


  this._value = isNaN(this.date.getTime()) ? year : null;
  /**
   * A number representing the year.  May return NaN if cannot be represented as
   * a Date.
   * @type Number
   */

  this.year = this.date.getUTCFullYear();
  /**
   * A number between 1 and 12 inclusive representing the month.  May return
   * NaN if cannot be represented as a Date.
   * @type Number
   */

  this.month = this.date.getUTCMonth() + 1;
  /**
   * A number between 1 and the number of days in the given month of the given year (28, 29, 30, 31).
   * May return NaN if cannot be represented as a Date.
   * @type Number
   */

  this.day = this.date.getUTCDate();
}
/**
 * Creates a new instance of LocalDate using the current year, month and day from the system clock in the default time-zone.
 */


LocalDate.now = function () {
  return LocalDate.fromDate(new Date());
};
/**
 * Creates a new instance of LocalDate using the current date from the system clock at UTC.
 */


LocalDate.utcNow = function () {
  return new LocalDate(Date.now());
};
/**
 * Creates a new instance of LocalDate using the year, month and day from the provided local date time.
 * @param {Date} date
 */


LocalDate.fromDate = function (date) {
  if (isNaN(date.getTime())) {
    throw new TypeError('Invalid date: ' + date);
  }

  return new LocalDate(date.getFullYear(), date.getMonth() + 1, date.getDate());
};
/**
 * Creates a new instance of LocalDate using the year, month and day provided in the form: yyyy-mm-dd or
 * days since epoch (i.e. -1 for Dec 31, 1969).
 * @param {String} value
 */


LocalDate.fromString = function (value) {
  var dashCount = (value.match(/-/g) || []).length;

  if (dashCount >= 2) {
    var multiplier = 1;

    if (value[0] === '-') {
      value = value.substring(1);
      multiplier = -1;
    }

    var parts = value.split('-');
    return new LocalDate(multiplier * parseInt(parts[0], 10), parseInt(parts[1], 10), parseInt(parts[2], 10));
  }

  if (value.match(/^-?\d+$/)) {
    // Parse as days since epoch.
    return new LocalDate(parseInt(value, 10));
  }

  throw new Error("Invalid input '" + value + "'.");
};
/**
 * Creates a new instance of LocalDate using the bytes representation.
 * @param {Buffer} buffer
 */


LocalDate.fromBuffer = function (buffer) {
  //move to unix epoch: 0.
  return new LocalDate(buffer.readUInt32BE(0) - dateCenter);
};
/**
 * Compares this LocalDate with the given one.
 * @param {LocalDate} other date to compare against.
 * @return {number} 0 if they are the same, 1 if the this is greater, and -1
 * if the given one is greater.
 */


LocalDate.prototype.compare = function (other) {
  var thisValue = isNaN(this.date.getTime()) ? this._value * millisecondsPerDay : this.date.getTime();
  var otherValue = isNaN(other.date.getTime()) ? other._value * millisecondsPerDay : other.date.getTime();
  var diff = thisValue - otherValue;

  if (diff < 0) {
    return -1;
  }

  if (diff > 0) {
    return 1;
  }

  return 0;
};
/**
 * Returns true if the value of the LocalDate instance and other are the same
 * @param {LocalDate} other
 * @returns {Boolean}
 */


LocalDate.prototype.equals = function (other) {
  return other instanceof LocalDate && this.compare(other) === 0;
};

LocalDate.prototype.inspect = function () {
  return this.constructor.name + ': ' + this.toString();
};
/**
 * Gets the bytes representation of the instance.
 * @returns {Buffer}
 */


LocalDate.prototype.toBuffer = function () {
  //days since unix epoch
  var daysSinceEpoch = isNaN(this.date.getTime()) ? this._value : Math.floor(this.date.getTime() / millisecondsPerDay);
  var value = daysSinceEpoch + dateCenter;
  var buf = utils$M.allocBufferUnsafe(4);
  buf.writeUInt32BE(value, 0);
  return buf;
};
/**
 * Gets the string representation of the instance in the form: yyyy-mm-dd if
 * the value can be parsed as a Date, otherwise days since epoch.
 * @returns {String}
 */


LocalDate.prototype.toString = function () {
  var result; //if cannot be parsed as date, return days since epoch representation.

  if (isNaN(this.date.getTime())) {
    return this._value.toString();
  }

  if (this.year < 0) {
    result = '-' + fillZeros((this.year * -1).toString(), 4);
  } else {
    result = fillZeros(this.year.toString(), 4);
  }

  result += '-' + fillZeros(this.month.toString(), 2) + '-' + fillZeros(this.day.toString(), 2);
  return result;
};
/**
 * Gets the string representation of the instance in the form: yyyy-mm-dd, valid for JSON.
 * @returns {String}
 */


LocalDate.prototype.toJSON = function () {
  return this.toString();
};
/**
 * @param {String} value
 * @param {Number} amount
 * @private
 */


function fillZeros(value, amount) {
  if (value.length >= amount) {
    return value;
  }

  return utils$M.stringRepeat('0', amount - value.length) + value;
}

var localDate = LocalDate;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Long$6 = Long$9.exports;
var util$D = require$$0__default$1["default"];
var utils$L = utils$V;
/** @module types */

/**
 * @const
 * @private
 * */

var maxNanos = Long$6.fromString('86399999999999');
/**
 * Nanoseconds in a second
 * @const
 * @private
 * */

var nanoSecInSec = Long$6.fromNumber(1000000000);
/**
 * Nanoseconds in a millisecond
 * @const
 * @private
 * */

var nanoSecInMillis = Long$6.fromNumber(1000000);
/**
 * Milliseconds in day
 * @const
 * @private
 * */

var millisInDay = 86400000;
/**
 *
 * Creates a new instance of LocalTime.
 * @class
 * @classdesc A time without a time-zone in the ISO-8601 calendar system, such as 10:30:05.
 * <p>
 *   LocalTime is an immutable date-time object that represents a time, often viewed as hour-minute-second. Time is represented to nanosecond precision. For example, the value "13:45.30.123456789" can be stored in a LocalTime.
 * </p>
 * @param {Long} totalNanoseconds Total nanoseconds since midnight.
 * @constructor
 */

function LocalTime(totalNanoseconds) {
  if (!(totalNanoseconds instanceof Long$6)) {
    throw new Error('You must specify a Long value as totalNanoseconds');
  }

  if (totalNanoseconds.lessThan(Long$6.ZERO) || totalNanoseconds.greaterThan(maxNanos)) {
    throw new Error('Total nanoseconds out of range');
  }

  this.value = totalNanoseconds;
  /**
   * Gets the hour component of the time represented by the current instance, a number from 0 to 23.
   * @type Number
   */

  this.hour = this._getParts()[0];
  /**
   * Gets the minute component of the time represented by the current instance, a number from 0 to 59.
   * @type Number
   */

  this.minute = this._getParts()[1];
  /**
   * Gets the second component of the time represented by the current instance, a number from 0 to 59.
   * @type Number
   */

  this.second = this._getParts()[2];
  /**
   * Gets the nanoseconds component of the time represented by the current instance, a number from 0 to 999999999.
   * @type Number
   */

  this.nanosecond = this._getParts()[3];
}
/**
 * Parses an string representation and returns a new LocalDate.
 * @param {String} value
 * @returns {LocalTime}
 */


LocalTime.fromString = function (value) {
  if (typeof value !== 'string') {
    throw new Error('Argument type invalid: ' + util$D.inspect(value));
  }

  var parts = value.split(':');
  var millis = parseInt(parts[0], 10) * 3600000 + parseInt(parts[1], 10) * 60000;
  var nanos;

  if (parts.length === 3) {
    var secParts = parts[2].split('.');
    millis += parseInt(secParts[0], 10) * 1000;

    if (secParts.length === 2) {
      nanos = secParts[1]; //add zeros at the end

      nanos = nanos + utils$L.stringRepeat('0', 9 - nanos.length);
    }
  }

  return LocalTime.fromMilliseconds(millis, parseInt(nanos, 10) || 0);
};
/**
 * Uses the current local time (in milliseconds) and the nanoseconds to create a new instance of LocalTime
 * @param {Number} [nanoseconds] A Number from 0 to 999,999, representing the time nanosecond portion.
 * @returns {LocalTime}
 */


LocalTime.now = function (nanoseconds) {
  return LocalTime.fromDate(new Date(), nanoseconds);
};
/**
 * Uses the provided local time (in milliseconds) and the nanoseconds to create a new instance of LocalTime
 * @param {Date} date Local date portion to extract the time passed since midnight.
 * @param {Number} [nanoseconds] A Number from 0 to 999,999, representing the nanosecond time portion.
 * @returns {LocalTime}
 */


LocalTime.fromDate = function (date, nanoseconds) {
  if (!util$D.isDate(date)) {
    throw new Error('Not a valid date');
  } //Use the local representation, only the milliseconds portion


  var millis = (date.getTime() + date.getTimezoneOffset() * -60000) % millisInDay;
  return LocalTime.fromMilliseconds(millis, nanoseconds);
};
/**
 * Uses the provided local time (in milliseconds) and the nanoseconds to create a new instance of LocalTime
 * @param {Number} milliseconds A Number from 0 to 86,399,999.
 * @param {Number} [nanoseconds] A Number from 0 to 999,999, representing the time nanosecond portion.
 * @returns {LocalTime}
 */


LocalTime.fromMilliseconds = function (milliseconds, nanoseconds) {
  if (typeof nanoseconds !== 'number') {
    nanoseconds = 0;
  }

  return new LocalTime(Long$6.fromNumber(milliseconds).multiply(nanoSecInMillis).add(Long$6.fromNumber(nanoseconds)));
};
/**
 * Creates a new instance of LocalTime from the bytes representation.
 * @param {Buffer} value
 * @returns {LocalTime}
 */


LocalTime.fromBuffer = function (value) {
  if (!(value instanceof Buffer)) {
    throw new TypeError('Expected Buffer, obtained ' + util$D.inspect(value));
  }

  return new LocalTime(new Long$6(value.readInt32BE(4), value.readInt32BE(0)));
};
/**
 * Compares this LocalTime with the given one.
 * @param {LocalTime} other time to compare against.
 * @return {number} 0 if they are the same, 1 if the this is greater, and -1
 * if the given one is greater.
 */


LocalTime.prototype.compare = function (other) {
  return this.value.compare(other.value);
};
/**
 * Returns true if the value of the LocalTime instance and other are the same
 * @param {LocalTime} other
 * @returns {Boolean}
 */


LocalTime.prototype.equals = function (other) {
  return other instanceof LocalTime && this.compare(other) === 0;
};
/**
 * Gets the total amount of nanoseconds since midnight for this instance.
 * @returns {Long}
 */


LocalTime.prototype.getTotalNanoseconds = function () {
  return this.value;
};

LocalTime.prototype.inspect = function () {
  return this.constructor.name + ': ' + this.toString();
};
/**
 * Returns a big-endian bytes representation of the instance
 * @returns {Buffer}
 */


LocalTime.prototype.toBuffer = function () {
  var buffer = utils$L.allocBufferUnsafe(8);
  buffer.writeUInt32BE(this.value.getHighBitsUnsigned(), 0);
  buffer.writeUInt32BE(this.value.getLowBitsUnsigned(), 4);
  return buffer;
};
/**
 * Returns the string representation of the instance in the form of hh:MM:ss.ns
 * @returns {String}
 */


LocalTime.prototype.toString = function () {
  return formatTime(this._getParts());
};
/**
 * Gets the string representation of the instance in the form: hh:MM:ss.ns
 * @returns {String}
 */


LocalTime.prototype.toJSON = function () {
  return this.toString();
};
/**
 * @returns {Array.<Number>}
 * @ignore
 */


LocalTime.prototype._getParts = function () {
  if (!this._partsCache) {
    //hours, minutes, seconds and nanos
    var parts = [0, 0, 0, 0];
    var secs = this.value.div(nanoSecInSec); //faster modulo
    //total nanos

    parts[3] = this.value.subtract(secs.multiply(nanoSecInSec)).toNumber(); //seconds

    parts[2] = secs.toNumber();

    if (parts[2] >= 60) {
      //minutes
      parts[1] = Math.floor(parts[2] / 60);
      parts[2] = parts[2] % 60;
    }

    if (parts[1] >= 60) {
      //hours
      parts[0] = Math.floor(parts[1] / 60);
      parts[1] = parts[1] % 60;
    }

    this._partsCache = parts;
  }

  return this._partsCache;
};
/**
 * @param {Array.<Number>} values
 * @private
 */


function formatTime(values) {
  var result;

  if (values[0] < 10) {
    result = '0' + values[0] + ':';
  } else {
    result = values[0] + ':';
  }

  if (values[1] < 10) {
    result += '0' + values[1] + ':';
  } else {
    result += values[1] + ':';
  }

  if (values[2] < 10) {
    result += '0' + values[2];
  } else {
    result += values[2];
  }

  if (values[3] > 0) {
    var nanos = values[3].toString(); //nine digits

    if (nanos.length < 9) {
      nanos = utils$L.stringRepeat('0', 9 - nanos.length) + nanos;
    }

    var lastPosition;

    for (var i = nanos.length - 1; i > 0; i--) {
      if (nanos[i] !== '0') {
        break;
      }

      lastPosition = i;
    }

    if (lastPosition) {
      nanos = nanos.substring(0, lastPosition);
    }

    result += '.' + nanos;
  }

  return result;
}

var localTime = LocalTime;

var utils$K = utils$V;
var errors$q = errors$s;
var asyncIteratorSymbol = Symbol.asyncIterator || '@@asyncIterator';
/** @module types */

/**
 * Creates a new instance of ResultSet.
 * @class
 * @classdesc Represents the result of a query.
 * @param {Object} response
 * @param {String} host
 * @param {Object} triedHosts
 * @param {Number} speculativeExecutions
 * @param {Number} consistency
 * @param {Boolean} isSchemaInAgreement
 * @constructor
 */

function ResultSet(response, host, triedHosts, speculativeExecutions, consistency, isSchemaInAgreement) {
  // if no execution was made at all, set to 0.
  if (speculativeExecutions === -1) {
    speculativeExecutions = 0;
  }
  /**
   * Information on the execution of a successful query:
   * @member {Object}
   * @property {Number} achievedConsistency The consistency level that has been actually achieved by the query.
   * @property {String} queriedHost The Cassandra host that coordinated this query.
   * @property {Object} triedHosts Gets the associative array of host that were queried before getting a valid response,
   * being the last host the one that replied correctly.
   * @property {Object} speculativeExecutions The number of speculative executions (not including the first) executed before
   * getting a valid response.
   * @property {Uuid} traceId Identifier of the trace session.
   * @property {Array.<string>} warnings Warning messages generated by the server when executing the query.
   * @property {Boolean} isSchemaInAgreement Whether the cluster had reached schema agreement after the execution of
   * this query.
   * <p>
   *   After a successful schema-altering query (ex: creating a table), the driver will check if
   *   the cluster's nodes agree on the new schema version. If not, it will keep retrying for a given
   *   delay (see <code>protocolOptions.maxSchemaAgreementWaitSeconds</code>).
   * </p>
   * <p>
   *   Note that the schema agreement check is only performed for schema-altering queries For other
   *   query types, this method will always return <code>true</code>. If this method returns <code>false</code>,
   *   clients can call [Metadata.checkSchemaAgreement()]{@link module:metadata~Metadata#checkSchemaAgreement} later to
   *   perform the check manually.
   * </p>
   */


  this.info = {
    queriedHost: host,
    triedHosts: triedHosts,
    speculativeExecutions: speculativeExecutions,
    achievedConsistency: consistency,
    traceId: null,
    warnings: null,
    customPayload: null,
    isSchemaInAgreement: isSchemaInAgreement
  };

  if (response.flags) {
    this.info.traceId = response.flags.traceId;
    this.info.warnings = response.flags.warnings;
    this.info.customPayload = response.flags.customPayload;
  }
  /**
   * Gets an array rows returned by the query.
   * When the result set represents a response from a write query, this property will be <code>undefined</code>.
   * When the read query result contains more rows than the fetch size (5000), this property will only contain the
   * first rows up to fetch size. To obtain all the rows, you can use the built-in async iterator that will retrieve the
   * following pages of results.
   * @type {Array<Row>|undefined}
   */


  this.rows = response.rows;
  /**
   * Gets the row length of the result, regardless if the result has been buffered or not
   * @type {Number|undefined}
   */

  this.rowLength = this.rows ? this.rows.length : response.rowLength;
  /**
   * Gets the columns returned in this ResultSet.
   * @type {Array.<{name, type}>}
   * @default null
   */

  this.columns = null;
  /**
   * A string token representing the current page state of query. It can be used in the following executions to
   * continue paging and retrieve the remained of the result for the query.
   * @type {String|null}
   * @default null
   */

  this.pageState = null;
  /**
   * Method used to manually fetch the next page of results.
   * This method is only exposed when using the {@link Client#eachRow} method and there are more rows available in
   * following pages.
   * @type Function
   */

  this.nextPage = undefined;
  /**
   * Method used internally to fetch the next page of results using promises.
   * @internal
   * @ignore
   * @type {Function}
   */

  this.nextPageAsync = undefined;
  var meta = response.meta;

  if (meta) {
    this.columns = meta.columns;

    if (meta.pageState) {
      this.pageState = meta.pageState.toString('hex'); // Expose rawPageState internally

      Object.defineProperty(this, 'rawPageState', {
        value: meta.pageState,
        enumerable: false
      });
    }
  }
}
/**
 * Returns the first row or null if the result rows are empty.
 */


ResultSet.prototype.first = function () {
  if (this.rows && this.rows.length) {
    return this.rows[0];
  }

  return null;
};

ResultSet.prototype.getPageState = function () {
  // backward-compatibility
  return this.pageState;
};

ResultSet.prototype.getColumns = function () {
  // backward-compatibility
  return this.columns;
};
/**
 * When this instance is the result of a conditional update query, it returns whether it was successful.
 * Otherwise, it returns <code>true</code>.
 * <p>
 *   For consistency, this method always returns <code>true</code> for non-conditional queries (although there is
 *   no reason to call the method in that case). This is also the case for conditional DDL statements
 *   (CREATE KEYSPACE... IF NOT EXISTS, CREATE TABLE... IF NOT EXISTS), for which the server doesn't return
 *   information whether it was applied or not.
 * </p>
 */


ResultSet.prototype.wasApplied = function () {
  if (!this.rows || this.rows.length === 0) {
    return true;
  }

  var firstRow = this.rows[0];
  var applied = firstRow['[applied]'];
  return typeof applied === 'boolean' ? applied : true;
};
/**
 * Gets the iterator function.
 * <p>
 *   Retrieves the iterator of the underlying fetched rows, without causing the driver to fetch the following
 *   result pages. For more information on result paging,
 *   [visit the documentation]{@link http://docs.datastax.com/en/developer/nodejs-driver/latest/features/paging/}.
 * </p>
 * @alias module:types~ResultSet#@@iterator
 * @see {@link module:types~ResultSet#@@asyncIterator}
 * @example <caption>Using for...of statement</caption>
 * const query = 'SELECT user_id, post_id, content FROM timeline WHERE user_id = ?';
 * const result = await client.execute(query, [ id ], { prepare: true });
 * for (const row of result) {
 *   console.log(row['email']);
 * }
 * @returns {Iterator.<Row>}
 */


ResultSet.prototype[Symbol.iterator] = function getIterator() {
  if (!this.rows) {
    return utils$K.emptyArray[Symbol.iterator]();
  }

  return this.rows[Symbol.iterator]();
};
/**
 * Gets the async iterator function.
 * <p>
 *   Retrieves the async iterator representing the entire query result, the driver will fetch the following result
 *   pages.
 * </p>
 * <p>Use the async iterator when the query result might contain more rows than the <code>fetchSize</code>.</p>
 * <p>
 *   Note that using the async iterator will not affect the internal state of the <code>ResultSet</code> instance.
 *   You should avoid using both <code>rows</code> property that contains the row instances of the first page of
 *   results, and the async iterator, that will yield all the rows in the result regardless on the number of pages.
 * </p>
 * <p>Multiple concurrent async iterations are not supported.</p>
 * @alias module:types~ResultSet#@@asyncIterator
 * @example <caption>Using for await...of statement</caption>
 * const query = 'SELECT user_id, post_id, content FROM timeline WHERE user_id = ?';
 * const result = await client.execute(query, [ id ], { prepare: true });
 * for await (const row of result) {
 *   console.log(row['email']);
 * }
 * @returns {AsyncIterator<Row>}
 */


ResultSet.prototype[asyncIteratorSymbol] = function getAsyncGenerator() {
  var index = 0;
  var pageState = this.rawPageState;
  var rows = this.rows;

  if (!rows || rows.length === 0) {
    return {
      next: function next() {
        return Promise.resolve({
          done: true
        });
      }
    };
  }

  var self = this; // Async generators are not present in Node.js 8, implement it manually

  return {
    next: function next() {
      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var rs;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(index >= rows.length && pageState)) {
                  _context.next = 9;
                  break;
                }

                if (self.nextPageAsync) {
                  _context.next = 3;
                  break;
                }

                throw new errors$q.DriverInternalError('Property nextPageAsync should be set when pageState is defined');

              case 3:
                _context.next = 5;
                return self.nextPageAsync(pageState);

              case 5:
                rs = _context.sent;
                rows = rs.rows;
                index = 0;
                pageState = rs.rawPageState;

              case 9:
                if (!(index < rows.length)) {
                  _context.next = 11;
                  break;
                }

                return _context.abrupt("return", {
                  done: false,
                  value: rows[index++]
                });

              case 11:
                return _context.abrupt("return", {
                  done: true
                });

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
  };
};
/**
 * Determines whether there are more pages of results.
 * If so, the driver will initially retrieve and contain only the first page of results.
 * To obtain all the rows, use the [AsyncIterator]{@linkcode module:types~ResultSet#@@asyncIterator}.
 * @returns {boolean}
 */


ResultSet.prototype.isPaged = function () {
  return !!this.rawPageState;
};

var resultSet$1 = ResultSet;

var Readable = require$$0__default$5["default"].Readable;
var utils$J = utils$V;
var errors$p = errors$s;
var clientOptions$2 = clientOptions$3;
/** @module types */

/**
 * Readable stream using to yield data from a result or a field
 */

var ResultStream = /*#__PURE__*/function (_Readable) {
  _inherits(ResultStream, _Readable);

  var _super = _createSuper(ResultStream);

  function ResultStream(opt) {
    var _this;

    _classCallCheck(this, ResultStream);

    _this = _super.call(this, opt);
    _this.buffer = [];
    _this.paused = true;
    _this._cancelAllowed = false;
    _this._handlersObject = null;
    _this._highWaterMarkRows = 0;
    return _this;
  }

  _createClass(ResultStream, [{
    key: "_read",
    value: function _read() {
      this.paused = false;

      if (this.buffer.length === 0) {
        this._readableState.reading = false;
      }

      while (!this.paused && this.buffer.length > 0) {
        this.paused = !this.push(this.buffer.shift());
      }

      this._checkBelowHighWaterMark();

      if (!this.paused && !this.buffer.length && this._readNext) {
        this._readNext();

        this._readNext = null;
      }
    }
    /**
     * Allows for throttling, helping nodejs keep the internal buffers reasonably sized.
     * @param {function} readNext function that triggers reading the next result chunk
     * @ignore
     */

  }, {
    key: "_valve",
    value: function _valve(readNext) {
      this._readNext = null;

      if (!readNext) {
        return;
      }

      if (this.paused || this.buffer.length) {
        this._readNext = readNext;
      } else {
        readNext();
      }
    }
  }, {
    key: "add",
    value: function add(chunk) {
      var length = this.buffer.push(chunk);
      this.read(0);

      this._checkAboveHighWaterMark();

      return length;
    }
  }, {
    key: "_checkAboveHighWaterMark",
    value: function _checkAboveHighWaterMark() {
      if (!this._handlersObject || !this._handlersObject.resumeReadingHandler) {
        return;
      }

      if (this._highWaterMarkRows === 0 || this.buffer.length !== this._highWaterMarkRows) {
        return;
      }

      this._handlersObject.resumeReadingHandler(false);
    }
  }, {
    key: "_checkBelowHighWaterMark",
    value: function _checkBelowHighWaterMark() {
      if (!this._handlersObject || !this._handlersObject.resumeReadingHandler) {
        return;
      }

      if (this._highWaterMarkRows === 0 || this.buffer.length >= this._highWaterMarkRows) {
        return;
      } // The consumer has dequeued below the watermark


      this._handlersObject.resumeReadingHandler(true);
    }
    /**
     * When continuous paging is enabled, allows the client to notify to the server to stop pushing further pages.
     * <p>Note: This is not part of the public API yet.</p>
     * @param {Function} [callback] The cancel method accepts an optional callback.
     * @example <caption>Cancelling a continuous paging execution</caption>
     * const stream = client.stream(query, params, { prepare: true, continuousPaging: true });
     * // ...
     * // Ask the server to stop pushing rows.
     * stream.cancel();
     * @ignore
     */

  }, {
    key: "cancel",
    value: function cancel(callback) {
      if (!this._cancelAllowed) {
        var err = new Error('You can only cancel streaming executions when continuous paging is enabled');

        if (!callback) {
          throw err;
        }

        return callback(err);
      }

      if (!this._handlersObject) {
        throw new errors$p.DriverInternalError('ResultStream cancel is allowed but the cancel options were not set');
      }

      callback = callback || utils$J.noop;

      if (!this._handlersObject.cancelHandler) {
        // The handler is not yet set
        // Set the callback as a flag to identify that the cancel handler must be invoked when set
        this._handlersObject.cancelHandler = callback;
        return;
      }

      this._handlersObject.cancelHandler(callback);
    }
    /**
     * Sets the pointer to the handler to be used to cancel the continuous page execution.
     * @param options
     * @internal
     * @ignore
     */

  }, {
    key: "setHandlers",
    value: function setHandlers(options) {
      if (!options.continuousPaging) {
        return;
      }

      this._cancelAllowed = true;
      this._handlersObject = options;
      this._highWaterMarkRows = options.continuousPaging.highWaterMarkRows || clientOptions$2.continuousPageDefaultHighWaterMark;
    }
  }]);

  return ResultStream;
}(Readable);

var resultStream = ResultStream;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @module types */

/**
 * Represents a result row
 * @param {Array} columns
 * @constructor
 */


function Row(columns) {
  if (!columns) {
    throw new Error('Columns not defined');
  } //Private non-enumerable properties, with double underscore to avoid interfering with column names


  Object.defineProperty(this, '__columns', {
    value: columns,
    enumerable: false,
    writable: false
  });
}
/**
 * Returns the cell value.
 * @param {String|Number} columnName Name or index of the column
 */


Row.prototype.get = function (columnName) {
  if (typeof columnName === 'number') {
    //its an index
    return this[this.__columns[columnName].name];
  }

  return this[columnName];
};
/**
 * Returns an array of the values of the row
 * @returns {Array}
 */


Row.prototype.values = function () {
  var valuesArray = [];
  this.forEach(function (val) {
    valuesArray.push(val);
  });
  return valuesArray;
};
/**
 * Returns an array of the column names of the row
 * @returns {Array}
 */


Row.prototype.keys = function () {
  var keysArray = [];
  this.forEach(function (val, key) {
    keysArray.push(key);
  });
  return keysArray;
};
/**
 * Executes the callback for each field in the row, containing the value as first parameter followed by the columnName
 * @param {Function} callback
 */


Row.prototype.forEach = function (callback) {
  for (var columnName in this) {
    if (!this.hasOwnProperty(columnName)) {
      continue;
    }

    callback(this[columnName], columnName);
  }
};

var row = Row;

/** @module types */

/**
 * Creates a new sequence of immutable objects with the parameters provided.
 * @class
 * @classdesc A tuple is a sequence of immutable objects.
 * Tuples are sequences, just like [Arrays]{@link Array}. The only difference is that tuples can't be changed.
 * <p>
 *   As tuples can be used as a Map keys, the {@link Tuple#toString toString()} method calls toString of each element,
 *   to try to get a unique string key.
 * </p>
 * @param args The sequence elements as arguments.
 * @constructor
 */


function Tuple$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  /**
   * Immutable elements of Tuple object.
   * @type Array
   */
  this.elements = args;

  if (this.elements.length === 0) {
    throw new TypeError('Tuple must contain at least one value');
  }
  /**
   * Returns the number of the elements.
   * @type Number
   */


  this.length = this.elements.length;
}
/**
 * Creates a new instance of a tuple based on the Array
 * @param {Array} elements
 * @returns {Tuple}
 */


Tuple$1.fromArray = function (elements) {
  // Apply the elements Array as parameters
  return _construct(Tuple$1, _toConsumableArray(elements));
};
/**
 * Returns the value located at the index.
 * @param {Number} index Element index
 */


Tuple$1.prototype.get = function (index) {
  return this.elements[index || 0];
};
/**
 * Returns the string representation of the sequence surrounded by parenthesis, ie: (1, 2).
 * <p>
 *   The returned value attempts to be a unique string representation of its values.
 * </p>
 * @returns {string}
 */


Tuple$1.prototype.toString = function () {
  return '(' + this.elements.reduce(function (prev, x, i) {
    return prev + (i > 0 ? ',' : '') + x.toString();
  }, '') + ')';
};
/**
 * Returns the Array representation of the sequence.
 * @returns {Array}
 */


Tuple$1.prototype.toJSON = function () {
  return this.elements;
};
/**
 * Gets the elements as an array
 * @returns {Array}
 */


Tuple$1.prototype.values = function () {
  // Clone the elements
  return this.elements.slice(0);
};

var tuple = Tuple$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$C = require$$0__default$1["default"];
var errors$o = errors$s;
var TimeUuid = timeUuid;
var Uuid = uuid$1;
var protocolVersion = protocolVersion_1;
var utils$I = utils$V;
/** @module types */

/**
 * Long constructor, wrapper of the internal library used: {@link https://github.com/dcodeIO/long.js Long.js}.
 * @constructor
 */

var Long$5 = Long$9.exports;
/**
 * Consistency levels
 * @type {Object}
 * @property {Number} any Writing: A write must be written to at least one node. If all replica nodes for the given row key are down, the write can still succeed after a hinted handoff has been written. If all replica nodes are down at write time, an ANY write is not readable until the replica nodes for that row have recovered.
 * @property {Number} one Returns a response from the closest replica, as determined by the snitch.
 * @property {Number} two Returns the most recent data from two of the closest replicas.
 * @property {Number} three Returns the most recent data from three of the closest replicas.
 * @property {Number} quorum Reading: Returns the record with the most recent timestamp after a quorum of replicas has responded regardless of data center. Writing: A write must be written to the commit log and memory table on a quorum of replica nodes.
 * @property {Number} all Reading: Returns the record with the most recent timestamp after all replicas have responded. The read operation will fail if a replica does not respond. Writing: A write must be written to the commit log and memory table on all replica nodes in the cluster for that row.
 * @property {Number} localQuorum Reading: Returns the record with the most recent timestamp once a quorum of replicas in the current data center as the coordinator node has reported. Writing: A write must be written to the commit log and memory table on a quorum of replica nodes in the same data center as the coordinator node. Avoids latency of inter-data center communication.
 * @property {Number} eachQuorum Reading: Returns the record once a quorum of replicas in each data center of the cluster has responded. Writing: Strong consistency. A write must be written to the commit log and memtable on a quorum of replica nodes in all data centers.
 * @property {Number} serial Achieves linearizable consistency for lightweight transactions by preventing unconditional updates.
 * @property {Number} localSerial Same as serial but confined to the data center. A write must be written conditionally to the commit log and memtable on a quorum of replica nodes in the same data center.
 * @property {Number} localOne Similar to One but only within the DC the coordinator is in.
 */

var consistencies = {
  any: 0x00,
  one: 0x01,
  two: 0x02,
  three: 0x03,
  quorum: 0x04,
  all: 0x05,
  localQuorum: 0x06,
  eachQuorum: 0x07,
  serial: 0x08,
  localSerial: 0x09,
  localOne: 0x0a
};
/**
 * Mapping of consistency level codes to their string representation.
 * @type {Object}
 */

var consistencyToString = {};
consistencyToString[consistencies.any] = 'ANY';
consistencyToString[consistencies.one] = 'ONE';
consistencyToString[consistencies.two] = 'TWO';
consistencyToString[consistencies.three] = 'THREE';
consistencyToString[consistencies.quorum] = 'QUORUM';
consistencyToString[consistencies.all] = 'ALL';
consistencyToString[consistencies.localQuorum] = 'LOCAL_QUORUM';
consistencyToString[consistencies.eachQuorum] = 'EACH_QUORUM';
consistencyToString[consistencies.serial] = 'SERIAL';
consistencyToString[consistencies.localSerial] = 'LOCAL_SERIAL';
consistencyToString[consistencies.localOne] = 'LOCAL_ONE';
/**
 * CQL data types
 * @type {Object}
 * @property {Number} custom A custom type.
 * @property {Number} ascii ASCII character string.
 * @property {Number} bigint 64-bit signed long.
 * @property {Number} blob Arbitrary bytes (no validation).
 * @property {Number} boolean true or false.
 * @property {Number} counter Counter column (64-bit signed value).
 * @property {Number} decimal Variable-precision decimal.
 * @property {Number} double 64-bit IEEE-754 floating point.
 * @property {Number} float 32-bit IEEE-754 floating point.
 * @property {Number} int 32-bit signed integer.
 * @property {Number} text UTF8 encoded string.
 * @property {Number} timestamp A timestamp.
 * @property {Number} uuid Type 1 or type 4 UUID.
 * @property {Number} varchar UTF8 encoded string.
 * @property {Number} varint Arbitrary-precision integer.
 * @property {Number} timeuuid  Type 1 UUID.
 * @property {Number} inet An IP address. It can be either 4 bytes long (IPv4) or 16 bytes long (IPv6).
 * @property {Number} date A date without a time-zone in the ISO-8601 calendar system.
 * @property {Number} time A value representing the time portion of the day.
 * @property {Number} smallint 16-bit two's complement integer.
 * @property {Number} tinyint 8-bit two's complement integer.
 * @property {Number} list A collection of elements.
 * @property {Number} map Key/value pairs.
 * @property {Number} set A collection that contains no duplicate elements.
 * @property {Number} udt User-defined type.
 * @property {Number} tuple A sequence of values.
 */

var dataTypes$5 = {
  custom: 0x0000,
  ascii: 0x0001,
  bigint: 0x0002,
  blob: 0x0003,
  "boolean": 0x0004,
  counter: 0x0005,
  decimal: 0x0006,
  "double": 0x0007,
  "float": 0x0008,
  "int": 0x0009,
  text: 0x000a,
  timestamp: 0x000b,
  uuid: 0x000c,
  varchar: 0x000d,
  varint: 0x000e,
  timeuuid: 0x000f,
  inet: 0x0010,
  date: 0x0011,
  time: 0x0012,
  smallint: 0x0013,
  tinyint: 0x0014,
  duration: 0x0015,
  list: 0x0020,
  map: 0x0021,
  set: 0x0022,
  udt: 0x0030,
  tuple: 0x0031,

  /**
   * Returns the typeInfo of a given type name
   * @param name
   * @returns {{code: number, info: *|Object}}
   */
  getByName: function getByName(name) {
    name = name.toLowerCase();

    if (name.indexOf('<') > 0) {
      var listMatches = /^(list|set)<(.+)>$/.exec(name);

      if (listMatches) {
        return {
          code: this[listMatches[1]],
          info: this.getByName(listMatches[2])
        };
      }

      var mapMatches = /^(map)< *(.+) *, *(.+)>$/.exec(name);

      if (mapMatches) {
        return {
          code: this[mapMatches[1]],
          info: [this.getByName(mapMatches[2]), this.getByName(mapMatches[3])]
        };
      }

      var udtMatches = /^(udt)<(.+)>$/.exec(name);

      if (udtMatches) {
        //udt name as raw string
        return {
          code: this[udtMatches[1]],
          info: udtMatches[2]
        };
      }

      var tupleMatches = /^(tuple)<(.+)>$/.exec(name);

      if (tupleMatches) {
        //tuple info as an array of types
        return {
          code: this[tupleMatches[1]],
          info: tupleMatches[2].split(',').map(function (x) {
            return this.getByName(x.trim());
          }, this)
        };
      }
    }

    var typeInfo = {
      code: this[name],
      info: null
    };

    if (typeof typeInfo.code !== 'number') {
      throw new TypeError('Data type with name ' + name + ' not valid');
    }

    return typeInfo;
  }
};
/**
 * Map of Data types by code
 * @internal
 * @private
 */

var _dataTypesByCode = function () {
  var result = {};

  for (var key in dataTypes$5) {
    if (!dataTypes$5.hasOwnProperty(key)) {
      continue;
    }

    var val = dataTypes$5[key];

    if (typeof val !== 'number') {
      continue;
    }

    result[val] = key;
  }

  return result;
}();
/**
 * Represents the distance of Cassandra node as assigned by a LoadBalancingPolicy relatively to the driver instance.
 * @type {Object}
 * @property {Number} local A local node.
 * @property {Number} remote A remote node.
 * @property {Number} ignored A node that is meant to be ignored.
 */


var distance = {
  local: 0,
  remote: 1,
  ignored: 2
};
/**
 * An integer byte that distinguish the actual message from and to Cassandra
 * @internal
 * @ignore
 */

var opcodes = {
  error: 0x00,
  startup: 0x01,
  ready: 0x02,
  authenticate: 0x03,
  credentials: 0x04,
  options: 0x05,
  supported: 0x06,
  query: 0x07,
  result: 0x08,
  prepare: 0x09,
  execute: 0x0a,
  register: 0x0b,
  event: 0x0c,
  batch: 0x0d,
  authChallenge: 0x0e,
  authResponse: 0x0f,
  authSuccess: 0x10,
  cancel: 0xff,

  /**
   * Determines if the code is a valid opcode
   */
  isInRange: function isInRange(code) {
    return code > this.error && code > this.event;
  }
};
/**
 * Event types from Cassandra
 * @type {{topologyChange: string, statusChange: string, schemaChange: string}}
 * @internal
 * @ignore
 */

var protocolEvents = {
  topologyChange: 'TOPOLOGY_CHANGE',
  statusChange: 'STATUS_CHANGE',
  schemaChange: 'SCHEMA_CHANGE'
};
/**
 * Server error codes returned by Cassandra
 * @type {Object}
 * @property {Number} serverError Something unexpected happened.
 * @property {Number} protocolError Some client message triggered a protocol violation.
 * @property {Number} badCredentials Authentication was required and failed.
 * @property {Number} unavailableException Raised when coordinator knows there is not enough replicas alive to perform a query with the requested consistency level.
 * @property {Number} overloaded The request cannot be processed because the coordinator is overloaded.
 * @property {Number} isBootstrapping The request was a read request but the coordinator node is bootstrapping.
 * @property {Number} truncateError Error encountered during a truncate request.
 * @property {Number} writeTimeout Timeout encountered on write query on coordinator waiting for response(s) from replicas.
 * @property {Number} readTimeout Timeout encountered on read query on coordinator waitign for response(s) from replicas.
 * @property {Number} readFailure A non-timeout error encountered during a read request.
 * @property {Number} functionFailure A (user defined) function encountered during execution.
 * @property {Number} writeFailure A non-timeout error encountered during a write request.
 * @property {Number} syntaxError The submitted query has a syntax error.
 * @property {Number} unauthorized The logged user doesn't have the right to perform the query.
 * @property {Number} invalid The query is syntactically correct but invalid.
 * @property {Number} configError The query is invalid because of some configuration issue.
 * @property {Number} alreadyExists The query attempted to create a schema element (i.e. keyspace, table) that already exists.
 * @property {Number} unprepared Can be thrown while a prepared statement tries to be executed if the provided statement is not known by the coordinator.
 */

var responseErrorCodes = {
  serverError: 0x0000,
  protocolError: 0x000A,
  badCredentials: 0x0100,
  unavailableException: 0x1000,
  overloaded: 0x1001,
  isBootstrapping: 0x1002,
  truncateError: 0x1003,
  writeTimeout: 0x1100,
  readTimeout: 0x1200,
  readFailure: 0x1300,
  functionFailure: 0x1400,
  writeFailure: 0x1500,
  syntaxError: 0x2000,
  unauthorized: 0x2100,
  invalid: 0x2200,
  configError: 0x2300,
  alreadyExists: 0x2400,
  unprepared: 0x2500,
  clientWriteFailure: 0x8000
};
/**
 * Type of result included in a response
 * @internal
 * @ignore
 */

var resultKind = {
  voidResult: 0x0001,
  rows: 0x0002,
  setKeyspace: 0x0003,
  prepared: 0x0004,
  schemaChange: 0x0005
};
/**
 * Message frame flags
 * @internal
 * @ignore
 */

var frameFlags = {
  compression: 0x01,
  tracing: 0x02,
  customPayload: 0x04,
  warning: 0x08
};
/**
 * Unset representation.
 * <p>
 *   Use this field if you want to set a parameter to <code>unset</code>. Valid for Cassandra 2.2 and above.
 * </p>
 */

var unset = Object.freeze({
  'unset': true
});
/**
 * A long representing the value 1000
 * @const
 * @private
 */

var _longOneThousand$1 = Long$5.fromInt(1000);
/**
 * Counter used to generate up to 1000 different timestamp values with the same Date
 * @private
 */


var _timestampTicks = 0;
/**
 * <p><strong>Backward compatibility only, use [TimeUuid]{@link module:types~TimeUuid} instead</strong>.</p>
 * Generates and returns a RFC4122 v1 (timestamp based) UUID in a string representation.
 * @param {{msecs, node, clockseq, nsecs}} [options]
 * @param {Buffer} [buffer]
 * @param {Number} [offset]
 * @deprecated Use [TimeUuid]{@link module:types~TimeUuid} instead
 */

function timeuuid(options, buffer, offset) {
  var date;
  var ticks;
  var nodeId;
  var clockId;

  if (options) {
    if (typeof options.msecs === 'number') {
      date = new Date(options.msecs);
    }

    if (options.msecs instanceof Date) {
      date = options.msecs;
    }

    if (Array.isArray(options.node)) {
      nodeId = utils$I.allocBufferFromArray(options.node);
    }

    if (typeof options.clockseq === 'number') {
      clockId = utils$I.allocBufferUnsafe(2);
      clockId.writeUInt16BE(options.clockseq, 0);
    }

    if (typeof options.nsecs === 'number') {
      ticks = options.nsecs;
    }
  }

  var uuid = new TimeUuid(date, ticks, nodeId, clockId);

  if (buffer instanceof Buffer) {
    //copy the values into the buffer
    uuid.getBuffer().copy(buffer, offset || 0);
    return buffer;
  }

  return uuid.toString();
}
/**
 * <p><strong>Backward compatibility only, use [Uuid]{@link module:types~Uuid} class instead</strong>.</p>
 * Generate and return a RFC4122 v4 UUID in a string representation.
 * @deprecated Use [Uuid]{@link module:types~Uuid} class instead
 */


function uuid(options, buffer, offset) {
  var uuid;

  if (options) {
    if (Array.isArray(options.random)) {
      uuid = new Uuid(utils$I.allocBufferFromArray(options.random));
    }
  }

  if (!uuid) {
    uuid = Uuid.random();
  }

  if (buffer instanceof Buffer) {
    //copy the values into the buffer
    uuid.getBuffer().copy(buffer, offset || 0);
    return buffer;
  }

  return uuid.toString();
}
/**
 * Gets the data type name for a given type definition
 * @internal
 * @ignore
 * @throws {ArgumentError}
 */


function getDataTypeNameByCode(item) {
  if (!item || typeof item.code !== 'number') {
    throw new errors$o.ArgumentError('Invalid signature type definition');
  }

  var typeName = _dataTypesByCode[item.code];

  if (!typeName) {
    throw new errors$o.ArgumentError(util$C.format('Type with code %d not found', item.code));
  }

  if (!item.info) {
    return typeName;
  }

  if (Array.isArray(item.info)) {
    return typeName + '<' + item.info.map(function (t) {
      return getDataTypeNameByCode(t);
    }).join(', ') + '>';
  }

  if (typeof item.info.code === 'number') {
    return typeName + '<' + getDataTypeNameByCode(item.info) + '>';
  }

  return typeName;
} //classes

/**
 * Represents a frame header that could be used to read from a Buffer or to write to a Buffer
 * @ignore
 * @param {Number} version Protocol version
 * @param {Number} flags
 * @param {Number} streamId
 * @param {Number} opcode
 * @param {Number} bodyLength
 * @constructor
 */


function FrameHeader$2(version, flags, streamId, opcode, bodyLength) {
  this.version = version;
  this.flags = flags;
  this.streamId = streamId;
  this.opcode = opcode;
  this.bodyLength = bodyLength;
}
/**
 * The length of the header of the frame based on the protocol version
 * @returns {Number}
 */


FrameHeader$2.size = function (version) {
  if (protocolVersion.uses2BytesStreamIds(version)) {
    return 9;
  }

  return 8;
};
/**
 * Gets the protocol version based on the first byte of the header
 * @param {Buffer} buffer
 * @returns {Number}
 */


FrameHeader$2.getProtocolVersion = function (buffer) {
  return buffer[0] & 0x7F;
};
/**
 * @param {Buffer} buf
 * @param {Number} [offset]
 * @returns {FrameHeader}
 */


FrameHeader$2.fromBuffer = function (buf, offset) {
  var streamId = 0;

  if (!offset) {
    offset = 0;
  }

  var version = buf[offset++] & 0x7F;
  var flags = buf.readUInt8(offset++);

  if (!protocolVersion.uses2BytesStreamIds(version)) {
    streamId = buf.readInt8(offset++);
  } else {
    streamId = buf.readInt16BE(offset);
    offset += 2;
  }

  return new FrameHeader$2(version, flags, streamId, buf.readUInt8(offset++), buf.readUInt32BE(offset));
};
/** @returns {Buffer} */


FrameHeader$2.prototype.toBuffer = function () {
  var buf = utils$I.allocBufferUnsafe(FrameHeader$2.size(this.version));
  buf.writeUInt8(this.version, 0);
  buf.writeUInt8(this.flags, 1);
  var offset = 3;

  if (!protocolVersion.uses2BytesStreamIds(this.version)) {
    buf.writeInt8(this.streamId, 2);
  } else {
    buf.writeInt16BE(this.streamId, 2);
    offset = 4;
  }

  buf.writeUInt8(this.opcode, offset++);
  buf.writeUInt32BE(this.bodyLength, offset);
  return buf;
};
/**
 * Returns a long representation.
 * Used internally for deserialization
 */


Long$5.fromBuffer = function (value) {
  if (!(value instanceof Buffer)) {
    throw new TypeError('Expected Buffer, obtained ' + util$C.inspect(value));
  }

  return new Long$5(value.readInt32BE(4), value.readInt32BE(0));
};
/**
 * Returns a big-endian buffer representation of the Long instance
 * @param {Long} value
 */


Long$5.toBuffer = function (value) {
  if (!(value instanceof Long$5)) {
    throw new TypeError('Expected Long, obtained ' + util$C.inspect(value));
  }

  var buffer = utils$I.allocBufferUnsafe(8);
  buffer.writeUInt32BE(value.getHighBitsUnsigned(), 0);
  buffer.writeUInt32BE(value.getLowBitsUnsigned(), 4);
  return buffer;
};
/**
 * Provide the name of the constructor and the string representation
 * @returns {string}
 */


Long$5.prototype.inspect = function () {
  return 'Long: ' + this.toString();
};
/**
 * Returns the string representation.
 * Method used by the native JSON.stringify() to serialize this instance
 */


Long$5.prototype.toJSON = function () {
  return this.toString();
};
/**
 * Generates a value representing the timestamp for the query in microseconds based on the date and the microseconds provided
 * @param {Date} [date] The date to generate the value, if not provided it will use the current date.
 * @param {Number} [microseconds] A number from 0 to 999 used to build the microseconds part of the date.
 * @returns {Long}
 */


function generateTimestamp(date, microseconds) {
  if (!date) {
    date = new Date();
  }

  var longMicro = Long$5.ZERO;

  if (typeof microseconds === 'number' && microseconds >= 0 && microseconds < 1000) {
    longMicro = Long$5.fromInt(microseconds);
  } else {
    if (_timestampTicks > 999) {
      _timestampTicks = 0;
    }

    longMicro = Long$5.fromInt(_timestampTicks);
    _timestampTicks++;
  }

  return Long$5.fromNumber(date.getTime()).multiply(_longOneThousand$1).add(longMicro);
} //error classes

/** @private */


function QueryParserError(e) {
  QueryParserError.super_.call(this, e.message, this.constructor);
  this.internalError = e;
}

util$C.inherits(QueryParserError, errors$o.DriverError);
/** @private */

function TimeoutError(message) {
  TimeoutError.super_.call(this, message, this.constructor);
  this.info = 'Represents an error that happens when the maximum amount of time for an operation passed.';
}

util$C.inherits(TimeoutError, errors$o.DriverError);
types$u.opcodes = opcodes;
types$u.consistencies = consistencies;
types$u.consistencyToString = consistencyToString;
types$u.dataTypes = dataTypes$5;
types$u.getDataTypeNameByCode = getDataTypeNameByCode;
types$u.distance = distance;
types$u.frameFlags = frameFlags;
types$u.protocolEvents = protocolEvents;
types$u.protocolVersion = protocolVersion;
types$u.responseErrorCodes = responseErrorCodes;
types$u.resultKind = resultKind;
types$u.timeuuid = timeuuid;
types$u.uuid = uuid;
types$u.BigDecimal = bigDecimal;
types$u.Duration = duration;
types$u.FrameHeader = FrameHeader$2;
types$u.InetAddress = inetAddress;
types$u.Integer = integer;
types$u.LocalDate = localDate;
types$u.LocalTime = localTime;
types$u.Long = Long$5;
types$u.ResultSet = resultSet$1;
types$u.ResultStream = resultStream;
types$u.Row = row; //export DriverError for backward-compatibility

types$u.DriverError = errors$o.DriverError;
types$u.TimeoutError = TimeoutError;
types$u.TimeUuid = TimeUuid;
types$u.Tuple = tuple;
types$u.Uuid = Uuid;
types$u.unset = unset;
types$u.generateTimestamp = generateTimestamp;

var util$B = require$$0__default$1["default"];
var types$t = types$u;
var utils$H = utils$V;
var errors$n = errors$s;
var doneIteratorObject = Object.freeze({
  done: true
});
var newlyUpInterval = 60000;
/** @module policies/loadBalancing */

/**
 * Base class for Load Balancing Policies
 * @constructor
 */

function LoadBalancingPolicy() {}
/**
 * Initializes the load balancing policy, called after the driver obtained the information of the cluster.
 * @param {Client} client
 * @param {HostMap} hosts
 * @param {Function} callback
 */


LoadBalancingPolicy.prototype.init = function (client, hosts, callback) {
  this.client = client;
  this.hosts = hosts;
  callback();
};
/**
 * Returns the distance assigned by this policy to the provided host.
 * @param {Host} host
 */


LoadBalancingPolicy.prototype.getDistance = function (host) {
  return types$t.distance.local;
};
/**
 * Returns an iterator with the hosts for a new query.
 * Each new query will call this method. The first host in the result will
 * then be used to perform the query.
 * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.
 * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.
 * @param {Function} callback The function to be invoked with the error as first parameter and the host iterator as
 * second parameter.
 */


LoadBalancingPolicy.prototype.newQueryPlan = function (keyspace, executionOptions, callback) {
  callback(new Error('You must implement a query plan for the LoadBalancingPolicy class'));
};
/**
 * Gets an associative array containing the policy options.
 */


LoadBalancingPolicy.prototype.getOptions = function () {
  return new Map();
};
/**
 * This policy yield nodes in a round-robin fashion.
 * @extends LoadBalancingPolicy
 * @constructor
 */


function RoundRobinPolicy() {
  this.index = 0;
}

util$B.inherits(RoundRobinPolicy, LoadBalancingPolicy);
/**
 * Returns an iterator with the hosts to be used as coordinator for a query.
 * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.
 * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.
 * @param {Function} callback The function to be invoked with the error as first parameter and the host iterator as
 * second parameter.
 */

RoundRobinPolicy.prototype.newQueryPlan = function (keyspace, executionOptions, callback) {
  if (!this.hosts) {
    return callback(new Error('Load balancing policy not initialized'));
  }

  var hosts = this.hosts.values();
  var self = this;
  var counter = 0;
  var planIndex = self.index % hosts.length;
  self.index += 1;

  if (self.index >= utils$H.maxInt) {
    self.index = 0;
  }

  callback(null, {
    next: function next() {
      if (++counter > hosts.length) {
        return doneIteratorObject;
      }

      return {
        value: hosts[planIndex++ % hosts.length],
        done: false
      };
    }
  });
};
/**
 * A data-center aware Round-robin load balancing policy.
 * This policy provides round-robin queries over the nodes of the local
 * data center.
 * @param {?String} [localDc] local datacenter name.  This value overrides the 'localDataCenter' Client option \
 * and is useful for cases where you have multiple execution profiles that you intend on using for routing
 * requests to different data centers.
 * @extends {LoadBalancingPolicy}
 * @constructor
 */


function DCAwareRoundRobinPolicy(localDc) {
  this.localDc = localDc;
  this.index = 0;
  /** @type {Array} */

  this.localHostsArray = null;
}

util$B.inherits(DCAwareRoundRobinPolicy, LoadBalancingPolicy);
/**
 * Initializes the load balancing policy.
 * @param {Client} client
 * @param {HostMap} hosts
 * @param {Function} callback
 */

DCAwareRoundRobinPolicy.prototype.init = function (client, hosts, callback) {
  this.client = client;
  this.hosts = hosts;
  hosts.on('add', this._cleanHostCache.bind(this));
  hosts.on('remove', this._cleanHostCache.bind(this));

  try {
    setLocalDc(this, client, this.hosts);
  } catch (err) {
    return callback(err);
  }

  callback();
};
/**
 * Returns the distance depending on the datacenter.
 * @param {Host} host
 */


DCAwareRoundRobinPolicy.prototype.getDistance = function (host) {
  if (host.datacenter === this.localDc) {
    return types$t.distance.local;
  }

  return types$t.distance.ignored;
};

DCAwareRoundRobinPolicy.prototype._cleanHostCache = function () {
  this.localHostsArray = null;
};

DCAwareRoundRobinPolicy.prototype._resolveLocalHosts = function () {
  var hosts = this.hosts.values();

  if (this.localHostsArray) {
    //there were already calculated
    return;
  }

  this.localHostsArray = [];
  hosts.forEach(function (h) {
    if (!h.datacenter) {
      //not a remote dc node
      return;
    }

    if (h.datacenter === this.localDc) {
      this.localHostsArray.push(h);
    }
  }, this);
};
/**
 * It returns an iterator that yields local nodes.
 * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.
 * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.
 * @param {Function} callback The function to be invoked with the error as first parameter and the host iterator as
 * second parameter.
 */


DCAwareRoundRobinPolicy.prototype.newQueryPlan = function (keyspace, executionOptions, callback) {
  if (!this.hosts) {
    return callback(new Error('Load balancing policy not initialized'));
  }

  this.index += 1;

  if (this.index >= utils$H.maxInt) {
    this.index = 0;
  }

  this._resolveLocalHosts(); // Use a local reference of hosts


  var localHostsArray = this.localHostsArray;
  var planLocalIndex = this.index;
  var counter = 0;
  callback(null, {
    next: function next() {
      var host;

      if (counter++ < localHostsArray.length) {
        host = localHostsArray[planLocalIndex++ % localHostsArray.length];
        return {
          value: host,
          done: false
        };
      }

      return doneIteratorObject;
    }
  });
};
/**
 * Gets an associative array containing the policy options.
 */


DCAwareRoundRobinPolicy.prototype.getOptions = function () {
  return new Map([['localDataCenter', this.localDc]]);
};
/**
 * A wrapper load balancing policy that add token awareness to a child policy.
 * @param {LoadBalancingPolicy} childPolicy
 * @extends LoadBalancingPolicy
 * @constructor
 */


function TokenAwarePolicy(childPolicy) {
  if (!childPolicy) {
    throw new Error("You must specify a child load balancing policy");
  }

  this.childPolicy = childPolicy;
}

util$B.inherits(TokenAwarePolicy, LoadBalancingPolicy);

TokenAwarePolicy.prototype.init = function (client, hosts, callback) {
  this.client = client;
  this.hosts = hosts;
  this.childPolicy.init(client, hosts, callback);
};

TokenAwarePolicy.prototype.getDistance = function (host) {
  return this.childPolicy.getDistance(host);
};
/**
 * Returns the hosts to use for a new query.
 * The returned plan will return local replicas first, if replicas can be determined, followed by the plan of the
 * child policy.
 * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.
 * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.
 * @param {Function} callback The function to be invoked with the error as first parameter and the host iterator as
 * second parameter.
 */


TokenAwarePolicy.prototype.newQueryPlan = function (keyspace, executionOptions, callback) {
  var routingKey;

  if (executionOptions) {
    routingKey = executionOptions.getRoutingKey();

    if (executionOptions.getKeyspace()) {
      keyspace = executionOptions.getKeyspace();
    }
  }

  var replicas;

  if (routingKey) {
    replicas = this.client.getReplicas(keyspace, routingKey);
  }

  if (!routingKey || !replicas) {
    return this.childPolicy.newQueryPlan(keyspace, executionOptions, callback);
  }

  var iterator = new TokenAwareIterator(keyspace, executionOptions, replicas, this.childPolicy);
  iterator.iterate(callback);
};
/**
 * An iterator that holds the context for the subsequent next() calls
 * @param {String} keyspace
 * @param {ExecutionOptions} execOptions
 * @param {Array} replicas
 * @param childPolicy
 * @constructor
 * @ignore
 */


function TokenAwareIterator(keyspace, execOptions, replicas, childPolicy) {
  this.keyspace = keyspace;
  this.childPolicy = childPolicy;
  this.options = execOptions;
  this.localReplicas = [];
  this.replicaIndex = 0;
  this.replicaMap = {};
  this.childIterator = null; // Memoize the local replicas
  // The amount of local replicas should be defined before start iterating, in order to select an
  // appropriate (pseudo random) startIndex

  for (var i = 0; i < replicas.length; i++) {
    var host = replicas[i];

    if (this.childPolicy.getDistance(host) !== types$t.distance.local) {
      continue;
    }

    this.replicaMap[host.address] = true;
    this.localReplicas.push(host);
  } // We use a PRNG to set the replica index
  // We only care about proportional fair scheduling between replicas of a given token
  // Math.random() has an extremely short permutation cycle length but we don't care about collisions


  this.startIndex = Math.floor(Math.random() * this.localReplicas.length);
}

TokenAwareIterator.prototype.iterate = function (callback) {
  //Load the child policy hosts
  var self = this;
  this.childPolicy.newQueryPlan(this.keyspace, this.options, function (err, iterator) {
    if (err) {
      return callback(err);
    } //get the iterator of the child policy in case is needed


    self.childIterator = iterator;
    callback(null, {
      next: function next() {
        return self.computeNext();
      }
    });
  });
};

TokenAwareIterator.prototype.computeNext = function () {
  var host;

  if (this.replicaIndex < this.localReplicas.length) {
    host = this.localReplicas[(this.startIndex + this.replicaIndex++) % this.localReplicas.length];
    return {
      value: host,
      done: false
    };
  } // Return hosts from child policy


  var item;

  while ((item = this.childIterator.next()) && !item.done) {
    if (this.replicaMap[item.value.address]) {
      // Avoid yielding local replicas from the child load balancing policy query plan
      continue;
    }

    return item;
  }

  return doneIteratorObject;
};
/**
 * Gets an associative array containing the policy options.
 */


TokenAwarePolicy.prototype.getOptions = function () {
  var map = new Map([['childPolicy', this.childPolicy.constructor !== undefined ? this.childPolicy.constructor.name : null]]);

  if (this.childPolicy instanceof DCAwareRoundRobinPolicy) {
    map.set('localDataCenter', this.childPolicy.localDc);
  }

  return map;
};
/**
 * Create a new policy that wraps the provided child policy but only "allow" hosts
 * from the provided list.
 * @class
 * @classdesc
 * A load balancing policy wrapper that ensure that only hosts from a provided
 * allow list will ever be returned.
 * <p>
 * This policy wraps another load balancing policy and will delegate the choice
 * of hosts to the wrapped policy with the exception that only hosts contained
 * in the allow list provided when constructing this policy will ever be
 * returned. Any host not in the while list will be considered ignored
 * and thus will not be connected to.
 * <p>
 * This policy can be useful to ensure that the driver only connects to a
 * predefined set of hosts. Keep in mind however that this policy defeats
 * somewhat the host auto-detection of the driver. As such, this policy is only
 * useful in a few special cases or for testing, but is not optimal in general.
 * If all you want to do is limiting connections to hosts of the local
 * data-center then you should use DCAwareRoundRobinPolicy and *not* this policy
 * in particular.
 * @param {LoadBalancingPolicy} childPolicy the wrapped policy.
 * @param {Array.<string>}  allowList The hosts address in the format ipAddress:port.
 * Only hosts from this list may get connected
 * to (whether they will get connected to or not depends on the child policy).
 * @extends LoadBalancingPolicy
 * @constructor
 */


function AllowListPolicy(childPolicy, allowList) {
  if (!childPolicy) {
    throw new Error("You must specify a child load balancing policy");
  }

  if (!Array.isArray(allowList)) {
    throw new Error("You must provide the list of allowed host addresses");
  }

  this.childPolicy = childPolicy;
  this.allowList = new Map(allowList.map(function (address) {
    return [address, true];
  }));
}

util$B.inherits(AllowListPolicy, LoadBalancingPolicy);

AllowListPolicy.prototype.init = function (client, hosts, callback) {
  this.childPolicy.init(client, hosts, callback);
};
/**
 * Uses the child policy to return the distance to the host if included in the allow list.
 * Any host not in the while list will be considered ignored.
 * @param host
 */


AllowListPolicy.prototype.getDistance = function (host) {
  if (!this._contains(host)) {
    return types$t.distance.ignored;
  }

  return this.childPolicy.getDistance(host);
};
/**
 * @param {Host} host
 * @returns {boolean}
 * @private
 */


AllowListPolicy.prototype._contains = function (host) {
  return !!this.allowList.get(host.address);
};
/**
 * Returns the hosts to use for a new query filtered by the allow list.
 */


AllowListPolicy.prototype.newQueryPlan = function (keyspace, info, callback) {
  var self = this;
  this.childPolicy.newQueryPlan(keyspace, info, function (err, iterator) {
    if (err) {
      return callback(err);
    }

    callback(null, self._filter(iterator));
  });
};

AllowListPolicy.prototype._filter = function (childIterator) {
  var self = this;
  return {
    next: function next() {
      var item = childIterator.next();

      if (!item.done && !self._contains(item.value)) {
        return this.next();
      }

      return item;
    }
  };
};
/**
 * Gets an associative array containing the policy options.
 */


AllowListPolicy.prototype.getOptions = function () {
  return new Map([['childPolicy', this.childPolicy.constructor !== undefined ? this.childPolicy.constructor.name : null], ['allowList', Array.from(this.allowList.keys())]]);
};
/**
 * Creates a new instance of the policy.
 * @classdesc
 * Exposed for backward-compatibility only, it's recommended that you use {@link AllowListPolicy} instead.
 * @param {LoadBalancingPolicy} childPolicy the wrapped policy.
 * @param {Array.<string>} allowList The hosts address in the format ipAddress:port.
 * Only hosts from this list may get connected to (whether they will get connected to or not depends on the child
 * policy).
 * @extends AllowListPolicy
 * @deprecated Use allow-list instead. It will be removed in future major versions.
 * @constructor
 */


function WhiteListPolicy(childPolicy, allowList) {
  AllowListPolicy.call(this, childPolicy, allowList);
}

util$B.inherits(WhiteListPolicy, AllowListPolicy);
/**
 * A load-balancing policy implementation that attempts to fairly distribute the load based on the amount of in-flight
 * request per hosts. The local replicas are initially shuffled and
 * <a href="https://www.eecs.harvard.edu/~michaelm/postscripts/mythesis.pdf">between the first two nodes in the
 * shuffled list, the one with fewer in-flight requests is selected as coordinator</a>.
 *
 * <p>
 *   Additionally, it detects unresponsive replicas and reorders them at the back of the query plan.
 * </p>
 *
 * <p>
 *   For graph analytics queries, it uses the preferred analytics graph server previously obtained by driver as first
 *   host in the query plan.
 * </p>
 */

var DefaultLoadBalancingPolicy = /*#__PURE__*/function (_LoadBalancingPolicy) {
  _inherits(DefaultLoadBalancingPolicy, _LoadBalancingPolicy);

  var _super = _createSuper(DefaultLoadBalancingPolicy);

  /**
   * Creates a new instance of <code>DefaultLoadBalancingPolicy</code>.
   * @param {String|Object} [options] The local data center name or the optional policy options object.
   * <p>
   *   Note that when providing the local data center name, it overrides <code>localDataCenter</code> option at
   *   <code>Client</code> level.
   * </p>
   * @param {String} [options.localDc] local data center name.  This value overrides the 'localDataCenter' Client option
   * and is useful for cases where you have multiple execution profiles that you intend on using for routing
   * requests to different data centers.
   * @param {Function} [options.filter] A function to apply to determine if hosts are included in the query plan.
   * The function takes a Host parameter and returns a Boolean.
   */
  function DefaultLoadBalancingPolicy(options) {
    var _this;

    _classCallCheck(this, DefaultLoadBalancingPolicy);

    _this = _super.call(this);

    if (typeof options === 'string') {
      options = {
        localDc: options
      };
    } else if (!options) {
      options = utils$H.emptyObject;
    }

    _this._client = null;
    _this._hosts = null;
    _this._filteredHosts = null;
    _this._preferredHost = null;
    _this._index = 0;
    _this.localDc = options.localDc;
    _this._filter = options.filter || _this._defaultFilter; // Allow some checks to be injected

    if (options.isHostNewlyUp) {
      _this._isHostNewlyUp = options.isHostNewlyUp;
    }

    if (options.healthCheck) {
      _this._healthCheck = options.healthCheck;
    }

    if (options.compare) {
      _this._compare = options.compare;
    }

    if (options.getReplicas) {
      _this._getReplicas = options.getReplicas;
    }

    return _this;
  }
  /**
   * Initializes the load balancing policy, called after the driver obtained the information of the cluster.
   * @param {Client} client
   * @param {HostMap} hosts
   * @param {Function} callback
   */


  _createClass(DefaultLoadBalancingPolicy, [{
    key: "init",
    value: function init(client, hosts, callback) {
      var _this2 = this;

      this._client = client;
      this._hosts = hosts; // Clean local host cache

      this._hosts.on('add', function () {
        return _this2._filteredHosts = null;
      });

      this._hosts.on('remove', function () {
        return _this2._filteredHosts = null;
      });

      try {
        setLocalDc(this, client, this._hosts);
      } catch (err) {
        return callback(err);
      }

      callback();
    }
    /**
     * Returns the distance assigned by this policy to the provided host, relatively to the client instance.
     * @param {Host} host
     */

  }, {
    key: "getDistance",
    value: function getDistance(host) {
      if (this._preferredHost !== null && host === this._preferredHost) {
        // Set the last preferred host as local.
        // It ensures that the pool for the graph analytics host has the appropriate size
        return types$t.distance.local;
      }

      if (!this._filter(host)) {
        return types$t.distance.ignored;
      }

      return host.datacenter === this.localDc ? types$t.distance.local : types$t.distance.ignored;
    }
    /**
     * Returns a host iterator to be used for a query execution.
     * @override
     * @param {String} keyspace
     * @param {ExecutionOptions} executionOptions
     * @param {Function} callback
     */

  }, {
    key: "newQueryPlan",
    value: function newQueryPlan(keyspace, executionOptions, callback) {
      var routingKey;
      var preferredHost;

      if (executionOptions) {
        routingKey = executionOptions.getRoutingKey();

        if (executionOptions.getKeyspace()) {
          keyspace = executionOptions.getKeyspace();
        }

        preferredHost = executionOptions.getPreferredHost();
      }

      var iterable;

      if (!keyspace || !routingKey) {
        iterable = this._getLocalHosts();
      } else {
        iterable = this._getReplicasAndLocalHosts(keyspace, routingKey);
      }

      if (preferredHost) {
        // Set it on an instance level field to set the distance
        this._preferredHost = preferredHost;
        iterable = DefaultLoadBalancingPolicy._getPreferredHostFirst(preferredHost, iterable);
      }

      return callback(null, iterable);
    }
    /**
     * Yields the preferred host first, followed by the host in the provided iterable
     * @param preferredHost
     * @param iterable
     * @private
     */

  }, {
    key: "_getLocalHosts",
    value:
    /*#__PURE__*/

    /**
     * Yields the local hosts without the replicas already yielded
     * @param {Array<Host>} [localReplicas] The local replicas that we should avoid to include again
     * @private
     */
    regeneratorRuntime.mark(function _getLocalHosts(localReplicas) {
      var hosts, initialIndex, canBeYield, i, h;
      return regeneratorRuntime.wrap(function _getLocalHosts$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // Use a local reference
              hosts = this._getFilteredLocalHosts();
              initialIndex = this._getIndex(); // indexOf() over an Array is a O(n) operation but given that there should be 3 to 7 replicas,
              // it shouldn't be an expensive call. Additionally, this will only be executed when the local replicas
              // have been exhausted in a lazy manner.

              canBeYield = localReplicas ? function (h) {
                return localReplicas.indexOf(h) === -1;
              } : function (h) {
                return true;
              };
              i = 0;

            case 4:
              if (!(i < hosts.length)) {
                _context.next = 12;
                break;
              }

              h = hosts[(i + initialIndex) % hosts.length];

              if (!(canBeYield(h) && h.isUp())) {
                _context.next = 9;
                break;
              }

              _context.next = 9;
              return h;

            case 9:
              i++;
              _context.next = 4;
              break;

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _getLocalHosts, this);
    })
  }, {
    key: "_getReplicasAndLocalHosts",
    value: function _getReplicasAndLocalHosts(keyspace, routingKey) {
      var replicas = this._getReplicas(keyspace, routingKey);

      if (replicas === null) {
        return this._getLocalHosts();
      }

      var filteredReplicas = [];
      var newlyUpReplica = null;
      var newlyUpReplicaTimestamp = Number.MIN_SAFE_INTEGER;
      var unhealthyReplicas = 0; // Filter by DC, predicate and UP replicas
      // Use the same iteration to perform other checks: whether if its newly UP or unhealthy
      // As this is part of the hot path, we use a simple loop and avoid using Array.prototype.filter() + closure

      for (var i = 0; i < replicas.length; i++) {
        var h = replicas[i];

        if (!this._filter(h) || h.datacenter !== this.localDc || !h.isUp()) {
          continue;
        }

        var isUpSince = this._isHostNewlyUp(h);

        if (isUpSince !== null && isUpSince > newlyUpReplicaTimestamp) {
          newlyUpReplica = h;
          newlyUpReplicaTimestamp = isUpSince;
        }

        if (newlyUpReplica === null && !this._healthCheck(h)) {
          unhealthyReplicas++;
        }

        filteredReplicas.push(h);
      }

      replicas = filteredReplicas; // Shuffle remaining local replicas

      utils$H.shuffleArray(replicas);

      if (replicas.length < 3) {
        // Avoid reordering replicas of a set of 2 as we could be doing more harm than good
        return this.yieldReplicasFirst(replicas);
      }

      var temp;

      if (newlyUpReplica === null) {
        if (unhealthyReplicas > 0 && unhealthyReplicas < Math.floor(replicas.length / 2 + 1)) {
          // There is one or more unhealthy replicas and there is a majority of healthy replicas
          this._sendUnhealthyToTheBack(replicas, unhealthyReplicas);
        }
      } else if ((newlyUpReplica === replicas[0] || newlyUpReplica === replicas[1]) && Math.random() * 4 >= 1) {
        // There is a newly UP replica and the replica in first or second position is the most recent replica
        // marked as UP and dice roll 1d4!=1 -> Send it to the back of the Array
        var index = newlyUpReplica === replicas[0] ? 0 : 1;
        temp = replicas[replicas.length - 1];
        replicas[replicas.length - 1] = replicas[index];
        replicas[index] = temp;
      }

      if (this._compare(replicas[1], replicas[0]) > 0) {
        // Power of two random choices
        temp = replicas[0];
        replicas[0] = replicas[1];
        replicas[1] = temp;
      }

      return this.yieldReplicasFirst(replicas);
    }
    /**
     * Yields the local replicas followed by the rest of local nodes.
     * @param {Array<Host>} replicas The local replicas
     */

  }, {
    key: "yieldReplicasFirst",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function yieldReplicasFirst(replicas) {
      var i;
      return regeneratorRuntime.wrap(function yieldReplicasFirst$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              i = 0;

            case 1:
              if (!(i < replicas.length)) {
                _context2.next = 7;
                break;
              }

              _context2.next = 4;
              return replicas[i];

            case 4:
              i++;
              _context2.next = 1;
              break;

            case 7:
              return _context2.delegateYield(this._getLocalHosts(replicas), "t0", 8);

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, yieldReplicasFirst, this);
    })
  }, {
    key: "_isHostNewlyUp",
    value: function _isHostNewlyUp(h) {
      return h.isUpSince !== null && Date.now() - h.isUpSince < newlyUpInterval ? h.isUpSince : null;
    }
    /**
     * Returns a boolean determining whether the host health is ok or not.
     * A Host is considered unhealthy when there are enough items in the queue (10 items in-flight) but the
     * Host is not responding to those requests.
     * @param {Host} h
     * @return {boolean}
     * @private
     */

  }, {
    key: "_healthCheck",
    value: function _healthCheck(h) {
      return !(h.getInFlight() >= 10 && h.getResponseCount() <= 1);
    }
    /**
     * Compares to host and returns 1 if it needs to favor the first host otherwise, -1.
     * @return {number}
     * @private
     */

  }, {
    key: "_compare",
    value: function _compare(h1, h2) {
      return h1.getInFlight() < h2.getInFlight() ? 1 : -1;
    }
  }, {
    key: "_getReplicas",
    value: function _getReplicas(keyspace, routingKey) {
      return this._client.getReplicas(keyspace, routingKey);
    }
    /**
     * Returns an Array of hosts filtered by DC and predicate.
     * @returns {Array<Host>}
     * @private
     */

  }, {
    key: "_getFilteredLocalHosts",
    value: function _getFilteredLocalHosts() {
      var _this3 = this;

      if (this._filteredHosts === null) {
        this._filteredHosts = this._hosts.values().filter(function (h) {
          return _this3._filter(h) && h.datacenter === _this3.localDc;
        });
      }

      return this._filteredHosts;
    }
  }, {
    key: "_getIndex",
    value: function _getIndex() {
      var result = this._index++; // Overflow protection

      if (this._index === 0x7fffffff) {
        this._index = 0;
      }

      return result;
    }
  }, {
    key: "_sendUnhealthyToTheBack",
    value: function _sendUnhealthyToTheBack(replicas, unhealthyReplicas) {
      var counter = 0; // Start from the back, move backwards and stop once all unhealthy replicas are at the back

      for (var i = replicas.length - 1; i >= 0 && counter < unhealthyReplicas; i--) {
        var host = replicas[i];

        if (this._healthCheck(host)) {
          continue;
        }

        var targetIndex = replicas.length - 1 - counter;

        if (targetIndex !== i) {
          var temp = replicas[targetIndex];
          replicas[targetIndex] = host;
          replicas[i] = temp;
        }

        counter++;
      }
    }
  }, {
    key: "_defaultFilter",
    value: function _defaultFilter() {
      return true;
    }
    /**
     * Gets an associative array containing the policy options.
     */

  }, {
    key: "getOptions",
    value: function getOptions() {
      return new Map([['localDataCenter', this.localDc], ['filterFunction', this._filter !== this._defaultFilter]]);
    }
  }], [{
    key: "_getPreferredHostFirst",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function _getPreferredHostFirst(preferredHost, iterable) {
      var _iterator, _step, host;

      return regeneratorRuntime.wrap(function _getPreferredHostFirst$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return preferredHost;

            case 2:
              _iterator = _createForOfIteratorHelper(iterable);
              _context3.prev = 3;

              _iterator.s();

            case 5:
              if ((_step = _iterator.n()).done) {
                _context3.next = 12;
                break;
              }

              host = _step.value;

              if (!(host !== preferredHost)) {
                _context3.next = 10;
                break;
              }

              _context3.next = 10;
              return host;

            case 10:
              _context3.next = 5;
              break;

            case 12:
              _context3.next = 17;
              break;

            case 14:
              _context3.prev = 14;
              _context3.t0 = _context3["catch"](3);

              _iterator.e(_context3.t0);

            case 17:
              _context3.prev = 17;

              _iterator.f();

              return _context3.finish(17);

            case 20:
            case "end":
              return _context3.stop();
          }
        }
      }, _getPreferredHostFirst, null, [[3, 14, 17, 20]]);
    })
  }]);

  return DefaultLoadBalancingPolicy;
}(LoadBalancingPolicy);
/**
 * Validates and sets the local data center to be used.
 * @param {LoadBalancingPolicy} lbp
 * @param {Client} client
 * @param {HostMap} hosts
 * @private
 */


function setLocalDc(lbp, client, hosts) {
  if (!(lbp instanceof LoadBalancingPolicy)) {
    throw new errors$n.DriverInternalError('LoadBalancingPolicy instance was not provided');
  }

  if (client && client.options) {
    if (lbp.localDc && !client.options.localDataCenter) {
      client.log('info', "Local data center '".concat(lbp.localDc, "' was provided as an argument to the load-balancing") + " policy. It is preferable to specify the local data center using 'localDataCenter' in Client" + " options instead when your application is targeting a single data center.");
    } // If localDc is unset, use value set in client options.


    lbp.localDc = lbp.localDc || client.options.localDataCenter;
  }

  var dcs = getDataCenters(hosts);

  if (!lbp.localDc) {
    throw new errors$n.ArgumentError("'localDataCenter' is not defined in Client options and also was not specified in constructor." + " At least one is required. Available DCs are: [".concat(Array.from(dcs), "]"));
  }

  if (!dcs.has(lbp.localDc)) {
    throw new errors$n.ArgumentError("Datacenter ".concat(lbp.localDc, " was not found. Available DCs are: [").concat(Array.from(dcs), "]"));
  }
}

function getDataCenters(hosts) {
  return new Set(hosts.values().map(function (h) {
    return h.datacenter;
  }));
}

var loadBalancing$1 = {
  AllowListPolicy: AllowListPolicy,
  DCAwareRoundRobinPolicy: DCAwareRoundRobinPolicy,
  DefaultLoadBalancingPolicy: DefaultLoadBalancingPolicy,
  LoadBalancingPolicy: LoadBalancingPolicy,
  RoundRobinPolicy: RoundRobinPolicy,
  TokenAwarePolicy: TokenAwarePolicy,
  // Deprecated: for backward compatibility only.
  WhiteListPolicy: WhiteListPolicy
};

var reconnection$1 = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$A = require$$0__default$1["default"];
/** @module policies/reconnection */

/**
 * Base class for Reconnection Policies
 * @constructor
 */

function ReconnectionPolicy() {}
/**
 * A new reconnection schedule.
 * @returns {{next: function}} An infinite iterator
 */


ReconnectionPolicy.prototype.newSchedule = function () {
  throw new Error('You must implement a new schedule for the Reconnection class');
};
/**
 * Gets an associative array containing the policy options.
 */


ReconnectionPolicy.prototype.getOptions = function () {
  return new Map();
};
/**
 * A reconnection policy that waits a constant time between each reconnection attempt.
 * @param {Number} delay Delay in ms
 * @constructor
 */


function ConstantReconnectionPolicy(delay) {
  this.delay = delay;
}

util$A.inherits(ConstantReconnectionPolicy, ReconnectionPolicy);
/**
 * A new reconnection schedule that returns the same next delay value
 * @returns {{next: Function}} An infinite iterator
 */

ConstantReconnectionPolicy.prototype.newSchedule = function () {
  var self = this;
  return {
    next: function next() {
      return {
        value: self.delay,
        done: false
      };
    }
  };
};
/**
 * Gets an associative array containing the policy options.
 */


ConstantReconnectionPolicy.prototype.getOptions = function () {
  return new Map([['delay', this.delay]]);
};
/**
 * A reconnection policy that waits exponentially longer between each
 * reconnection attempt (but keeps a constant delay once a maximum delay is reached).
 * <p>
 *   A random amount of jitter (+/- 15%) will be added to the pure exponential delay value to avoid situations
 *   where many clients are in the reconnection process at exactly the same time. The jitter will never cause the
 *   delay to be less than the base delay, or more than the max delay.
 * </p>
 * @param {Number} baseDelay The base delay in milliseconds to use for the schedules created by this policy.
 * @param {Number} maxDelay The maximum delay in milliseconds to wait between two reconnection attempt.
 * @param {Boolean} startWithNoDelay Determines if the first attempt should be zero delay
 * @constructor
 */


function ExponentialReconnectionPolicy(baseDelay, maxDelay, startWithNoDelay) {
  this.baseDelay = baseDelay;
  this.maxDelay = maxDelay;
  this.startWithNoDelay = startWithNoDelay;
}

util$A.inherits(ExponentialReconnectionPolicy, ReconnectionPolicy);
/**
 * A new schedule that uses an exponentially growing delay between reconnection attempts.
 * @returns {{next: Function}} An infinite iterator.
 */

ExponentialReconnectionPolicy.prototype.newSchedule = /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
  var index, delay;
  return regeneratorRuntime.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          index = this.startWithNoDelay ? -1 : 0;

        case 1:

          delay = 0;

          if (index >= 64) {
            delay = this.maxDelay;
          } else if (index !== -1) {
            delay = Math.min(Math.pow(2, index) * this.baseDelay, this.maxDelay);
          }

          index++;
          _context.next = 7;
          return this._addJitter(delay);

        case 7:
          _context.next = 1;
          break;

        case 9:
        case "end":
          return _context.stop();
      }
    }
  }, _callee, this);
});
/**
 * Adds a random portion of +-15% to the delay provided.
 * Initially, its adds a random value of 15% to avoid reconnection before reaching the base delay.
 * When the schedule reaches max delay, only subtracts a random portion of 15%.
 */

ExponentialReconnectionPolicy.prototype._addJitter = function (value) {
  if (value === 0) {
    // Instant reconnection without jitter
    return value;
  } // Use the formula: 85% + rnd() * 30% to calculate the percentage of the original delay


  var minPercentage = 0.85;
  var range = 0.30;

  if (!this.startWithNoDelay && value === this.baseDelay) {
    // Between 100% to 115% of the original value
    minPercentage = 1;
    range = 0.15;
  } else if (value === this.maxDelay) {
    // Between 85% to 100% of the original value
    range = 0.15;
  }

  return Math.floor(value * (Math.random() * range + minPercentage));
};
/**
 * Gets an associative array containing the policy options.
 */


ExponentialReconnectionPolicy.prototype.getOptions = function () {
  return new Map([['baseDelay', this.baseDelay], ['maxDelay', this.maxDelay], ['startWithNoDelay', this.startWithNoDelay]]);
};

reconnection$1.ReconnectionPolicy = ReconnectionPolicy;
reconnection$1.ConstantReconnectionPolicy = ConstantReconnectionPolicy;
reconnection$1.ExponentialReconnectionPolicy = ExponentialReconnectionPolicy;

var retry$2 = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$z = require$$0__default$1["default"];
/** @module policies/retry */

/**
 * Base and default RetryPolicy.
 * Determines what to do when the drivers runs into an specific Cassandra exception
 * @constructor
 */

function RetryPolicy() {}
/**
 * Determines what to do when the driver gets an UnavailableException response from a Cassandra node.
 * @param {OperationInfo} info
 * @param {Number} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered
 * the exception.
 * @param {Number} required The number of replicas whose response is required to achieve the
 * required [consistency]{@link module:types~consistencies}.
 * @param {Number} alive The number of replicas that were known to be alive when the request had been processed
 * (since an unavailable exception has been triggered, there will be alive &lt; required)
 * @returns {DecisionInfo}
 */


RetryPolicy.prototype.onUnavailable = function (info, consistency, required, alive) {
  if (info.nbRetry > 0) {
    return this.rethrowResult();
  }

  return this.retryResult(undefined, false);
};
/**
 * Determines what to do when the driver gets a ReadTimeoutException response from a Cassandra node.
 * @param {OperationInfo} info
 * @param {Number} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered
 * the exception.
 * @param {Number} received The number of nodes having answered the request.
 * @param {Number} blockFor The number of replicas whose response is required to achieve the
 * required [consistency]{@link module:types~consistencies}.
 * @param {Boolean} isDataPresent When <code>false</code>, it means the replica that was asked for data has not responded.
 * @returns {DecisionInfo}
 */


RetryPolicy.prototype.onReadTimeout = function (info, consistency, received, blockFor, isDataPresent) {
  if (info.nbRetry > 0) {
    return this.rethrowResult();
  }

  return received >= blockFor && !isDataPresent ? this.retryResult() : this.rethrowResult();
};
/**
 * Determines what to do when the driver gets a WriteTimeoutException response from a Cassandra node.
 * @param {OperationInfo} info
 * @param {Number} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered
 * the exception.
 * @param {Number} received The number of nodes having acknowledged the request.
 * @param {Number} blockFor The number of replicas whose acknowledgement is required to achieve the required
 * [consistency]{@link module:types~consistencies}.
 * @param {String} writeType A <code>string</code> that describes the type of the write that timed out ("SIMPLE"
 * / "BATCH" / "BATCH_LOG" / "UNLOGGED_BATCH" / "COUNTER").
 * @returns {DecisionInfo}
 */


RetryPolicy.prototype.onWriteTimeout = function (info, consistency, received, blockFor, writeType) {
  if (info.nbRetry > 0) {
    return this.rethrowResult();
  } // If the batch log write failed, retry the operation as this might just be we were unlucky at picking candidates


  return writeType === "BATCH_LOG" ? this.retryResult() : this.rethrowResult();
};
/**
 * Defines whether to retry and at which consistency level on an unexpected error.
 * <p>
 * This method might be invoked in the following situations:
 * </p>
 * <ol>
 * <li>On a client timeout, while waiting for the server response
 * (see [socketOptions.readTimeout]{@link ClientOptions}), being the error an instance of
 * [OperationTimedOutError]{@link module:errors~OperationTimedOutError}.</li>
 * <li>On a connection error (socket closed, etc.).</li>
 * <li>When the contacted host replies with an error, such as <code>overloaded</code>, <code>isBootstrapping</code>,
 * </code>serverError, etc. In this case, the error is instance of [ResponseError]{@link module:errors~ResponseError}.
 * </li>
 * </ol>
 * <p>
 * Note that when this method is invoked, <em>the driver cannot guarantee that the mutation has been effectively
 * applied server-side</em>; a retry should only be attempted if the request is known to be idempotent.
 * </p>
 * @param {OperationInfo} info
 * @param {Number|undefined} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered
 * the exception.
 * @param {Error} err The error that caused this request to fail.
 * @returns {DecisionInfo}
 */


RetryPolicy.prototype.onRequestError = function (info, consistency, err) {
  // The default implementation triggers a retry on the next host in the query plan with the same consistency level,
  // regardless of the statement's idempotence, for historical reasons.
  return this.retryResult(undefined, false);
};
/**
 * Returns a {@link DecisionInfo} to retry the request with the given [consistency]{@link module:types~consistencies}.
 * @param {Number|undefined} [consistency] When specified, it retries the request with the given consistency.
 * @param {Boolean} [useCurrentHost] When specified, determines if the retry should be made using the same coordinator.
 * Default: true.
 * @returns {DecisionInfo}
 */


RetryPolicy.prototype.retryResult = function (consistency, useCurrentHost) {
  return {
    decision: RetryPolicy.retryDecision.retry,
    consistency: consistency,
    useCurrentHost: useCurrentHost !== false
  };
};
/**
 * Returns a {@link DecisionInfo} to callback in error when a err is obtained for a given request.
 * @returns {DecisionInfo}
 */


RetryPolicy.prototype.rethrowResult = function () {
  return {
    decision: RetryPolicy.retryDecision.rethrow
  };
};
/**
 * Determines the retry decision for the retry policies.
 * @type {Object}
 * @property {Number} rethrow
 * @property {Number} retry
 * @property {Number} ignore
 * @static
 */


RetryPolicy.retryDecision = {
  rethrow: 0,
  retry: 1,
  ignore: 2
};
/**
 * Creates a new instance of <code>IdempotenceAwareRetryPolicy</code>.
 * @classdesc
 * A retry policy that avoids retrying non-idempotent statements.
 * <p>
 * In case of write timeouts or unexpected errors, this policy will always return
 * [rethrowResult()]{@link module:policies/retry~RetryPolicy#rethrowResult} if the statement is deemed non-idempotent
 * (see [QueryOptions.isIdempotent]{@link QueryOptions}).
 * <p/>
 * For all other cases, this policy delegates the decision to the child policy.
 * @param {RetryPolicy} [childPolicy] The child retry policy to wrap. When not defined, it will use an instance of
 * [RetryPolicy]{@link module:policies/retry~RetryPolicy} as child policy.
 * @extends module:policies/retry~RetryPolicy
 * @constructor
 * @deprecated Since version 4.0 non-idempotent operations are never tried for write timeout or request error, use the
 * default retry policy instead.
 */

function IdempotenceAwareRetryPolicy(childPolicy) {
  this._childPolicy = childPolicy || new RetryPolicy();
}

util$z.inherits(IdempotenceAwareRetryPolicy, RetryPolicy);

IdempotenceAwareRetryPolicy.prototype.onReadTimeout = function (info, consistency, received, blockFor, isDataPresent) {
  return this._childPolicy.onReadTimeout(info, consistency, received, blockFor, isDataPresent);
};
/**
 * If the query is not idempotent, it returns a rethrow decision. Otherwise, it relies on the child policy to decide.
 */


IdempotenceAwareRetryPolicy.prototype.onRequestError = function (info, consistency, err) {
  if (info.executionOptions.isIdempotent()) {
    return this._childPolicy.onRequestError(info, consistency, err);
  }

  return this.rethrowResult();
};

IdempotenceAwareRetryPolicy.prototype.onUnavailable = function (info, consistency, required, alive) {
  return this._childPolicy.onUnavailable(info, consistency, required, alive);
};
/**
 * If the query is not idempotent, it return a rethrow decision. Otherwise, it relies on the child policy to decide.
 */


IdempotenceAwareRetryPolicy.prototype.onWriteTimeout = function (info, consistency, received, blockFor, writeType) {
  if (info.executionOptions.isIdempotent()) {
    return this._childPolicy.onWriteTimeout(info, consistency, received, blockFor, writeType);
  }

  return this.rethrowResult();
};
/**
 * Creates a new instance of FallthroughRetryPolicy.
 * @classdesc
 * A retry policy that never retries nor ignores.
 * <p>
 * All of the methods of this retry policy unconditionally return
 * [rethrow]{@link module:policies/retry~Retry#rethrowResult()}. If this policy is used, retry logic will have to be
 * implemented in business code.
 * </p>
 * @alias module:policies/retry~FallthroughRetryPolicy
 * @extends RetryPolicy
 * @constructor
 */


function FallthroughRetryPolicy() {}

util$z.inherits(FallthroughRetryPolicy, RetryPolicy);
/**
 * Implementation of RetryPolicy method that returns [rethrow]{@link module:policies/retry~Retry#rethrowResult()}.
 */

FallthroughRetryPolicy.prototype.onReadTimeout = function () {
  return this.rethrowResult();
};
/**
 * Implementation of RetryPolicy method that returns [rethrow]{@link module:policies/retry~Retry#rethrowResult()}.
 */


FallthroughRetryPolicy.prototype.onRequestError = function () {
  return this.rethrowResult();
};
/**
 * Implementation of RetryPolicy method that returns [rethrow]{@link module:policies/retry~Retry#rethrowResult()}.
 */


FallthroughRetryPolicy.prototype.onUnavailable = function () {
  return this.rethrowResult();
};
/**
 * Implementation of RetryPolicy method that returns [rethrow]{@link module:policies/retry~Retry#rethrowResult()}.
 */


FallthroughRetryPolicy.prototype.onWriteTimeout = function () {
  return this.rethrowResult();
};
/**
 * Decision information
 * @typedef {Object} DecisionInfo
 * @property {Number} decision The decision as specified in
 * [retryDecision]{@link module:policies/retry~RetryPolicy.retryDecision}.
 * @property {Number} [consistency] The [consistency level]{@link module:types~consistencies}.
 * @property {useCurrentHost} [useCurrentHost] Determines if it should use the same host to retry the request.
 * <p>
 *   In the case that the current host is not available anymore, it will be retried on the next host even when
 *   <code>useCurrentHost</code> is set to <code>true</code>.
 * </p>
 */

/**
 * Information of the execution to be used to determine whether the operation should be retried.
 * @typedef {Object} OperationInfo
 * @property {String} query The query that was executed.
 * @param {ExecutionOptions} executionOptions The options related to the execution of the request.
 * @property {Number} nbRetry The number of retries already performed for this operation.
 */


retry$2.IdempotenceAwareRetryPolicy = IdempotenceAwareRetryPolicy;
retry$2.FallthroughRetryPolicy = FallthroughRetryPolicy;
retry$2.RetryPolicy = RetryPolicy;

var speculativeExecution$1 = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$y = require$$0__default$1["default"];
var errors$m = errors$s;
/** @module policies/speculativeExecution */

/**
 * @classdesc
 * The policy that decides if the driver will send speculative queries to the next hosts when the current host takes too
 * long to respond.
 * <p>Note that only idempotent statements will be speculatively retried.</p>
 * @constructor
 * @abstract
 */

function SpeculativeExecutionPolicy() {}
/**
 * Initialization method that gets invoked on Client startup.
 * @param {Client} client
 * @abstract
 */


SpeculativeExecutionPolicy.prototype.init = function (client) {};
/**
 * Gets invoked at client shutdown, giving the opportunity to the implementor to perform cleanup.
 * @abstract
 */


SpeculativeExecutionPolicy.prototype.shutdown = function () {};
/**
 * Gets the plan to use for a new query.
 * Returns an object with a <code>nextExecution()</code> method, which returns a positive number representing the
 * amount of milliseconds to delay the next execution or a non-negative number to avoid further executions.
 * @param {String} keyspace The currently logged keyspace.
 * @param {String|Array<String>} queryInfo The query, or queries in the case of batches, for which to build a plan.
 * @return {{nextExecution: function}}
 * @abstract
 */


SpeculativeExecutionPolicy.prototype.newPlan = function (keyspace, queryInfo) {
  throw new Error('You must implement newPlan() method in the SpeculativeExecutionPolicy');
};
/**
 * Gets an associative array containing the policy options.
 */


SpeculativeExecutionPolicy.prototype.getOptions = function () {
  return new Map();
};
/**
 * Creates a new instance of NoSpeculativeExecutionPolicy.
 * @classdesc
 * A {@link SpeculativeExecutionPolicy} that never schedules speculative executions.
 * @constructor
 * @extends {SpeculativeExecutionPolicy}
 */


function NoSpeculativeExecutionPolicy() {
  this._plan = {
    nextExecution: function nextExecution() {
      return -1;
    }
  };
}

util$y.inherits(NoSpeculativeExecutionPolicy, SpeculativeExecutionPolicy);

NoSpeculativeExecutionPolicy.prototype.newPlan = function () {
  return this._plan;
};
/**
 * Creates a new instance of ConstantSpeculativeExecutionPolicy.
 * @classdesc
 * A {@link SpeculativeExecutionPolicy} that schedules a given number of speculative executions,
 * separated by a fixed delay.
 * @constructor
 * @param {Number} delay The delay between each speculative execution.
 * @param {Number} maxSpeculativeExecutions The amount of speculative executions that should be scheduled after the
 * initial execution. Must be strictly positive.
 * @extends {SpeculativeExecutionPolicy}
 */


function ConstantSpeculativeExecutionPolicy(delay, maxSpeculativeExecutions) {
  if (!(delay >= 0)) {
    throw new errors$m.ArgumentError('delay must be a positive number or zero');
  }

  if (!(maxSpeculativeExecutions > 0)) {
    throw new errors$m.ArgumentError('maxSpeculativeExecutions must be a positive number');
  }

  this._delay = delay;
  this._maxSpeculativeExecutions = maxSpeculativeExecutions;
}

util$y.inherits(ConstantSpeculativeExecutionPolicy, SpeculativeExecutionPolicy);

ConstantSpeculativeExecutionPolicy.prototype.newPlan = function () {
  var executions = 0;
  var self = this;
  return {
    nextExecution: function nextExecution() {
      if (executions++ < self._maxSpeculativeExecutions) {
        return self._delay;
      }

      return -1;
    }
  };
};
/**
 * Gets an associative array containing the policy options.
 */


ConstantSpeculativeExecutionPolicy.prototype.getOptions = function () {
  return new Map([['delay', this._delay], ['maxSpeculativeExecutions', this._maxSpeculativeExecutions]]);
};

speculativeExecution$1.NoSpeculativeExecutionPolicy = NoSpeculativeExecutionPolicy;
speculativeExecution$1.SpeculativeExecutionPolicy = SpeculativeExecutionPolicy;
speculativeExecution$1.ConstantSpeculativeExecutionPolicy = ConstantSpeculativeExecutionPolicy;

var timestampGeneration$1 = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$x = require$$0__default$1["default"];
var Long$4 = types$u.Long;
var errors$l = errors$s;
/** @module policies/timestampGeneration */

/**
 * Defines the maximum date in milliseconds that can be represented in microseconds using Number ((2 ^ 53) / 1000)
 * @const
 * @private
 */

var _maxSafeNumberDate = 9007199254740;
/**
 * A long representing the value 1000
 * @const
 * @private
 */

var _longOneThousand = Long$4.fromInt(1000);
/**
 * Creates a new instance of {@link TimestampGenerator}.
 * @classdesc
 * Generates client-side, microsecond-precision query timestamps.
 * <p>
 *   Given that Cassandra uses those timestamps to resolve conflicts, implementations should generate
 *   monotonically increasing timestamps for successive invocations of {@link TimestampGenerator.next()}.
 * </p>
 * @constructor
 */


function TimestampGenerator() {}
/**
 * Returns the next timestamp.
 * <p>
 *   Implementors should enforce increasing monotonicity of timestamps, that is,
 *   a timestamp returned should always be strictly greater that any previously returned
 *   timestamp.
 * <p/>
 * <p>
 *   Implementors should strive to achieve microsecond precision in the best possible way,
 *   which is usually largely dependent on the underlying operating system's capabilities.
 * </p>
 * @param {Client} client The {@link Client} instance to generate timestamps to.
 * @returns {Long|Number|null} the next timestamp (in microseconds). If it's equals to <code>null</code>, it won't be
 * sent by the driver, letting the server to generate the timestamp.
 * @abstract
 */


TimestampGenerator.prototype.next = function (client) {
  throw new Error('next() must be implemented');
};
/**
 * A timestamp generator that guarantees monotonically increasing timestamps and logs warnings when timestamps
 * drift in the future.
 * <p>
 *   {@link Date} has millisecond precision and client timestamps require microsecond precision. This generator
 *   keeps track of the last generated timestamp, and if the current time is within the same millisecond as the last,
 *   it fills the microsecond portion of the new timestamp with the value of an incrementing counter.
 * </p>
 * @param {Number} [warningThreshold] Determines how far in the future timestamps are allowed to drift before a
 * warning is logged, expressed in milliseconds. Default: <code>1000</code>.
 * @param {Number} [minLogInterval] In case of multiple log events, it determines the time separation between log
 * events, expressed in milliseconds. Use 0 to disable. Default: <code>1000</code>.
 * @extends {TimestampGenerator}
 * @constructor
 */


function MonotonicTimestampGenerator(warningThreshold, minLogInterval) {
  if (warningThreshold < 0) {
    throw new errors$l.ArgumentError('warningThreshold can not be lower than 0');
  }

  this._warningThreshold = warningThreshold || 1000;
  this._minLogInterval = 1000;

  if (typeof minLogInterval === 'number') {
    // A value under 1 will disable logging
    this._minLogInterval = minLogInterval;
  }

  this._micros = -1;
  this._lastDate = 0;
  this._lastLogDate = 0;
}

util$x.inherits(MonotonicTimestampGenerator, TimestampGenerator);
/**
 * Returns the current time in milliseconds since UNIX epoch
 * @returns {Number}
 */

MonotonicTimestampGenerator.prototype.getDate = function () {
  return Date.now();
};

MonotonicTimestampGenerator.prototype.next = function (client) {
  var date = this.getDate();
  var drifted = 0;

  if (date > this._lastDate) {
    this._micros = 0;
    this._lastDate = date;
    return this._generateMicroseconds();
  }

  if (date < this._lastDate) {
    drifted = this._lastDate - date;
    date = this._lastDate;
  }

  if (++this._micros === 1000) {
    this._micros = 0;

    if (date === this._lastDate) {
      // Move date 1 millisecond into the future
      date++;
      drifted++;
    }
  }

  var lastDate = this._lastDate;
  this._lastDate = date;

  var result = this._generateMicroseconds();

  if (drifted >= this._warningThreshold) {
    // Avoid logging an unbounded amount of times within a clock-skew event or during an interval when more than 1
    // query is being issued by microsecond
    var currentLogDate = Date.now();

    if (this._minLogInterval > 0 && this._lastLogDate + this._minLogInterval <= currentLogDate) {
      var message = util$x.format('Timestamp generated using current date was %d milliseconds behind the last generated timestamp (which ' + 'millisecond portion was %d), the returned value (%s) is being artificially incremented to guarantee ' + 'monotonicity.', drifted, lastDate, result);
      this._lastLogDate = currentLogDate;
      client.log('warning', message);
    }
  }

  return result;
};
/**
 * @private
 * @returns {Number|Long}
 */


MonotonicTimestampGenerator.prototype._generateMicroseconds = function () {
  if (this._lastDate < _maxSafeNumberDate) {
    // We are safe until Jun 06 2255, its faster to perform this operations on Number than on Long
    // We hope to have native int64 by then :)
    return this._lastDate * 1000 + this._micros;
  }

  return Long$4.fromNumber(this._lastDate).multiply(_longOneThousand).add(Long$4.fromInt(this._micros));
};

timestampGeneration$1.TimestampGenerator = TimestampGenerator;
timestampGeneration$1.MonotonicTimestampGenerator = MonotonicTimestampGenerator;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Contains driver tuning policies to determine [load balancing]{@link module:policies/loadBalancing},
 *  [retrying]{@link module:policies/retry} queries, [reconnecting]{@link module:policies/reconnection} to a node,
 *  [address resolution]{@link module:policies/addressResolution},
 *  [timestamp generation]{@link module:policies/timestampGeneration} and
 *  [speculative execution]{@link module:policies/speculativeExecution}.
 * @module policies
 */


var addressResolution = policies$2.addressResolution = addressResolution$1;
var loadBalancing = policies$2.loadBalancing = loadBalancing$1;
var reconnection = policies$2.reconnection = reconnection$1;
var retry$1 = policies$2.retry = retry$2;
var speculativeExecution = policies$2.speculativeExecution = speculativeExecution$1;
var timestampGeneration = policies$2.timestampGeneration = timestampGeneration$1;
/**
 * Returns a new instance of the default address translator policy used by the driver.
 * @returns {AddressTranslator}
 */

policies$2.defaultAddressTranslator = function () {
  return new addressResolution.AddressTranslator();
};
/**
 * Returns a new instance of the default load-balancing policy used by the driver.
 * @param {string} [localDc] When provided, it sets the data center that is going to be used as local for the
 * load-balancing policy instance.
 * <p>When localDc is undefined, the load-balancing policy instance will use the <code>localDataCenter</code>
 * provided in the {@link ClientOptions}.</p>
 * @returns {LoadBalancingPolicy}
 */


policies$2.defaultLoadBalancingPolicy = function (localDc) {
  return new loadBalancing.DefaultLoadBalancingPolicy(localDc);
};
/**
 * Returns a new instance of the default retry policy used by the driver.
 * @returns {RetryPolicy}
 */


policies$2.defaultRetryPolicy = function () {
  return new retry$1.RetryPolicy();
};
/**
 * Returns a new instance of the default reconnection policy used by the driver.
 * @returns {ReconnectionPolicy}
 */


policies$2.defaultReconnectionPolicy = function () {
  return new reconnection.ExponentialReconnectionPolicy(1000, 10 * 60 * 1000, false);
};
/**
 * Returns a new instance of the default speculative execution policy used by the driver.
 * @returns {SpeculativeExecutionPolicy}
 */


policies$2.defaultSpeculativeExecutionPolicy = function () {
  return new speculativeExecution.NoSpeculativeExecutionPolicy();
};
/**
 * Returns a new instance of the default timestamp generator used by the driver.
 * @returns {TimestampGenerator}
 */


policies$2.defaultTimestampGenerator = function () {
  return new timestampGeneration.MonotonicTimestampGenerator();
};

var tracker$1 = {};

/**
 * Tracks request execution for a {@link Client}.
 * <p>
 *   A {@link RequestTracker} can be configured in the client options. The <code>Client</code> will execute
 *   {@link RequestTracker#onSuccess} or {@link RequestTracker#onError} for every query or batch
 *   executed (QUERY, EXECUTE and BATCH requests).
 * </p>
 * @interface
 * @alias module:tracker~RequestTracker
 */


var RequestTracker$1 = /*#__PURE__*/function () {
  function RequestTracker() {
    _classCallCheck(this, RequestTracker);
  }

  _createClass(RequestTracker, [{
    key: "onSuccess",
    value:
    /**
     * Invoked each time a query or batch request succeeds.
     * @param {Host} host The node that acted as coordinator of the request.
     * @param {String|Array} query In the case of prepared or unprepared query executions, the provided
     * query string. For batch requests, an Array containing the queries and parameters provided.
     * @param {Array|Object|null} parameters In the case of prepared or unprepared query executions, the provided
     * parameters.
     * @param {ExecutionOptions} executionOptions The information related to the execution of the request.
     * @param {Number} requestLength Length of the body of the request.
     * @param {Number} responseLength Length of the body of the response.
     * @param {Array<Number>} latency An array containing [seconds, nanoseconds] tuple, where nanoseconds is the
     * remaining part of the real time that can't be represented in second precision (see <code>process.hrtime()</code>).
     */
    function onSuccess(host, query, parameters, executionOptions, requestLength, responseLength, latency) {}
    /**
     * Invoked each time a query or batch request fails.
     * @param {Host} host The node that acted as coordinator of the request.
     * @param {String|Array} query In the case of prepared or unprepared query executions, the provided
     * query string. For batch requests, an Array containing the queries and parameters provided.
     * @param {Array|Object|null} parameters In the case of prepared or unprepared query executions, the provided
     * parameters.
     * @param {ExecutionOptions} executionOptions The information related to the execution of the request.
     * @param {Number} requestLength Length of the body of the request. When the failure occurred before the request was
     * written to the wire, the length will be <code>0</code>.
     * @param {Error} err The error that caused that caused the request to fail.
     * @param {Array<Number>} latency An array containing [seconds, nanoseconds] tuple, where nanoseconds is the
     * remaining part of the real time that can't be represented in second precision (see <code>process.hrtime()</code>).
     */

  }, {
    key: "onError",
    value: function onError(host, query, parameters, executionOptions, requestLength, err, latency) {}
    /**
     * Invoked when the Client is being shutdown.
     */

  }, {
    key: "shutdown",
    value: function shutdown() {}
  }]);

  return RequestTracker;
}();

var requestTracker = RequestTracker$1;

var events$9 = require$$0__default$2["default"];
var RequestTracker = requestTracker;
var errors$k = errors$s;
var format$1 = require$$0__default$1["default"].format;
var nanosToMillis = 1000000;
var defaultMessageMaxQueryLength = 500;
var defaultMaxParameterValueLength = 50;
var defaultMaxErrorStackTraceLength = 200;
/**
 * A request tracker that logs the requests executed through the session, according to a set of
 * configurable options.
 * @implements {module:tracker~RequestTracker}
 * @alias module:tracker~RequestLogger
 * @example <caption>Logging slow queries</caption>
 * const requestLogger = new RequestLogger({ slowThreshold: 1000 });
 * requestLogger.emitter.on('show', message => console.log(message));
 * // Add the requestLogger to the client options
 * const client = new Client({ contactPoints, requestTracker: requestLogger });
 */

var RequestLogger = /*#__PURE__*/function (_RequestTracker) {
  _inherits(RequestLogger, _RequestTracker);

  var _super = _createSuper(RequestLogger);

  /**
   * Creates a new instance of {@link RequestLogger}.
   * @param {Object} options
   * @param {Number} [options.slowThreshold] The threshold in milliseconds beyond which queries are considered 'slow'
   * and logged as such by the driver.
   * @param {Number} [options.requestSizeThreshold] The threshold in bytes beyond which requests are considered 'large'
   * and logged as such by the driver.
   * @param {Boolean} [options.logNormalRequests] Determines whether it should emit 'normal' events for every
   * EXECUTE, QUERY and BATCH request executed successfully, useful only for debugging. This option can be modified
   * after the client is connected using the property {@link RequestLogger#logNormalRequests}.
   * @param {Boolean} [options.logErroredRequests] Determines whether it should emit 'failure' events for every
   * EXECUTE, QUERY and BATCH request execution that resulted in an error. This option can be modified
   * after the client is connected using the property {@link RequestLogger#logErroredRequests}.
   * @param {Number} [options.messageMaxQueryLength] The maximum amount of characters that are logged from the query
   * portion of the message. Defaults to 500.
   * @param {Number} [options.messageMaxParameterValueLength] The maximum amount of characters of each query parameter
   * value that will be included in the message. Defaults to 50.
   * @param {Number} [options.messageMaxErrorStackTraceLength] The maximum amount of characters of the stack trace
   * that will be included in the message. Defaults to 200.
   */
  function RequestLogger(options) {
    var _this;

    _classCallCheck(this, RequestLogger);

    _this = _super.call(this);

    if (!options) {
      throw new errors$k.ArgumentError('RequestLogger options parameter is required');
    }

    _this._options = options;
    /**
     * Determines whether it should emit 'normal' events for every EXECUTE, QUERY and BATCH request executed
     * successfully, useful only for debugging
     * @type {Boolean}
     */

    _this.logNormalRequests = _this._options.logNormalRequests;
    /**
     * Determines whether it should emit 'failure' events for every EXECUTE, QUERY and BATCH request execution that
     * resulted in an error
     * @type {Boolean}
     */

    _this.logErroredRequests = _this._options.logErroredRequests;
    /**
     * The object instance that emits <code>'slow'</code>, <code>'large'</code>, <code>'normal'</code> and
     * <code>'failure'</code> events.
     * @type {EventEmitter}
     */

    _this.emitter = new events$9.EventEmitter();
    return _this;
  }
  /**
   * Logs message if request execution was deemed too slow, large or if normal requests are logged.
   * @override
   */


  _createClass(RequestLogger, [{
    key: "onSuccess",
    value: function onSuccess(host, query, parameters, execOptions, requestLength, responseLength, latency) {
      if (this._options.slowThreshold > 0 && toMillis(latency) > this._options.slowThreshold) {
        this._logSlow(host, query, parameters, execOptions, requestLength, responseLength, latency);
      } else if (this._options.requestSizeThreshold > 0 && requestLength > this._options.requestSizeThreshold) {
        this._logLargeRequest(host, query, parameters, execOptions, requestLength, responseLength, latency);
      } else if (this.logNormalRequests) {
        this._logNormalRequest(host, query, parameters, execOptions, requestLength, responseLength, latency);
      }
    }
    /**
     * Logs message if request execution was too large and/or encountered an error.
     * @override
     */

  }, {
    key: "onError",
    value: function onError(host, query, parameters, execOptions, requestLength, err, latency) {
      if (this._options.requestSizeThreshold > 0 && requestLength > this._options.requestSizeThreshold) {
        this._logLargeErrorRequest(host, query, parameters, execOptions, requestLength, err, latency);
      } else if (this.logErroredRequests) {
        this._logErrorRequest(host, query, parameters, execOptions, requestLength, err, latency);
      }
    }
  }, {
    key: "_logSlow",
    value: function _logSlow(host, query, parameters, execOptions, requestLength, responseLength, latency) {
      var message = format$1('[%s] Slow request, took %d ms (%s): %s', host.address, Math.floor(toMillis(latency)), getPayloadSizes(requestLength, responseLength), getStatementInfo(query, parameters, execOptions, this._options));
      this.emitter.emit('slow', message);
    }
  }, {
    key: "_logLargeRequest",
    value: function _logLargeRequest(host, query, parameters, execOptions, requestLength, responseLength, latency) {
      var message = format$1('[%s] Request exceeded length, %s (took %d ms): %s', host.address, getPayloadSizes(requestLength, responseLength), ~~toMillis(latency), getStatementInfo(query, parameters, execOptions, this._options));
      this.emitter.emit('large', message);
    }
  }, {
    key: "_logNormalRequest",
    value: function _logNormalRequest(host, query, parameters, execOptions, requestLength, responseLength, latency) {
      var message = format$1('[%s] Request completed normally, took %d ms (%s): %s', host.address, ~~toMillis(latency), getPayloadSizes(requestLength, responseLength), getStatementInfo(query, parameters, execOptions, this._options));
      this.emitter.emit('normal', message);
    }
  }, {
    key: "_logLargeErrorRequest",
    value: function _logLargeErrorRequest(host, query, parameters, execOptions, requestLength, err, latency) {
      var maxStackTraceLength = this._options.messageMaxErrorStackTraceLength || defaultMaxErrorStackTraceLength;
      var message = format$1('[%s] Request exceeded length and execution failed, %s (took %d ms): %s; error: %s', host.address, getPayloadSizes(requestLength), ~~toMillis(latency), getStatementInfo(query, parameters, execOptions, this._options), err.stack.substr(0, maxStackTraceLength)); // Use 'large' event and not 'failure' as this log is caused by exceeded length

      this.emitter.emit('large', message);
    }
  }, {
    key: "_logErrorRequest",
    value: function _logErrorRequest(host, query, parameters, execOptions, requestLength, err, latency) {
      var maxStackTraceLength = this._options.messageMaxErrorStackTraceLength || defaultMaxErrorStackTraceLength;
      var message = format$1('[%s] Request execution failed, took %d ms (%s): %s; error: %s', host.address, ~~toMillis(latency), getPayloadSizes(requestLength), getStatementInfo(query, parameters, execOptions, this._options), err.stack.substr(0, maxStackTraceLength)); // Avoid using 'error' as its a special event

      this.emitter.emit('failure', message);
    }
  }]);

  return RequestLogger;
}(RequestTracker);

function toMillis(latency) {
  return latency[0] * 1000 + latency[1] / nanosToMillis;
}

function getStatementInfo(query, parameters, execOptions, options) {
  var maxQueryLength = options.messageMaxQueryLength || defaultMessageMaxQueryLength;
  var maxParameterLength = options.messageMaxParameterValueLength || defaultMaxParameterValueLength;

  if (Array.isArray(query)) {
    return getBatchStatementInfo(query, execOptions, maxQueryLength, maxParameterLength);
  } // String concatenation is usually faster than Array#join() in V8


  var message = query.substr(0, maxQueryLength);
  var remaining = maxQueryLength - message.length - 1;
  message += getParametersInfo(parameters, remaining, maxParameterLength);

  if (!execOptions.isPrepared()) {
    // This part of the message is not accounted for in "maxQueryLength"
    message += ' (not prepared)';
  }

  return message;
}

function getBatchStatementInfo(queries, execOptions, maxQueryLength, maxParameterLength) {
  // This part of the message is not accounted for in "maxQueryLength"
  var message = (execOptions.isBatchLogged() ? 'LOGGED ' : '') + 'BATCH w/ ' + queries.length + (!execOptions.isPrepared() ? ' not prepared' : '') + ' queries (';
  var remaining = maxQueryLength;
  var i;

  for (i = 0; i < queries.length && remaining > 0; i++) {
    var q = queries[i];
    var params = q.params;

    if (typeof q !== 'string') {
      q = q.query;
    }

    if (i > 0) {
      message += ',';
      remaining--;
    }

    var queryLength = Math.min(remaining, q.length);
    message += q.substr(0, queryLength);
    remaining -= queryLength;

    if (remaining <= 0) {
      break;
    }

    var parameters = getParametersInfo(params, remaining, maxParameterLength);
    remaining -= parameters.length;
    message += parameters;
  }

  message += i < queries.length ? ',...)' : ')';
  return message;
}

function getParametersInfo(params, remaining, maxParameterLength) {
  if (remaining <= 3) {
    // We need at least 3 chars to describe the parameters
    // its OK to add more chars in an effort to be descriptive
    return ' [...]';
  }

  if (!params) {
    return ' []';
  }

  var paramStringifier = function paramStringifier(index, length) {
    return formatParam(params[index], length);
  };

  if (!Array.isArray(params)) {
    var obj = params;
    params = Object.keys(params);

    paramStringifier = function paramStringifier(index, length) {
      var key = params[index];
      var result = key.substr(0, length);
      var rem = length - result.length - 1;

      if (rem <= 0) {
        return result;
      }

      result += ":" + formatParam(obj[key], rem);
      return result;
    };
  }

  var message = ' [';
  var i;

  for (i = 0; remaining > 0 && i < params.length; i++) {
    if (i > 0) {
      message += ',';
      remaining--;
    }

    var paramString = paramStringifier(i, Math.min(maxParameterLength, remaining));
    remaining -= paramString.length;
    message += paramString;
  }

  if (i < params.length) {
    message += '...';
  }

  message += ']';
  return message;
}

function formatParam(value, maxLength) {
  if (value === undefined) {
    return 'undefined';
  }

  if (value === null) {
    return 'null';
  }

  return value.toString().substr(0, maxLength);
}

function getPayloadSizes(requestLength, responseLength) {
  var message = 'request size ' + formatSize(requestLength);

  if (responseLength !== undefined) {
    message += ' / response size ' + formatSize(responseLength);
  }

  return message;
}

function formatSize(length) {
  return length > 1000 ? Math.round(length / 1024) + ' KB' : length + ' bytes';
}

var requestLogger = RequestLogger;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Tracker module.
 * @module tracker
 */


tracker$1.RequestLogger = requestLogger;
tracker$1.RequestTracker = requestTracker;

/**
 * Represents a base class that is used to measure events from the server and the client as seen by the driver.
 * @alias module:metrics~ClientMetrics
 * @interface
 */


var ClientMetrics$2 = /*#__PURE__*/function () {
  function ClientMetrics() {
    _classCallCheck(this, ClientMetrics);
  }

  _createClass(ClientMetrics, [{
    key: "onAuthenticationError",
    value:
    /**
     * Method invoked when an authentication error is obtained from the server.
     * @param {AuthenticationError|Error} e The error encountered.
     */
    function onAuthenticationError(e) {}
    /**
     * Method invoked when an error (different than a server or client timeout, authentication or connection error) is
     * encountered when executing a request.
     * @param {OperationTimedOutError} e The timeout error.
     */

  }, {
    key: "onClientTimeoutError",
    value: function onClientTimeoutError(e) {}
    /**
     * Method invoked when there is a connection error.
     * @param {Error} e The error encountered.
     */

  }, {
    key: "onConnectionError",
    value: function onConnectionError(e) {}
    /**
     * Method invoked when an error (different than a server or client timeout, authentication or connection error) is
     * encountered when executing a request.
     * @param {Error} e The error encountered.
     */

  }, {
    key: "onOtherError",
    value: function onOtherError(e) {}
    /**
     * Method invoked when a read timeout error is obtained from the server.
     * @param {ResponseError} e The error encountered.
     */

  }, {
    key: "onReadTimeoutError",
    value: function onReadTimeoutError(e) {}
    /**
     * Method invoked when a write timeout error is obtained from the server.
     * @param {ResponseError} e The error encountered.
     */

  }, {
    key: "onWriteTimeoutError",
    value: function onWriteTimeoutError(e) {}
    /**
     * Method invoked when an unavailable error is obtained from the server.
     * @param {ResponseError} e The error encountered.
     */

  }, {
    key: "onUnavailableError",
    value: function onUnavailableError(e) {}
    /**
     * Method invoked when an execution is retried as a result of a client-level timeout.
     * @param {Error} e The error that caused the retry.
     */

  }, {
    key: "onClientTimeoutRetry",
    value: function onClientTimeoutRetry(e) {}
    /**
     * Method invoked when an error (other than a server or client timeout) is retried.
     * @param {Error} e The error that caused the retry.
     */

  }, {
    key: "onOtherErrorRetry",
    value: function onOtherErrorRetry(e) {}
    /**
     * Method invoked when an execution is retried as a result of a read timeout from the server (coordinator to replica).
     * @param {Error} e The error that caused the retry.
     */

  }, {
    key: "onReadTimeoutRetry",
    value: function onReadTimeoutRetry(e) {}
    /**
     * Method invoked when an execution is retried as a result of an unavailable error from the server.
     * @param {Error} e The error that caused the retry.
     */

  }, {
    key: "onUnavailableRetry",
    value: function onUnavailableRetry(e) {}
    /**
     * Method invoked when an execution is retried as a result of a write timeout from the server (coordinator to
     * replica).
     * @param {Error} e The error that caused the retry.
     */

  }, {
    key: "onWriteTimeoutRetry",
    value: function onWriteTimeoutRetry(e) {}
    /**
     * Method invoked when an error is marked as ignored by the retry policy.
     * @param {Error} e The error that was ignored by the retry policy.
     */

  }, {
    key: "onIgnoreError",
    value: function onIgnoreError(e) {}
    /**
     * Method invoked when a speculative execution is started.
     */

  }, {
    key: "onSpeculativeExecution",
    value: function onSpeculativeExecution() {}
    /**
     * Method invoked when a response is obtained successfully.
     * @param {Array<Number>} latency The latency represented in a <code>[seconds, nanoseconds]</code> tuple
     * Array, where nanoseconds is the remaining part of the real time that can't be represented in second precision.
     */

  }, {
    key: "onSuccessfulResponse",
    value: function onSuccessfulResponse(latency) {}
    /**
     * Method invoked when any response is obtained, the response can be the result of a successful execution or a
     * server-side error.
     * @param {Array<Number>} latency The latency represented in a <code>[seconds, nanoseconds]</code> tuple
     * Array, where nanoseconds is the remaining part of the real time that can't be represented in second precision.
     */

  }, {
    key: "onResponse",
    value: function onResponse(latency) {}
  }]);

  return ClientMetrics;
}();

var clientMetrics = ClientMetrics$2;

var ClientMetrics$1 = clientMetrics;
var EventEmitter$1 = require$$0__default$2["default"];
/**
 * A default implementation of [ClientMetrics]{@link module:metrics~ClientMetrics} that exposes the driver events as
 * Node.js events.
 * <p>
 *   An instance of [DefaultMetrics]{@link module:metrics~DefaultMetrics} is configured by default in the client,
 *   you can access this instance using [Client#metrics]{@link Client#metrics} property.
 * </p>
 * @implements {module:metrics~ClientMetrics}
 * @alias module:metrics~DefaultMetrics
 * @example <caption>Listening to events emitted</caption>
 * defaultMetrics.errors.on('increment', err => totalErrors++);
 * defaultMetrics.errors.clientTimeout.on('increment', () => clientTimeoutErrors++);
 * defaultMetrics.speculativeRetries.on('increment', () => specExecsCount++);
 * defaultMetrics.responses.on('increment', latency => myHistogram.record(latency));
 */

var DefaultMetrics$1 = /*#__PURE__*/function (_ClientMetrics) {
  _inherits(DefaultMetrics, _ClientMetrics);

  var _super = _createSuper(DefaultMetrics);

  /**
   * Creates a new instance of [DefaultMetrics]{@link module:metrics~DefaultMetrics}.
   */
  function DefaultMetrics() {
    var _this;

    _classCallCheck(this, DefaultMetrics);

    _this = _super.call(this);
    /**
     * Emits all the error events.
     * <p>Use each of the properties to measure events of specific errors.</p>
     * @type {EventEmitter}
     * @property {EventEmitter} authentication Emits the authentication timeout error events.
     * @property {EventEmitter} clientTimeout Emits the client timeout error events.
     * @property {EventEmitter} connection Emits the connection error events.
     * @property {EventEmitter} readTimeout Emits the read timeout error events obtained from the server.
     * @property {EventEmitter} other Emits the error events, that are not part of the other categories.
     * @property {EventEmitter} unavailable Emits the unavailable error events obtained from the server.
     * @property {EventEmitter} writeTimeout Emits the write timeout error events obtained from the server
     */

    _this.errors = new EventEmitter$1();
    _this.errors.authentication = new EventEmitter$1();
    _this.errors.clientTimeout = new EventEmitter$1();
    _this.errors.connection = new EventEmitter$1();
    _this.errors.other = new EventEmitter$1();
    _this.errors.readTimeout = new EventEmitter$1();
    _this.errors.unavailable = new EventEmitter$1();
    _this.errors.writeTimeout = new EventEmitter$1();
    /**
     * Emits all the retry events.
     * <p>Use each of the properties to measure events of specific retries.</p>
     * @type {EventEmitter}
     * @property {EventEmitter} clientTimeout Emits when an execution is retried as a result of an client timeout.
     * @property {EventEmitter} other Emits the error events, that are not part of the other categories.
     * @property {EventEmitter} readTimeout Emits an execution is retried as a result of an read timeout error from the
     * server (coordinator to replica).
     * @property {EventEmitter} unavailable Emits an execution is retried as a result of an unavailable error from the
     * server.
     * @property {EventEmitter} writeTimeout Emits an execution is retried as a result of a write timeout error from the
     * server (coordinator to replica).
     */

    _this.retries = new EventEmitter$1();
    _this.retries.clientTimeout = new EventEmitter$1();
    _this.retries.other = new EventEmitter$1();
    _this.retries.readTimeout = new EventEmitter$1();
    _this.retries.unavailable = new EventEmitter$1();
    _this.retries.writeTimeout = new EventEmitter$1();
    /**
     * Emits events when a speculative execution is started.
     * @type {EventEmitter}
     */

    _this.speculativeExecutions = new EventEmitter$1();
    /**
     * Emits events when an error is ignored by the retry policy.
     * @type {EventEmitter}
     */

    _this.ignoredErrors = new EventEmitter$1();
    /**
     * Emits events when a response message is obtained.
     * @type {EventEmitter}
     * @property {EventEmitter} success Emits when a response was obtained as the result of a successful execution.
     */

    _this.responses = new EventEmitter$1();
    _this.responses.success = new EventEmitter$1();
    return _this;
  }
  /** @override */


  _createClass(DefaultMetrics, [{
    key: "onAuthenticationError",
    value: function onAuthenticationError(e) {
      this.errors.authentication.emit('increment', e);
      this.errors.emit('increment', e);
    }
    /** @override */

  }, {
    key: "onConnectionError",
    value: function onConnectionError(e) {
      this.errors.connection.emit('increment', e);
      this.errors.emit('increment', e);
    }
    /** @override */

  }, {
    key: "onReadTimeoutError",
    value: function onReadTimeoutError(e) {
      this.errors.readTimeout.emit('increment', e);
      this.errors.emit('increment', e);
    }
    /** @override */

  }, {
    key: "onWriteTimeoutError",
    value: function onWriteTimeoutError(e) {
      this.errors.writeTimeout.emit('increment', e);
      this.errors.emit('increment', e);
    }
    /** @override */

  }, {
    key: "onUnavailableError",
    value: function onUnavailableError(e) {
      this.errors.unavailable.emit('increment', e);
      this.errors.emit('increment', e);
    }
    /** @override */

  }, {
    key: "onClientTimeoutError",
    value: function onClientTimeoutError(e) {
      this.errors.clientTimeout.emit('increment', e);
      this.errors.emit('increment', e);
    }
    /** @override */

  }, {
    key: "onOtherError",
    value: function onOtherError(e) {
      this.errors.other.emit('increment', e);
      this.errors.emit('increment', e);
    }
    /** @override */

  }, {
    key: "onClientTimeoutRetry",
    value: function onClientTimeoutRetry(e) {
      this.retries.clientTimeout.emit('increment', e);
      this.retries.emit('increment', e);
    }
    /** @override */

  }, {
    key: "onOtherErrorRetry",
    value: function onOtherErrorRetry(e) {
      this.retries.other.emit('increment', e);
      this.retries.emit('increment', e);
    }
    /** @override */

  }, {
    key: "onReadTimeoutRetry",
    value: function onReadTimeoutRetry(e) {
      this.retries.readTimeout.emit('increment', e);
      this.retries.emit('increment', e);
    }
    /** @override */

  }, {
    key: "onUnavailableRetry",
    value: function onUnavailableRetry(e) {
      this.retries.unavailable.emit('increment', e);
      this.retries.emit('increment', e);
    }
    /** @override */

  }, {
    key: "onWriteTimeoutRetry",
    value: function onWriteTimeoutRetry(e) {
      this.retries.writeTimeout.emit('increment', e);
      this.retries.emit('increment', e);
    }
    /** @override */

  }, {
    key: "onIgnoreError",
    value: function onIgnoreError(e) {
      this.ignoredErrors.emit('increment', e);
    }
    /** @override */

  }, {
    key: "onSpeculativeExecution",
    value: function onSpeculativeExecution() {
      this.speculativeExecutions.emit('increment');
    }
    /** @override */

  }, {
    key: "onSuccessfulResponse",
    value: function onSuccessfulResponse(latency) {
      this.responses.success.emit('increment', latency);
    }
    /** @override */

  }, {
    key: "onResponse",
    value: function onResponse(latency) {
      this.responses.emit('increment', latency);
    }
  }]);

  return DefaultMetrics;
}(ClientMetrics$1);

var defaultMetrics = DefaultMetrics$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var ClientMetrics = clientMetrics;
var DefaultMetrics = defaultMetrics;
/**
 * The <code>metrics</code> module contains interfaces and implementations used by the driver to expose
 * measurements of its internal behavior and of the server as seen from the driver side.
 * @module metrics
 */

var metrics$1 = {
  ClientMetrics: ClientMetrics,
  DefaultMetrics: DefaultMetrics
};

var provider$1 = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @classdesc Provides [Authenticator]{@link module:auth~Authenticator} instances to be used when connecting to a host.
 * @constructor
 * @abstract
 * @alias module:auth~AuthProvider
 */


function AuthProvider$5() {}
/**
 * Returns an [Authenticator]{@link module:auth~Authenticator} instance to be used when connecting to a host.
 * @param {String} endpoint The ip address and port number in the format ip:port
 * @param {String} name Authenticator name
 * @abstract
 * @returns {Authenticator}
 */


AuthProvider$5.prototype.newAuthenticator = function (endpoint, name) {
  throw new Error('This is an abstract class, you must implement newAuthenticator method or ' + 'use another auth provider that inherits from this class');
};
/**
 * @class
 * @classdesc Handles SASL authentication with Cassandra servers.
 * Each time a new connection is created and the server requires authentication,
 * a new instance of this class will be created by the corresponding.
 * @constructor
 * @alias module:auth~Authenticator
 */


function Authenticator$4() {}
/**
 * Obtain an initial response token for initializing the SASL handshake.
 * @param {Function} callback
 */


Authenticator$4.prototype.initialResponse = function (callback) {
  callback(new Error('Not implemented'));
};
/**
 * Evaluates a challenge received from the Server. Generally, this method should callback with
 * no error and no additional params when authentication is complete from the client perspective.
 * @param {Buffer} challenge
 * @param {Function} callback
 */


Authenticator$4.prototype.evaluateChallenge = function (challenge, callback) {
  callback(new Error('Not implemented'));
};
/**
 * Called when authentication is successful with the last information
 * optionally sent by the server.
 * @param {Buffer} [token]
 */


Authenticator$4.prototype.onAuthenticationSuccess = function (token) {};

provider$1.AuthProvider = AuthProvider$5;
provider$1.Authenticator = Authenticator$4;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$w = require$$0__default$1["default"];
var provider = provider$1;
var utils$G = utils$V;
var AuthProvider$4 = provider.AuthProvider;
var Authenticator$3 = provider.Authenticator;
/**
 * Creates a new instance of the Authenticator provider
 * @classdesc Provides plain text [Authenticator]{@link module:auth~Authenticator} instances to be used when
 * connecting to a host.
 * @extends module:auth~AuthProvider
 * @example
 * var authProvider = new cassandra.auth.PlainTextAuthProvider('my_user', 'p@ssword1!');
 * //Set the auth provider in the clientOptions when creating the Client instance
 * const client = new Client({ contactPoints: contactPoints, authProvider: authProvider });
 * @param {String} username User name in plain text
 * @param {String} password Password in plain text
 * @alias module:auth~PlainTextAuthProvider
 * @constructor
 */

function PlainTextAuthProvider$1(username, password) {
  this.username = username;
  this.password = password;
}

util$w.inherits(PlainTextAuthProvider$1, AuthProvider$4);
/**
 * Returns a new [Authenticator]{@link module:auth~Authenticator} instance to be used for plain text authentication.
 * @override
 * @returns {Authenticator}
 */

PlainTextAuthProvider$1.prototype.newAuthenticator = function () {
  return new PlainTextAuthenticator$2(this.username, this.password);
};
/**
 * @ignore
 */


function PlainTextAuthenticator$2(username, password) {
  this.username = username;
  this.password = password;
}

util$w.inherits(PlainTextAuthenticator$2, Authenticator$3);

PlainTextAuthenticator$2.prototype.initialResponse = function (callback) {
  var initialToken = Buffer.concat([utils$G.allocBufferFromArray([0]), utils$G.allocBufferFromString(this.username, 'utf8'), utils$G.allocBufferFromArray([0]), utils$G.allocBufferFromString(this.password, 'utf8')]);
  callback(null, initialToken);
};

PlainTextAuthenticator$2.prototype.evaluateChallenge = function (challenge, callback) {
  //noop
  callback();
};

var plainTextAuthProvider = {
  PlainTextAuthenticator: PlainTextAuthenticator$2,
  PlainTextAuthProvider: PlainTextAuthProvider$1
};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$v = require$$0__default$1["default"];
var Authenticator$2 = provider$1.Authenticator;
var dseAuthenticatorName = 'com.datastax.bdp.cassandra.auth.DseAuthenticator';
/**
 * Base class for Authenticator implementations that want to make use of
 * the authentication scheme negotiation in the DseAuthenticator
 * @param {String} authenticatorName
 * @extends Authenticator
 * @constructor
 * @ignore
 */

function BaseDseAuthenticator$2(authenticatorName) {
  this.authenticatorName = authenticatorName;
}

util$v.inherits(BaseDseAuthenticator$2, Authenticator$2);
/**
 * Return a Buffer containing the required SASL mechanism.
 * @abstract
 * @returns {Buffer}
 */

BaseDseAuthenticator$2.prototype.getMechanism = function () {
  throw new Error('Not implemented');
};
/**
 * Return a byte array containing the expected successful server challenge.
 * @abstract
 * @returns {Buffer}
 */


BaseDseAuthenticator$2.prototype.getInitialServerChallenge = function () {
  throw new Error('Not implemented');
};
/**
 * @param {Function} callback
 * @override
 */


BaseDseAuthenticator$2.prototype.initialResponse = function (callback) {
  if (!this._isDseAuthenticator()) {
    //fallback
    return this.evaluateChallenge(this.getInitialServerChallenge(), callback);
  } //send the mechanism as a first auth message


  callback(null, this.getMechanism());
};
/**
 * Determines if the name of the authenticator matches DSE 5+
 * @protected
 * @ignore
 */


BaseDseAuthenticator$2.prototype._isDseAuthenticator = function () {
  return this.authenticatorName === dseAuthenticatorName;
};

var baseDseAuthenticator = BaseDseAuthenticator$2;

var util$u = require$$0__default$1["default"];
var utils$F = utils$V;
/**
 * GSSAPI Client interface.
 * @ignore
 */

var GssapiClient$1 = /*#__PURE__*/function () {
  /**
   * @param {String} [authorizationId]
   * @param {String} [service]
   */
  function GssapiClient(authorizationId, service) {
    _classCallCheck(this, GssapiClient);

    this.authorizationId = authorizationId;
    this.service = service !== undefined ? service : 'dse';
  }
  /**
   * @abstract
   * @param {String} host Host name or ip
   * @param {Function} callback
   */


  _createClass(GssapiClient, [{
    key: "init",
    value: function init(host, callback) {
      throw new Error('Not implemented');
    }
    /**
     * @param {Buffer} challenge
     * @param {Function} callback
     * @abstract
     */

  }, {
    key: "evaluateChallenge",
    value: function evaluateChallenge(challenge, callback) {
      throw new Error('Not implemented');
    }
    /**
     * @abstract
     * @param {Function} [callback]
     */

  }, {
    key: "shutdown",
    value: function shutdown(callback) {
      throw new Error('Not implemented');
    }
    /**
     * Factory to get the actual implementation of GSSAPI (unix or win)
     * @param {Object} kerberosModule Kerberos client library dependency
     * @param {String} [authorizationId] An identity to act as (for proxy authentication).
     * @param {String} [service] The service to use. (defaults to 'dse')
     * @returns GssapiClient
     */

  }], [{
    key: "createNew",
    value: function createNew(kerberosModule, authorizationId, service) {
      return new StandardGssClient(kerberosModule, authorizationId, service);
    }
  }]);

  return GssapiClient;
}();
/**
 * GSSAPI Client implementation using kerberos module.
 * @ignore
 */


var StandardGssClient = /*#__PURE__*/function (_GssapiClient) {
  _inherits(StandardGssClient, _GssapiClient);

  var _super = _createSuper(StandardGssClient);

  function StandardGssClient(kerberosModule, authorizationId, service) {
    var _this;

    _classCallCheck(this, StandardGssClient);

    if (typeof kerberosModule.initializeClient !== 'function') {
      throw new Error('The driver expects version 1.x of the kerberos library');
    }

    _this = _super.call(this, authorizationId, service);
    _this.kerberos = kerberosModule;
    _this.transitionIndex = 0;
    return _this;
  }

  _createClass(StandardGssClient, [{
    key: "init",
    value: function init(host, callback) {
      var _this2 = this;

      this.host = host;
      var uri = this.service;

      if (this.host) {
        //For the principal    "dse/cassandra1.datastax.com@DATASTAX.COM"
        //the expected uri is: "dse@cassandra1.datastax.com"
        uri = util$u.format("%s@%s", this.service, this.host);
      }

      var options = {
        gssFlags: this.kerberos.GSS_C_MUTUAL_FLAG //authenticate itself flag

      };
      this.kerberos.initializeClient(uri, options, function (err, kerberosClient) {
        if (err) {
          return callback(err);
        }

        _this2.kerberosClient = kerberosClient;
        callback();
      });
    }
    /** @override */

  }, {
    key: "evaluateChallenge",
    value: function evaluateChallenge(challenge, callback) {
      var _this3 = this;

      this['transition' + this.transitionIndex](challenge, function (err, response) {
        if (err) {
          return callback(err);
        }

        _this3.transitionIndex++;
        callback(null, response ? utils$F.allocBufferFromString(response, 'base64') : utils$F.allocBuffer(0));
      });
    }
  }, {
    key: "transition0",
    value: function transition0(challenge, callback) {
      this.kerberosClient.step('', callback);
    }
  }, {
    key: "transition1",
    value: function transition1(challenge, callback) {
      var charPointerChallenge = challenge.toString('base64');
      this.kerberosClient.step(charPointerChallenge, callback);
    }
  }, {
    key: "transition2",
    value: function transition2(challenge, callback) {
      var _this4 = this;

      this.kerberosClient.unwrap(challenge.toString('base64'), function (err, response) {
        if (err) {
          return callback(err, false);
        }

        var cb = function cb(err, wrapped) {
          if (err) {
            return callback(err);
          }

          callback(null, wrapped);
        };

        if (_this4.authorizationId !== undefined) {
          _this4.kerberosClient.wrap(response, {
            user: _this4.authorizationId
          }, cb);
        } else {
          _this4.kerberosClient.wrap(response, null, cb);
        }
      });
    }
  }, {
    key: "shutdown",
    value: function shutdown(callback) {
      this.kerberosClient = null;
      callback();
    }
  }]);

  return StandardGssClient;
}(GssapiClient$1);

var gssapiClient = GssapiClient$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$t = require$$0__default$1["default"];
var AuthProvider$3 = provider$1.AuthProvider;
var BaseDseAuthenticator$1 = baseDseAuthenticator;
var GssapiClient = gssapiClient;
var dns$1 = require$$0__default$3["default"];
var utils$E = utils$V;
var mechanism$1 = utils$E.allocBufferFromString('GSSAPI');
var initialServerChallenge$1 = 'GSSAPI-START';
var emptyBuffer = utils$E.allocBuffer(0);
/**
 * Creates a new instance of <code>DseGssapiAuthProvider</code>.
 * @classdesc
 * AuthProvider that provides GSSAPI authenticator instances for clients to connect
 * to DSE clusters secured with the DseAuthenticator.
 * @param {Object} [gssOptions] GSSAPI authenticator options
 * @param {String} [gssOptions.authorizationId] The optional authorization ID. Providing an authorization ID allows the
 * currently authenticated user to act as a different user (a.k.a. proxy authentication).
 * @param {String} [gssOptions.service] The service to use. Defaults to 'dse'.
 * @param {Function} [gssOptions.hostNameResolver] A method to be used to resolve the name of the Cassandra node based
 * on the IP Address.  Defaults to [lookupServiceResolver]{@link module:auth~DseGssapiAuthProvider.lookupServiceResolver}
 * which resolves the FQDN of the provided IP to generate principals in the format of
 * <code>dse/example.com@MYREALM.COM</code>.
 * Alternatively, you can use [reverseDnsResolver]{@link module:auth~DseGssapiAuthProvider.reverseDnsResolver} to do a
 * reverse DNS lookup or [useIpResolver]{@link module:auth~DseGssapiAuthProvider.useIpResolver} to simply use the IP
 * address provided.
 * @param {String} [gssOptions.user] DEPRECATED, it will be removed in future versions. For proxy authentication, use
 * <code>authorizationId</code> instead.
 * @example
 * const client = new cassandra.Client({
 *   contactPoints: ['h1', 'h2'],
 *   authProvider: new cassandra.auth.DseGssapiAuthProvider()
 * });
 * @alias module:auth~DseGssapiAuthProvider
 * @constructor
 */

function DseGssapiAuthProvider$1(gssOptions) {
  //load the kerberos at construction time
  try {
    // eslint-disable-next-line
    this._kerberos = require('kerberos');
  } catch (err) {
    if (err.code === 'MODULE_NOT_FOUND') {
      var newErr = new Error('You must install module "kerberos" to use GSSAPI auth provider: ' + 'https://www.npmjs.com/package/kerberos');
      newErr.code = err.code;
      throw newErr;
    }

    throw err;
  }

  gssOptions = gssOptions || utils$E.emptyObject;
  this.authorizationId = gssOptions.authorizationId || gssOptions.user;
  this.service = gssOptions.service;
  this.hostNameResolver = gssOptions.hostNameResolver || DseGssapiAuthProvider$1.lookupServiceResolver;
}

util$t.inherits(DseGssapiAuthProvider$1, AuthProvider$3);
/**
 * Returns an Authenticator instance to be used by the driver when connecting to a host.
 * @param {String} endpoint The IP address and port number in the format ip:port.
 * @param {String} name Authenticator name.
 * @override
 * @returns {Authenticator}
 */

DseGssapiAuthProvider$1.prototype.newAuthenticator = function (endpoint, name) {
  var address = endpoint;

  if (endpoint.indexOf(':') > 0) {
    address = endpoint.split(':')[0];
  }

  return new GssapiAuthenticator(this._kerberos, address, name, this.authorizationId, this.service, this.hostNameResolver);
};
/**
 * Performs a lookupService query that resolves an IPv4 or IPv6 address to a hostname.  This ultimately makes a
 * <code>getnameinfo()</code> system call which depends on the OS to do hostname resolution.
 * <p/>
 * <b>Note:</b> Depends on <code>dns.lookupService</code> which was added in 0.12.  For older versions falls back on
 * [reverseDnsResolver]{@link module:auth~DseGssapiAuthProvider.reverseDnsResolver}.
 *
 * @param {String} ip IP address to resolve.
 * @param {Function} callback The callback function with <code>err</code> and <code>hostname</code> arguments.
 */


DseGssapiAuthProvider$1.lookupServiceResolver = function (ip, callback) {
  if (!dns$1.lookupService) {
    return DseGssapiAuthProvider$1.reverseDnsResolver(ip, callback);
  }

  dns$1.lookupService(ip, 0, function (err, hostname) {
    if (err) {
      return callback(err);
    }

    if (!hostname) {
      //fallback to ip
      return callback(null, ip);
    }

    callback(null, hostname);
  });
};
/**
 * Performs a reverse DNS query that resolves an IPv4 or IPv6 address to a hostname.
 * @param {String} ip IP address to resolve.
 * @param {Function} callback The callback function with <code>err</code> and <code>hostname</code> arguments.
 */


DseGssapiAuthProvider$1.reverseDnsResolver = function (ip, callback) {
  dns$1.reverse(ip, function (err, names) {
    if (err) {
      return callback(err);
    }

    if (!names || !names.length) {
      //fallback to ip
      return callback(null, ip);
    }

    callback(null, names[0]);
  });
};
/**
 * Effectively a no op operation, returns the IP address provided.
 * @param {String} ip IP address to use.
 * @param {Function} callback The callback function with <code>err</code> and <code>hostname</code> arguments.
 */


DseGssapiAuthProvider$1.useIpResolver = function (ip, callback) {
  callback(null, ip);
};
/**
 * @param {Object} kerberosModule
 * @param {String} address Host address.
 * @param {String} authenticatorName
 * @param {String} authorizationId
 * @param {String} service
 * @param {Function} hostNameResolver
 * @extends Authenticator
 * @private
 */


function GssapiAuthenticator(kerberosModule, address, authenticatorName, authorizationId, service, hostNameResolver) {
  BaseDseAuthenticator$1.call(this, authenticatorName);
  this.authorizationId = authorizationId;
  this.address = address;
  this.client = GssapiClient.createNew(kerberosModule, authorizationId, service);
  this.hostNameResolver = hostNameResolver;
} //noinspection JSCheckFunctionSignatures


util$t.inherits(GssapiAuthenticator, BaseDseAuthenticator$1);

GssapiAuthenticator.prototype.getMechanism = function () {
  return mechanism$1;
};

GssapiAuthenticator.prototype.getInitialServerChallenge = function () {
  return utils$E.allocBufferFromString(initialServerChallenge$1);
}; //noinspection JSUnusedGlobalSymbols

/**
 * Obtain an initial response token for initializing the SASL handshake.
 * @param {Function} callback
 */


GssapiAuthenticator.prototype.initialResponse = function (callback) {
  var self = this; //initialize the GSS client

  var host = this.address;
  utils$E.series([function getHostName(next) {
    self.hostNameResolver(self.address, function (err, name) {
      if (!err && name) {
        host = name;
      }

      next();
    });
  }, function initClient(next) {
    self.client.init(host, function (err) {
      if (err) {
        return next(err);
      }

      if (!self._isDseAuthenticator()) {
        //fallback
        return self.evaluateChallenge(self.getInitialServerChallenge(), next);
      } //send the mechanism as a first auth message


      next(null, self.getMechanism());
    });
  }], callback);
};
/**
 * Evaluates a challenge received from the Server. Generally, this method should callback with
 * no error and no additional params when authentication is complete from the client perspective.
 * @param {Buffer} challenge
 * @param {Function} callback
 * @override
 */


GssapiAuthenticator.prototype.evaluateChallenge = function (challenge, callback) {
  if (!challenge || challenge.toString() === initialServerChallenge$1) {
    challenge = emptyBuffer;
  }

  this.client.evaluateChallenge(challenge, callback);
};
/**
 * @override
 */


GssapiAuthenticator.prototype.onAuthenticationSuccess = function (token) {
  this.client.shutdown(function noop() {});
};

var dseGssapiAuthProvider = DseGssapiAuthProvider$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$s = require$$0__default$1["default"];
var AuthProvider$2 = provider$1.AuthProvider;
var BaseDseAuthenticator = baseDseAuthenticator;
var utils$D = utils$V;
var mechanism = utils$D.allocBufferFromString('PLAIN');
var separatorBuffer = utils$D.allocBufferFromArray([0]);
var initialServerChallenge = 'PLAIN-START';
/**
 * Creates a new instance of <code>DsePlainTextAuthProvider</code>.
 * @classdesc
 * AuthProvider that provides plain text authenticator instances for clients to connect
 * to DSE clusters secured with the DseAuthenticator.
 * @param {String} username The username; cannot be <code>null</code>.
 * @param {String} password The password; cannot be <code>null</code>.
 * @param {String} [authorizationId] The optional authorization ID. Providing an authorization ID allows the currently
 * authenticated user to act as a different user (a.k.a. proxy authentication).
 * @extends AuthProvider
 * @alias module:auth~DsePlainTextAuthProvider
 * @example
 * const client = new cassandra.Client({
 *   contactPoints: ['h1', 'h2'],
 *   authProvider: new cassandra.auth.DsePlainTextAuthProvider('user', 'p@ssword1');
 * });
 * @constructor
 */

function DsePlainTextAuthProvider$2(username, password, authorizationId) {
  if (typeof username !== 'string' || typeof password !== 'string') {
    // Validate for null and undefined
    throw new TypeError('Username and password must be a string');
  }

  this.username = username;
  this.password = password;
  this.authorizationId = authorizationId;
}

util$s.inherits(DsePlainTextAuthProvider$2, AuthProvider$2);
/**
 * Returns an Authenticator instance to be used by the driver when connecting to a host.
 * @param {String} endpoint The IP address and port number in the format ip:port.
 * @param {String} name Authenticator name.
 * @override
 * @returns {Authenticator}
 */

DsePlainTextAuthProvider$2.prototype.newAuthenticator = function (endpoint, name) {
  return new PlainTextAuthenticator$1(name, this.username, this.password, this.authorizationId);
};
/**
 * @param {String} authenticatorName
 * @param {String} authenticatorId
 * @param {String} password
 * @param {String} authorizationId
 * @extends BaseDseAuthenticator
 * @constructor
 * @private
 */


function PlainTextAuthenticator$1(authenticatorName, authenticatorId, password, authorizationId) {
  BaseDseAuthenticator.call(this, authenticatorName);
  this.authenticatorId = utils$D.allocBufferFromString(authenticatorId);
  this.password = utils$D.allocBufferFromString(password);
  this.authorizationId = utils$D.allocBufferFromString(authorizationId || '');
}

util$s.inherits(PlainTextAuthenticator$1, BaseDseAuthenticator);
/** @override */

PlainTextAuthenticator$1.prototype.getMechanism = function () {
  return mechanism;
};
/** @override */


PlainTextAuthenticator$1.prototype.getInitialServerChallenge = function () {
  return utils$D.allocBufferFromString(initialServerChallenge);
};
/** @override */


PlainTextAuthenticator$1.prototype.evaluateChallenge = function (challenge, callback) {
  if (!challenge || challenge.toString() !== initialServerChallenge) {
    return callback(new Error('Incorrect SASL challenge from server'));
  } // The SASL plain text format is authorizationId 0 username 0 password


  callback(null, Buffer.concat([this.authorizationId, separatorBuffer, this.authenticatorId, separatorBuffer, this.password]));
};

var dsePlainTextAuthProvider = DsePlainTextAuthProvider$2;

var AuthProvider$1 = provider$1.AuthProvider,
    Authenticator$1 = provider$1.Authenticator;
var PlainTextAuthenticator = plainTextAuthProvider.PlainTextAuthenticator;
var errors$j = errors$s;
var dseAuthenticator = 'com.datastax.bdp.cassandra.auth.DseAuthenticator';
/**
 * Internal authentication provider that is used when no provider has been set by the user.
 * @ignore
 */

var NoAuthProvider$3 = /*#__PURE__*/function (_AuthProvider) {
  _inherits(NoAuthProvider, _AuthProvider);

  var _super = _createSuper(NoAuthProvider);

  function NoAuthProvider() {
    _classCallCheck(this, NoAuthProvider);

    return _super.apply(this, arguments);
  }

  _createClass(NoAuthProvider, [{
    key: "newAuthenticator",
    value: function newAuthenticator(endpoint, name) {
      if (name === dseAuthenticator) {
        // Try to use transitional mode
        return new TransitionalModePlainTextAuthenticator();
      } // Use an authenticator that doesn't allow auth flow


      return new NoAuthAuthenticator(endpoint);
    }
  }]);

  return NoAuthProvider;
}(AuthProvider$1);
/**
 * An authenticator throws an error when authentication flow is started.
 * @ignore
 */


var NoAuthAuthenticator = /*#__PURE__*/function (_Authenticator) {
  _inherits(NoAuthAuthenticator, _Authenticator);

  var _super2 = _createSuper(NoAuthAuthenticator);

  function NoAuthAuthenticator(endpoint) {
    var _this;

    _classCallCheck(this, NoAuthAuthenticator);

    _this = _super2.call(this);
    _this.endpoint = endpoint;
    return _this;
  }

  _createClass(NoAuthAuthenticator, [{
    key: "initialResponse",
    value: function initialResponse(callback) {
      callback(new errors$j.AuthenticationError("Host ".concat(this.endpoint, " requires authentication, but no authenticator found in the options")));
    }
  }]);

  return NoAuthAuthenticator;
}(Authenticator$1);
/**
 * Authenticator that accounts for DSE authentication configured with transitional mode: normal.
 *
 * In this situation, the client is allowed to connect without authentication, but DSE
 * would still send an AUTHENTICATE response. This Authenticator handles this situation
 * by sending back a dummy credential.
 */


var TransitionalModePlainTextAuthenticator = /*#__PURE__*/function (_PlainTextAuthenticat) {
  _inherits(TransitionalModePlainTextAuthenticator, _PlainTextAuthenticat);

  var _super3 = _createSuper(TransitionalModePlainTextAuthenticator);

  function TransitionalModePlainTextAuthenticator() {
    _classCallCheck(this, TransitionalModePlainTextAuthenticator);

    return _super3.call(this, '', '');
  }

  return _createClass(TransitionalModePlainTextAuthenticator);
}(PlainTextAuthenticator);

var noAuthProvider = NoAuthProvider$3;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * DSE Authentication module.
 * <p>
 *   Contains the classes used for connecting to a DSE cluster secured with DseAuthenticator.
 * </p>
 * @module auth
 */


var Authenticator = provider$1.Authenticator,
    AuthProvider = provider$1.AuthProvider;
var PlainTextAuthProvider = plainTextAuthProvider.PlainTextAuthProvider;
var DseGssapiAuthProvider = dseGssapiAuthProvider;
var DsePlainTextAuthProvider$1 = dsePlainTextAuthProvider;
var NoAuthProvider$2 = noAuthProvider;
var auth$1 = {
  Authenticator: Authenticator,
  AuthProvider: AuthProvider,
  DseGssapiAuthProvider: DseGssapiAuthProvider,
  DsePlainTextAuthProvider: DsePlainTextAuthProvider$1,
  NoAuthProvider: NoAuthProvider$2,
  PlainTextAuthProvider: PlainTextAuthProvider
};

var _coreConnectionsPerHo, _coreConnectionsPerHo2;

var util$r = require$$0__default$1["default"];
var policies$1 = policies$2;
var types$s = types$u;
var utils$C = utils$V;
var tracker = tracker$1;
var metrics = metrics$1;
var auth = auth$1;
/** Core connections per host for protocol versions 1 and 2 */

var coreConnectionsPerHostV2 = (_coreConnectionsPerHo = {}, _defineProperty(_coreConnectionsPerHo, types$s.distance.local, 2), _defineProperty(_coreConnectionsPerHo, types$s.distance.remote, 1), _defineProperty(_coreConnectionsPerHo, types$s.distance.ignored, 0), _coreConnectionsPerHo);
/** Core connections per host for protocol version 3 and above */

var coreConnectionsPerHostV3 = (_coreConnectionsPerHo2 = {}, _defineProperty(_coreConnectionsPerHo2, types$s.distance.local, 1), _defineProperty(_coreConnectionsPerHo2, types$s.distance.remote, 1), _defineProperty(_coreConnectionsPerHo2, types$s.distance.ignored, 0), _coreConnectionsPerHo2);
/** Default maxRequestsPerConnection value for protocol v1 and v2 */

var maxRequestsPerConnectionV2 = 128;
/** Default maxRequestsPerConnection value for protocol v3+ */

var maxRequestsPerConnectionV3 = 2048;
var continuousPageUnitBytes = 'bytes';
var continuousPageDefaultSize = 5000;
var continuousPageDefaultHighWaterMark = 10000;
/**
 * @returns {ClientOptions}
 */

function defaultOptions$2() {
  return {
    policies: {
      addressResolution: policies$1.defaultAddressTranslator(),
      loadBalancing: policies$1.defaultLoadBalancingPolicy(),
      reconnection: policies$1.defaultReconnectionPolicy(),
      retry: policies$1.defaultRetryPolicy(),
      speculativeExecution: policies$1.defaultSpeculativeExecutionPolicy(),
      timestampGeneration: policies$1.defaultTimestampGenerator()
    },
    queryOptions: {
      fetchSize: 5000,
      prepare: false,
      captureStackTrace: false
    },
    protocolOptions: {
      port: 9042,
      maxSchemaAgreementWaitSeconds: 10,
      maxVersion: 0,
      noCompact: false
    },
    pooling: {
      heartBeatInterval: 30000,
      warmup: true
    },
    socketOptions: {
      connectTimeout: 5000,
      defunctReadTimeoutThreshold: 64,
      keepAlive: true,
      keepAliveDelay: 0,
      readTimeout: 12000,
      tcpNoDelay: true,
      coalescingThreshold: 65536
    },
    authProvider: null,
    requestTracker: null,
    metrics: new metrics.DefaultMetrics(),
    maxPrepared: 500,
    refreshSchemaDelay: 1000,
    isMetadataSyncEnabled: true,
    prepareOnAllHosts: true,
    rePrepareOnUp: true,
    encoding: {
      copyBuffer: true,
      useUndefinedAsUnset: true
    },
    monitorReporting: {
      enabled: true
    }
  };
}
/**
 * Extends and validates the user options
 * @param {Object} [baseOptions] The source object instance that will be overridden
 * @param {Object} userOptions
 * @returns {Object}
 */


function extend(baseOptions, userOptions) {
  if (arguments.length === 1) {
    userOptions = arguments[0];
    baseOptions = {};
  }

  var options = utils$C.deepExtend(baseOptions, defaultOptions$2(), userOptions);

  if (!options.cloud) {
    if (!Array.isArray(options.contactPoints) || options.contactPoints.length === 0) {
      throw new TypeError('Contacts points are not defined.');
    }

    for (var i = 0; i < options.contactPoints.length; i++) {
      var hostName = options.contactPoints[i];

      if (!hostName) {
        throw new TypeError(util$r.format('Contact point %s (%s) is not a valid host name, ' + 'the following values are valid contact points: ipAddress, hostName or ipAddress:port', i, hostName));
      }
    }

    options.sni = undefined;
  } else {
    validateCloudOptions(options);
  }

  if (!options.logEmitter) {
    options.logEmitter = function () {};
  }

  if (!options.queryOptions) {
    throw new TypeError('queryOptions not defined in options');
  }

  if (options.requestTracker !== null && !(options.requestTracker instanceof tracker.RequestTracker)) {
    throw new TypeError('requestTracker must be an instance of RequestTracker');
  }

  if (!(options.metrics instanceof metrics.ClientMetrics)) {
    throw new TypeError('metrics must be an instance of ClientMetrics');
  }

  validatePoliciesOptions(options.policies);
  validateProtocolOptions(options.protocolOptions);
  validateSocketOptions(options.socketOptions);
  validateAuthenticationOptions(options);
  options.encoding = options.encoding || {};
  validateEncodingOptions(options.encoding);

  if (options.profiles && !Array.isArray(options.profiles)) {
    throw new TypeError('profiles must be an Array of ExecutionProfile instances');
  }

  validateApplicationInfo(options);
  validateMonitorReporting(options);
  return options;
}
/**
 * Validates the options to connect to a cloud instance.
 * @private
 */


function validateCloudOptions(options) {
  var bundle = options.cloud.secureConnectBundle; // eslint-disable-next-line no-undef

  if (!(typeof bundle === 'string' || typeof URL !== 'undefined' && bundle instanceof URL)) {
    throw new TypeError('secureConnectBundle in cloud options must be of type string');
  }

  if (options.contactPoints) {
    throw new TypeError('Contact points can not be defined when cloud settings are provided');
  }

  if (options.sslOptions) {
    throw new TypeError('SSL options can not be defined when cloud settings are provided');
  }
}
/**
 * Validates the policies from the client options.
 * @param {ClientOptions.policies} policiesOptions
 * @private
 */


function validatePoliciesOptions(policiesOptions) {
  if (!policiesOptions) {
    throw new TypeError('policies not defined in options');
  }

  if (!(policiesOptions.loadBalancing instanceof policies$1.loadBalancing.LoadBalancingPolicy)) {
    throw new TypeError('Load balancing policy must be an instance of LoadBalancingPolicy');
  }

  if (!(policiesOptions.reconnection instanceof policies$1.reconnection.ReconnectionPolicy)) {
    throw new TypeError('Reconnection policy must be an instance of ReconnectionPolicy');
  }

  if (!(policiesOptions.retry instanceof policies$1.retry.RetryPolicy)) {
    throw new TypeError('Retry policy must be an instance of RetryPolicy');
  }

  if (!(policiesOptions.addressResolution instanceof policies$1.addressResolution.AddressTranslator)) {
    throw new TypeError('Address resolution policy must be an instance of AddressTranslator');
  }

  if (policiesOptions.timestampGeneration !== null && !(policiesOptions.timestampGeneration instanceof policies$1.timestampGeneration.TimestampGenerator)) {
    throw new TypeError('Timestamp generation policy must be an instance of TimestampGenerator');
  }
}
/**
 * Validates the protocol options.
 * @param {ClientOptions.protocolOptions} protocolOptions
 * @private
 */


function validateProtocolOptions(protocolOptions) {
  if (!protocolOptions) {
    throw new TypeError('protocolOptions not defined in options');
  }

  var version = protocolOptions.maxVersion;

  if (version && (typeof version !== 'number' || !types$s.protocolVersion.isSupported(version))) {
    throw new TypeError(util$r.format('protocolOptions.maxVersion provided (%s) is invalid', version));
  }
}
/**
 * Validates the socket options.
 * @param {ClientOptions.socketOptions} socketOptions
 * @private
 */


function validateSocketOptions(socketOptions) {
  if (!socketOptions) {
    throw new TypeError('socketOptions not defined in options');
  }

  if (typeof socketOptions.readTimeout !== 'number') {
    throw new TypeError('socketOptions.readTimeout must be a Number');
  }

  if (typeof socketOptions.coalescingThreshold !== 'number' || socketOptions.coalescingThreshold <= 0) {
    throw new TypeError('socketOptions.coalescingThreshold must be a positive Number');
  }
}
/**
 * Validates authentication provider and credentials.
 * @param {ClientOptions} options
 * @private
 */


function validateAuthenticationOptions(options) {
  if (!options.authProvider) {
    var credentials = options.credentials;

    if (credentials) {
      if (typeof credentials.username !== 'string' || typeof credentials.password !== 'string') {
        throw new TypeError('credentials username and password must be a string');
      }

      options.authProvider = new auth.PlainTextAuthProvider(credentials.username, credentials.password);
    } else {
      options.authProvider = new auth.NoAuthProvider();
    }
  } else if (!(options.authProvider instanceof auth.AuthProvider)) {
    throw new TypeError('options.authProvider must be an instance of AuthProvider');
  }
}
/**
 * Validates the encoding options.
 * @param {ClientOptions.encoding} encodingOptions
 * @private
 */


function validateEncodingOptions(encodingOptions) {
  if (encodingOptions.map) {
    var mapConstructor = encodingOptions.map;

    if (typeof mapConstructor !== 'function' || typeof mapConstructor.prototype.forEach !== 'function' || typeof mapConstructor.prototype.set !== 'function') {
      throw new TypeError('Map constructor not valid');
    }
  }

  if (encodingOptions.set) {
    var setConstructor = encodingOptions.set;

    if (typeof setConstructor !== 'function' || typeof setConstructor.prototype.forEach !== 'function' || typeof setConstructor.prototype.add !== 'function') {
      throw new TypeError('Set constructor not valid');
    }
  }

  if ((encodingOptions.useBigIntAsLong || encodingOptions.useBigIntAsVarint) && typeof BigInt === 'undefined') {
    throw new TypeError('BigInt is not supported by the JavaScript engine');
  }
}

function validateApplicationInfo(options) {
  function validateString(key) {
    var str = options[key];

    if (str !== null && str !== undefined && typeof str !== 'string') {
      throw new TypeError("".concat(key, " should be a String"));
    }
  }

  validateString('applicationName');
  validateString('applicationVersion');

  if (options.id !== null && options.id !== undefined && !(options.id instanceof types$s.Uuid)) {
    throw new TypeError('Client id must be a Uuid');
  }
}

function validateMonitorReporting(options) {
  var o = options.monitorReporting;

  if (o === null || _typeof(o) !== 'object') {
    throw new TypeError("Monitor reporting must be an object, obtained: ".concat(o));
  }
}
/**
 * Sets the default options that depend on the protocol version and other metadata.
 * @param {Client} client
 */


function setMetadataDependent(client) {
  var version = client.controlConnection.protocolVersion;
  var coreConnectionsPerHost = coreConnectionsPerHostV3;
  var maxRequestsPerConnection = maxRequestsPerConnectionV3;

  if (!types$s.protocolVersion.uses2BytesStreamIds(version)) {
    coreConnectionsPerHost = coreConnectionsPerHostV2;
    maxRequestsPerConnection = maxRequestsPerConnectionV2;
  }

  if (client.options.queryOptions.consistency === undefined) {
    client.options.queryOptions.consistency = client.metadata.isDbaas() ? types$s.consistencies.localQuorum : types$s.consistencies.localOne;
  }

  client.options.pooling = utils$C.deepExtend({}, {
    coreConnectionsPerHost: coreConnectionsPerHost,
    maxRequestsPerConnection: maxRequestsPerConnection
  }, client.options.pooling);
}

clientOptions$3.extend = extend;
clientOptions$3.defaultOptions = defaultOptions$2;
clientOptions$3.coreConnectionsPerHostV2 = coreConnectionsPerHostV2;
clientOptions$3.coreConnectionsPerHostV3 = coreConnectionsPerHostV3;
clientOptions$3.maxRequestsPerConnectionV2 = maxRequestsPerConnectionV2;
clientOptions$3.maxRequestsPerConnectionV3 = maxRequestsPerConnectionV3;
clientOptions$3.setMetadataDependent = setMetadataDependent;
clientOptions$3.continuousPageUnitBytes = continuousPageUnitBytes;
clientOptions$3.continuousPageDefaultSize = continuousPageDefaultSize;
clientOptions$3.continuousPageDefaultHighWaterMark = continuousPageDefaultHighWaterMark;

var utils$B = utils$V;
var types$r = types$u;
var promiseUtils$c = promiseUtils$e;
/**
 * Creates a new instance of {@link ExecutionProfile}.
 * @classdesc
 * Represents a set configurations to be used in a statement execution to be used for a single {@link Client} instance.
 * <p>
 *   An {@link ExecutionProfile} instance should not be shared across different {@link Client} instances.
 * </p>
 * @param {String} name Name of the execution profile.
 * <p>
 *   Use <code>'default'</code> to specify that the new instance should be the default {@link ExecutionProfile} if no
 *   profile is specified in the execution.
 * </p>
 * @param {Object} [options] Profile options, when any of the options is not specified the {@link Client} will the use
 * the ones defined in the default profile.
 * @param {Number} [options.consistency] The consistency level to use for this profile.
 * @param {LoadBalancingPolicy} [options.loadBalancing] The load-balancing policy to use for this profile.
 * @param {Number} [options.readTimeout] The client per-host request timeout to use for this profile.
 * @param {RetryPolicy} [options.retry] The retry policy to use for this profile.
 * @param {Number} [options.serialConsistency] The serial consistency level to use for this profile.
 * @param {Object} [options.graphOptions]
 * @param {String} [options.graphOptions.language] The graph language to use for graph queries.
 * <p>
 *   Note that this setting should normally be <code>undefined</code> or set by a utility method and it's not expected
 *   to be defined manually by the user.
 * </p>
 * @param {String} [options.graphOptions.results] The protocol to use for serializing and deserializing graph results.
 * <p>
 *   Note that this setting should normally be <code>undefined</code> or set by a utility method and it's not expected
 *   to be defined manually by the user.
 * </p>
 * @param {String} [options.graphOptions.name] The graph name to use for graph queries.
 * @param {Number} [options.graphOptions.readConsistency] The consistency level to use for graph read queries.
 * @param {String} [options.graphOptions.source] The graph traversal source name to use for graph queries.
 * @param {Number} [options.graphOptions.writeConsistency] The consistency level to use for graph write queries.
 * @param {LoadBalancingPolicy} [options.loadBalancing] The load-balancing policy to use for this profile.
 * @param {Number} [options.readTimeout] The client per-host request timeout to use for this profile.
 * @param {RetryPolicy} [options.retry] The retry policy to use for this profile.
 * @param {Number} [options.serialConsistency] The serial consistency level to use for this profile.
 * @example
 * const { Client, ExecutionProfile } = require('cassandra-driver');
 * const client = new Client({
 *   contactPoints: ['host1', 'host2'],
 *   profiles: [
 *     new ExecutionProfile('metrics-oltp', {
 *       consistency: consistency.localQuorum,
 *       retry: myRetryPolicy
 *     })
 *   ]
 * });
 *
 * client.execute(query, params, { executionProfile: 'metrics-oltp' }, callback);
 * @constructor
 */

function ExecutionProfile(name, options) {
  if (typeof name !== 'string') {
    throw new TypeError('Execution profile name must be a string');
  }

  options = options || utils$B.emptyObject;
  var graphOptions = options.graphOptions || utils$B.emptyObject;
  /**
   * Name of the execution profile.
   * @type {String}
   */

  this.name = name;
  /**
   * Consistency level.
   * @type {Number}
   */

  this.consistency = options.consistency;
  /**
   * Load-balancing policy
   * @type {LoadBalancingPolicy}
   */

  this.loadBalancing = options.loadBalancing;
  /**
   * Client read timeout.
   * @type {Number}
   */

  this.readTimeout = options.readTimeout;
  /**
   * Retry policy.
   * @type {RetryPolicy}
   */

  this.retry = options.retry;
  /**
   * Serial consistency level.
   * @type {Number}
   */

  this.serialConsistency = options.serialConsistency;
  /**
   * The graph options for this profile.
   * @type {Object}
   * @property {String} language The graph language.
   * @property {String} name The graph name.
   * @property {String} readConsistency The consistency to use for graph write queries.
   * @property {String} source The graph traversal source.
   * @property {String} writeConsistency The consistency to use for graph write queries.
   */

  this.graphOptions = {
    language: graphOptions.language,
    results: graphOptions.results,
    name: graphOptions.name,
    readConsistency: graphOptions.readConsistency,
    source: graphOptions.source,
    writeConsistency: graphOptions.writeConsistency
  };
}
/**
 * Contains the logic to handle the different execution profiles of a {@link Client}.
 * @ignore
 */


var ProfileManager$1 = /*#__PURE__*/function () {
  /**
   * @param {ClientOptions} options
   */
  function ProfileManager(options) {
    _classCallCheck(this, ProfileManager);

    this._profiles = options.profiles || [];
    this._defaultConfiguredRetryPolicy = undefined;

    this._setDefault(options); // A array of unique load balancing policies


    this._loadBalancingPolicies = []; // A dictionary of name keys and profile values

    this._profilesMap = {}; // A dictionary of name keys and custom payload dictionaries as values

    this._customPayloadCache = {}; // A dictionary of name keys and graph options as values

    this._graphOptionsCache = {};

    this._profiles.forEach(function (p) {
      this._profilesMap[p.name] = p; // Set required properties

      p.loadBalancing = p.loadBalancing || this._defaultProfile.loadBalancing; // Using array indexOf is not very efficient (O(n)) but the amount of profiles should be limited
      // and a handful of load-balancing policies (no hashcode for load-Balancing policies)

      if (this._loadBalancingPolicies.indexOf(p.loadBalancing) === -1) {
        this._loadBalancingPolicies.push(p.loadBalancing);
      }

      return p;
    }, this);
  }
  /**
   * @param {Client} client
   * @param {HostMap} hosts
   */


  _createClass(ProfileManager, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(client, hosts) {
        var _iterator, _step, _loop;

        return regeneratorRuntime.wrap(function _callee$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _iterator = _createForOfIteratorHelper(this._loadBalancingPolicies);
                _context2.prev = 1;
                _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {
                  var lbp;
                  return regeneratorRuntime.wrap(function _loop$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          lbp = _step.value;
                          _context.next = 3;
                          return promiseUtils$c.fromCallback(function (callback) {
                            return lbp.init(client, hosts, callback);
                          });

                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _loop);
                });

                _iterator.s();

              case 4:
                if ((_step = _iterator.n()).done) {
                  _context2.next = 8;
                  break;
                }

                return _context2.delegateYield(_loop(), "t0", 6);

              case 6:
                _context2.next = 4;
                break;

              case 8:
                _context2.next = 13;
                break;

              case 10:
                _context2.prev = 10;
                _context2.t1 = _context2["catch"](1);

                _iterator.e(_context2.t1);

              case 13:
                _context2.prev = 13;

                _iterator.f();

                return _context2.finish(13);

              case 16:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee, this, [[1, 10, 13, 16]]);
      }));

      function init(_x, _x2) {
        return _init.apply(this, arguments);
      }

      return init;
    }()
    /**
     * Uses the load-balancing policies to get the relative distance to the host and return the closest one.
     * @param {Host} host
     */

  }, {
    key: "getDistance",
    value: function getDistance(host) {
      var distance = types$r.distance.ignored; // this is performance critical: we can't use any other language features than for-loop :(

      for (var i = 0; i < this._loadBalancingPolicies.length; i++) {
        var d = this._loadBalancingPolicies[i].getDistance(host);

        if (d < distance) {
          distance = d;

          if (distance === types$r.distance.local) {
            break;
          }
        }
      }

      host.setDistance(distance);
      return distance;
    }
    /**
     * @param {String|ExecutionProfile} name
     * @returns {ExecutionProfile|undefined} It returns the execution profile by name or the default profile when name is
     * undefined. It returns undefined when the profile does not exist.
     */

  }, {
    key: "getProfile",
    value: function getProfile(name) {
      if (name instanceof ExecutionProfile) {
        return name;
      }

      return this._profilesMap[name || 'default'];
    }
    /** @returns {ExecutionProfile} */

  }, {
    key: "getDefault",
    value: function getDefault() {
      return this._defaultProfile;
    }
    /** @returns {LoadBalancingPolicy} */

  }, {
    key: "getDefaultLoadBalancing",
    value: function getDefaultLoadBalancing() {
      return this._defaultProfile.loadBalancing;
    }
    /**
     * Gets the cached default graph options for a given profile. If it doesn't exist, it creates new options using the
     * handler and inserts it into the cache
     * @param {ExecutionProfile} profile
     * @param {Function} createHandler
     */

  }, {
    key: "getOrCreateGraphOptions",
    value: function getOrCreateGraphOptions(profile, createHandler) {
      var graphOptions = this._graphOptionsCache[profile.name];

      if (!graphOptions) {
        graphOptions = this._graphOptionsCache[profile.name] = createHandler();
      }

      return graphOptions;
    }
    /**
     * @private
     * @param {ClientOptions} options
     */

  }, {
    key: "_setDefault",
    value: function _setDefault(options) {
      this._defaultProfile = this._profiles.filter(function (p) {
        return p.name === 'default';
      })[0];

      if (!this._defaultProfile) {
        this._profiles.push(this._defaultProfile = new ExecutionProfile('default'));
      } // Store the default configured retry policy


      this._defaultConfiguredRetryPolicy = this._defaultProfile.retry; // Set the required properties

      this._defaultProfile.loadBalancing = this._defaultProfile.loadBalancing || options.policies.loadBalancing;
      this._defaultProfile.retry = this._defaultProfile.retry || options.policies.retry;
    }
    /**
     * Gets all the execution profiles currently defined.
     * @returns {Array.<ExecutionProfile>}
     */

  }, {
    key: "getAll",
    value: function getAll() {
      return this._profiles;
    }
  }, {
    key: "getDefaultConfiguredRetryPolicy",
    value: function getDefaultConfiguredRetryPolicy() {
      return this._defaultConfiguredRetryPolicy;
    }
  }]);

  return ProfileManager;
}();

var executionProfile = {
  ProfileManager: ProfileManager$1,
  ExecutionProfile: ExecutionProfile
};

var requests$7 = {};

var events$8 = require$$0__default$2["default"];
var types$q = types$u;
var utils$A = utils$V;
var FrameHeader$1 = types$q.FrameHeader;
/**
 * Contains the logic to write all the different types to the frame.
 */

var FrameWriter$1 = /*#__PURE__*/function () {
  /**
   * Creates a new instance of FrameWriter.
   * @param {Number} opcode
   */
  function FrameWriter(opcode) {
    _classCallCheck(this, FrameWriter);

    if (!opcode) {
      throw new Error('Opcode not provided');
    }

    this.buffers = [];
    this.opcode = opcode;
    this.bodyLength = 0;
  }

  _createClass(FrameWriter, [{
    key: "add",
    value: function add(buf) {
      this.buffers.push(buf);
      this.bodyLength += buf.length;
    }
  }, {
    key: "writeShort",
    value: function writeShort(num) {
      var buf = utils$A.allocBufferUnsafe(2);
      buf.writeUInt16BE(num, 0);
      this.add(buf);
    }
  }, {
    key: "writeInt",
    value: function writeInt(num) {
      var buf = utils$A.allocBufferUnsafe(4);
      buf.writeInt32BE(num, 0);
      this.add(buf);
    }
    /** @param {Long} num */

  }, {
    key: "writeLong",
    value: function writeLong(num) {
      this.add(types$q.Long.toBuffer(num));
    }
    /**
     * Writes bytes according to Cassandra <int byteLength><bytes>
     * @param {Buffer|null|types.unset} bytes
     */

  }, {
    key: "writeBytes",
    value: function writeBytes(bytes) {
      if (bytes === null) {
        //Only the length buffer containing -1
        this.writeInt(-1);
        return;
      }

      if (bytes === types$q.unset) {
        this.writeInt(-2);
        return;
      } //Add the length buffer


      this.writeInt(bytes.length); //Add the actual buffer

      this.add(bytes);
    }
    /**
     * Writes a buffer according to Cassandra protocol: bytes.length (2) + bytes
     * @param {Buffer} bytes
     */

  }, {
    key: "writeShortBytes",
    value: function writeShortBytes(bytes) {
      if (bytes === null) {
        //Only the length buffer containing -1
        this.writeShort(-1);
        return;
      } //Add the length buffer


      this.writeShort(bytes.length); //Add the actual buffer

      this.add(bytes);
    }
    /**
     * Writes a single byte
     * @param {Number} num Value of the byte, a number between 0 and 255.
     */

  }, {
    key: "writeByte",
    value: function writeByte(num) {
      this.add(utils$A.allocBufferFromArray([num]));
    }
  }, {
    key: "writeString",
    value: function writeString(str) {
      if (typeof str === "undefined") {
        throw new Error("can not write undefined");
      }

      var len = Buffer.byteLength(str, 'utf8');
      var buf = utils$A.allocBufferUnsafe(2 + len);
      buf.writeUInt16BE(len, 0);
      buf.write(str, 2, buf.length - 2, 'utf8');
      this.add(buf);
    }
  }, {
    key: "writeLString",
    value: function writeLString(str) {
      var len = Buffer.byteLength(str, 'utf8');
      var buf = utils$A.allocBufferUnsafe(4 + len);
      buf.writeInt32BE(len, 0);
      buf.write(str, 4, buf.length - 4, 'utf8');
      this.add(buf);
    }
  }, {
    key: "writeStringList",
    value: function writeStringList(values) {
      this.writeShort(values.length);
      values.forEach(this.writeString, this);
    }
  }, {
    key: "writeCustomPayload",
    value: function writeCustomPayload(payload) {
      var _this = this;

      var keys = Object.keys(payload);
      this.writeShort(keys.length);
      keys.forEach(function (k) {
        _this.writeString(k);

        _this.writeBytes(payload[k]);
      });
    }
  }, {
    key: "writeStringMap",
    value: function writeStringMap(map) {
      var keys = [];

      for (var k in map) {
        if (map.hasOwnProperty(k)) {
          keys.push(k);
        }
      }

      this.writeShort(keys.length);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        this.writeString(key);
        this.writeString(map[key]);
      }
    }
    /**
     * @param {Number} version
     * @param {Number} streamId
     * @param {Number} [flags] Header flags
     * @returns {Buffer}
     * @throws {TypeError}
     */

  }, {
    key: "write",
    value: function write(version, streamId, flags) {
      var header = new FrameHeader$1(version, flags || 0, streamId, this.opcode, this.bodyLength);
      var headerBuffer = header.toBuffer();
      this.buffers.unshift(headerBuffer);
      return Buffer.concat(this.buffers, headerBuffer.length + this.bodyLength);
    }
  }]);

  return FrameWriter;
}();
/**
 * Represents a queue that process one write at a time (FIFO).
 * @extends {EventEmitter}
 */


var WriteQueue$1 = /*#__PURE__*/function (_events$EventEmitter) {
  _inherits(WriteQueue, _events$EventEmitter);

  var _super = _createSuper(WriteQueue);

  /**
   * Creates a new WriteQueue instance.
   * @param {Socket} netClient
   * @param {Encoder} encoder
   * @param {ClientOptions} options
   */
  function WriteQueue(netClient, encoder, options) {
    var _this2;

    _classCallCheck(this, WriteQueue);

    _this2 = _super.call(this);
    _this2.netClient = netClient;
    _this2.encoder = encoder;
    _this2.isRunning = false;
    /** @type {Array<{operation: OperationState, callback: Function}>} */

    _this2.queue = [];
    _this2.coalescingThreshold = options.socketOptions.coalescingThreshold;
    _this2.error = null;
    _this2.canWrite = true; // Listen to drain event that is going to be fired once
    // the underlying buffer is empty

    netClient.on('drain', function () {
      _this2.canWrite = true;

      _this2.run();
    });
    return _this2;
  }
  /**
   * Enqueues a new request
   * @param {OperationState} operation
   * @param {Function} callback The write callback.
   */


  _createClass(WriteQueue, [{
    key: "push",
    value: function push(operation, callback) {
      var self = this;

      if (this.error) {
        // There was a write error, there is no point in further trying to write to the socket.
        return process.nextTick(function writePushError() {
          callback(self.error);
        });
      }

      this.queue.push({
        operation: operation,
        callback: callback
      });
      this.run();
    }
  }, {
    key: "run",
    value: function run() {
      var _this3 = this;

      if (!this.isRunning && this.canWrite) {
        this.isRunning = true; // Use nextTick to allow the queue to build up on the current phase

        process.nextTick(function () {
          return _this3.process();
        });
      }
    }
  }, {
    key: "process",
    value: function process() {
      var _this4 = this;

      if (this.error) {
        return;
      }

      var buffers = [];
      var callbacks = [];
      var totalLength = 0;

      while (this.queue.length > 0 && totalLength < this.coalescingThreshold) {
        var writeItem = this.queue.shift();

        if (!writeItem.operation.canBeWritten()) {
          // Invoke the write callback with an error that is not going to be yielded to user
          // as the operation has timed out or was cancelled.
          writeItem.callback(new Error('The operation was already cancelled or timeout elapsed'));
          continue;
        }

        var data = void 0;

        try {
          data = writeItem.operation.request.write(this.encoder, writeItem.operation.streamId);
        } catch (err) {
          writeItem.callback(err);
          continue;
        }

        totalLength += data.length;
        buffers.push(data);
        callbacks.push(writeItem.callback);
      }

      if (totalLength === 0) {
        this.isRunning = false;
        return;
      } // We have to invoke the callbacks to avoid race conditions.
      // There is a performance benefit from executing all of them in a loop


      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i]();
      } // Concatenate buffers and write it to the socket
      // Further writes will be throttled until flushed


      this.canWrite = this.netClient.write(Buffer.concat(buffers, totalLength), function (err) {
        if (err) {
          _this4.setWriteError(err);

          return;
        }

        if (_this4.queue.length === 0 || !_this4.canWrite) {
          // It will start running once we get the next message or has drained
          _this4.isRunning = false;
          return;
        } // Allow IO between writes


        setImmediate(function () {
          return _this4.process();
        });
      });
    }
    /**
     * Emits the 'error' event and callbacks items that haven't been written and clears them from the queue.
     * @param err
     */

  }, {
    key: "setWriteError",
    value: function setWriteError(err) {
      err.isSocketError = true;
      this.error = new types$q.DriverError('Socket was closed');
      this.error.isSocketError = true; // Use an special flag for items that haven't been written

      this.error.requestNotWritten = true;
      this.error.innerError = err;
      var q = this.queue; // Not more items can be added to the queue.

      this.queue = utils$A.emptyArray;

      for (var i = 0; i < q.length; i++) {
        var item = q[i]; // Use the error marking that it was not written

        item.callback(this.error);
      }
    }
  }]);

  return WriteQueue;
}(events$8.EventEmitter);

var writers = {
  FrameWriter: FrameWriter$1,
  WriteQueue: WriteQueue$1
};

var utils$z = utils$V;
var types$p = types$u;
var errors$i = errors$s;
var proxyExecuteKey$1 = 'ProxyExecute';
/**
 * A base class that represents a wrapper around the user provided query options with getter methods and proper
 * default values.
 * <p>
 *   Note that getter methods might return <code>undefined</code> when not set on the query options or default
 *  {@link Client} options.
 * </p>
 */

var ExecutionOptions$4 = /*#__PURE__*/function () {
  /**
   * Creates a new instance of {@link ExecutionOptions}.
   */
  function ExecutionOptions() {
    _classCallCheck(this, ExecutionOptions);
  }
  /**
   * Creates an empty instance, where all methods return undefined, used internally.
   * @ignore
   * @return {ExecutionOptions}
   */


  _createClass(ExecutionOptions, [{
    key: "getCaptureStackTrace",
    value:
    /**
     * Determines if the stack trace before the query execution should be maintained.
     * @abstract
     * @returns {Boolean}
     */
    function getCaptureStackTrace() {}
    /**
     * Gets the [Consistency level]{@link module:types~consistencies} to be used for the execution.
     * @abstract
     * @returns {Number}
     */

  }, {
    key: "getConsistency",
    value: function getConsistency() {}
    /**
     * Key-value payload to be passed to the server. On the server side, implementations of QueryHandler can use
     * this data.
     * @abstract
     * @returns {Object}
     */

  }, {
    key: "getCustomPayload",
    value: function getCustomPayload() {}
    /**
     * Gets the amount of rows to retrieve per page.
     * @abstract
     * @returns {Number}
     */

  }, {
    key: "getFetchSize",
    value: function getFetchSize() {}
    /**
     * When a fixed host is set on the query options and the query plan for the load-balancing policy is not used, it
     * gets the host that should handle the query.
     * @returns {Host}
     */

  }, {
    key: "getFixedHost",
    value: function getFixedHost() {}
    /**
     * Gets the type hints for parameters given in the query, ordered as for the parameters.
     * @abstract
     * @returns {Array|Array<Array>}
     */

  }, {
    key: "getHints",
    value: function getHints() {}
    /**
     * Determines whether the driver must retrieve the following result pages automatically.
     * <p>
     *   This setting is only considered by the [Client#eachRow()]{@link Client#eachRow} method.
     * </p>
     * @abstract
     * @returns {Boolean}
     */

  }, {
    key: "isAutoPage",
    value: function isAutoPage() {}
    /**
     * Determines whether its a counter batch. Only valid for [Client#batch()]{@link Client#batch}, it will be ignored by
     * other methods.
     * @abstract
     * @returns {Boolean} A <code>Boolean</code> value, it can't be <code>undefined</code>.
     */

  }, {
    key: "isBatchCounter",
    value: function isBatchCounter() {}
    /**
     * Determines whether the batch should be written to the batchlog. Only valid for
     * [Client#batch()]{@link Client#batch}, it will be ignored by other methods.
     * @abstract
     * @returns {Boolean} A <code>Boolean</code> value, it can't be <code>undefined</code>.
     */

  }, {
    key: "isBatchLogged",
    value: function isBatchLogged() {}
    /**
     * Determines whether the query can be applied multiple times without changing the result beyond the initial
     * application.
     * @abstract
     * @returns {Boolean}
     */

  }, {
    key: "isIdempotent",
    value: function isIdempotent() {}
    /**
     * Determines whether the query must be prepared beforehand.
     * @abstract
     * @returns {Boolean} A <code>Boolean</code> value, it can't be <code>undefined</code>.
     */

  }, {
    key: "isPrepared",
    value: function isPrepared() {}
    /**
     * Determines whether query tracing is enabled for the execution.
     * @abstract
     * @returns {Boolean}
     */

  }, {
    key: "isQueryTracing",
    value: function isQueryTracing() {}
    /**
     * Gets the keyspace for the query when set at query options level.
     * <p>
     *   Note that this method will return <code>undefined</code> when the keyspace is not set at query options level.
     *   It will only return the keyspace name when the user provided a different keyspace than the current
     *   {@link Client} keyspace.
     * </p>
     * @abstract
     * @returns {String}
     */

  }, {
    key: "getKeyspace",
    value: function getKeyspace() {}
    /**
     * Gets the load balancing policy used for this execution.
     * @returns {LoadBalancingPolicy} A <code>LoadBalancingPolicy</code> instance, it can't be <code>undefined</code>.
     */

  }, {
    key: "getLoadBalancingPolicy",
    value: function getLoadBalancingPolicy() {}
    /**
     * Gets the Buffer representing the paging state.
     * @abstract
     * @returns {Buffer}
     */

  }, {
    key: "getPageState",
    value: function getPageState() {}
    /**
     * Internal method that gets the preferred host.
     * @abstract
     * @ignore
     */

  }, {
    key: "getPreferredHost",
    value: function getPreferredHost() {}
    /**
     * Gets the query options as provided to the execution method without setting the default values.
     * @returns {QueryOptions}
     */

  }, {
    key: "getRawQueryOptions",
    value: function getRawQueryOptions() {}
    /**
     * Gets the timeout in milliseconds to be used for the execution per coordinator.
     * <p>
     *   A value of <code>0</code> disables client side read timeout for the execution. Default: <code>undefined</code>.
     * </p>
     * @abstract
     * @returns {Number}
     */

  }, {
    key: "getReadTimeout",
    value: function getReadTimeout() {}
    /**
     * Gets the [retry policy]{@link module:policies/retry} to be used.
     * @abstract
     * @returns {RetryPolicy} A <code>RetryPolicy</code> instance, it can't be <code>undefined</code>.
     */

  }, {
    key: "getRetryPolicy",
    value: function getRetryPolicy() {}
    /**
     * Internal method to obtain the row callback, for "by row" results.
     * @abstract
     * @ignore
     */

  }, {
    key: "getRowCallback",
    value: function getRowCallback() {}
    /**
     * Internal method to get or generate a timestamp for the request execution.
     * @ignore
     * @returns {Long|null}
     */

  }, {
    key: "getOrGenerateTimestamp",
    value: function getOrGenerateTimestamp() {}
    /**
     * Gets the index of the parameters that are part of the partition key to determine the routing.
     * @abstract
     * @ignore
     * @returns {Array}
     */

  }, {
    key: "getRoutingIndexes",
    value: function getRoutingIndexes() {}
    /**
     * Gets the partition key(s) to determine which coordinator should be used for the query.
     * @abstract
     * @returns {Buffer|Array<Buffer>}
     */

  }, {
    key: "getRoutingKey",
    value: function getRoutingKey() {}
    /**
     * Gets the array of the parameters names that are part of the partition key to determine the
     * routing. Only valid for non-prepared requests.
     * @abstract
     * @ignore
     */

  }, {
    key: "getRoutingNames",
    value: function getRoutingNames() {}
    /**
     * Gets the the consistency level to be used for the serial phase of conditional updates.
     * @abstract
     * @returns {Number}
     */

  }, {
    key: "getSerialConsistency",
    value: function getSerialConsistency() {}
    /**
     * Gets the provided timestamp for the execution in microseconds from the unix epoch (00:00:00, January 1st, 1970).
     * <p>When a timestamp generator is used, this method returns <code>undefined</code>.</p>
     * @abstract
     * @returns {Number|Long|undefined|null}
     */

  }, {
    key: "getTimestamp",
    value: function getTimestamp() {}
    /**
     * @param {Array} hints
     * @abstract
     * @ignore
     */

  }, {
    key: "setHints",
    value: function setHints(hints) {}
    /**
     * Sets the keyspace for the execution.
     * @ignore
     * @abstract
     * @param {String} keyspace
     */

  }, {
    key: "setKeyspace",
    value: function setKeyspace(keyspace) {}
    /**
     * @abstract
     * @ignore
     */

  }, {
    key: "setPageState",
    value: function setPageState() {}
    /**
     * Internal method that sets the preferred host.
     * @abstract
     * @ignore
     */

  }, {
    key: "setPreferredHost",
    value: function setPreferredHost() {}
    /**
     * Sets the index of the parameters that are part of the partition key to determine the routing.
     * @param {Array} routingIndexes
     * @abstract
     * @ignore
     */

  }, {
    key: "setRoutingIndexes",
    value: function setRoutingIndexes(routingIndexes) {}
    /**
     * Sets the routing key.
     * @abstract
     * @ignore
     */

  }, {
    key: "setRoutingKey",
    value: function setRoutingKey(value) {}
  }], [{
    key: "empty",
    value: function empty() {
      return new ExecutionOptions();
    }
  }]);

  return ExecutionOptions;
}();
/**
 * Internal implementation of {@link ExecutionOptions} that uses the value from the client options and execution
 * profile into account.
 * @ignore
 */


var DefaultExecutionOptions$2 = /*#__PURE__*/function (_ExecutionOptions) {
  _inherits(DefaultExecutionOptions, _ExecutionOptions);

  var _super = _createSuper(DefaultExecutionOptions);

  /**
   * Creates a new instance of {@link ExecutionOptions}.
   * @param {QueryOptions} queryOptions
   * @param {Client} client
   * @param {Function|null} rowCallback
   */
  function DefaultExecutionOptions(queryOptions, client, rowCallback) {
    var _this;

    _classCallCheck(this, DefaultExecutionOptions);

    _this = _super.call(this);
    _this._queryOptions = queryOptions;
    _this._rowCallback = rowCallback;
    _this._routingKey = _this._queryOptions.routingKey;
    _this._hints = _this._queryOptions.hints;
    _this._keyspace = _this._queryOptions.keyspace;
    _this._routingIndexes = _this._queryOptions.routingIndexes;
    _this._pageState = typeof _this._queryOptions.pageState === 'string' ? utils$z.allocBufferFromString(_this._queryOptions.pageState, 'hex') : _this._queryOptions.pageState;
    _this._preferredHost = null;
    _this._client = client;
    _this._defaultQueryOptions = client.options.queryOptions;
    _this._profile = client.profileManager.getProfile(_this._queryOptions.executionProfile); // Build a custom payload object designed for DSE-specific functionality

    _this._customPayload = DefaultExecutionOptions.createCustomPayload(_this._queryOptions, _this._defaultQueryOptions);

    if (!_this._profile) {
      throw new errors$i.ArgumentError("Execution profile \"".concat(_this._queryOptions.executionProfile, "\" not found"));
    }

    return _this;
  }
  /**
   * Creates a payload for given user.
   * @param {QueryOptions} userOptions
   * @param {QueryOptions} defaultQueryOptions
   * @private
   */


  _createClass(DefaultExecutionOptions, [{
    key: "getCaptureStackTrace",
    value: function getCaptureStackTrace() {
      return ifUndefined(this._queryOptions.captureStackTrace, this._defaultQueryOptions.captureStackTrace);
    }
  }, {
    key: "getConsistency",
    value: function getConsistency() {
      return ifUndefined3(this._queryOptions.consistency, this._profile.consistency, this._defaultQueryOptions.consistency);
    }
  }, {
    key: "getCustomPayload",
    value: function getCustomPayload() {
      return this._customPayload;
    }
  }, {
    key: "getFetchSize",
    value: function getFetchSize() {
      return ifUndefined(this._queryOptions.fetchSize, this._defaultQueryOptions.fetchSize);
    }
  }, {
    key: "getFixedHost",
    value: function getFixedHost() {
      return this._queryOptions.host;
    }
  }, {
    key: "getHints",
    value: function getHints() {
      return this._hints;
    }
  }, {
    key: "isAutoPage",
    value: function isAutoPage() {
      return ifUndefined(this._queryOptions.autoPage, this._defaultQueryOptions.autoPage);
    }
  }, {
    key: "isBatchCounter",
    value: function isBatchCounter() {
      return ifUndefined(this._queryOptions.counter, false);
    }
  }, {
    key: "isBatchLogged",
    value: function isBatchLogged() {
      return ifUndefined3(this._queryOptions.logged, this._defaultQueryOptions.logged, true);
    }
  }, {
    key: "isIdempotent",
    value: function isIdempotent() {
      return ifUndefined(this._queryOptions.isIdempotent, this._defaultQueryOptions.isIdempotent);
    }
    /**
     * Determines if the query execution must be prepared beforehand.
     * @return {Boolean}
     */

  }, {
    key: "isPrepared",
    value: function isPrepared() {
      return ifUndefined(this._queryOptions.prepare, this._defaultQueryOptions.prepare);
    }
  }, {
    key: "isQueryTracing",
    value: function isQueryTracing() {
      return ifUndefined(this._queryOptions.traceQuery, this._defaultQueryOptions.traceQuery);
    }
  }, {
    key: "getKeyspace",
    value: function getKeyspace() {
      return this._keyspace;
    }
  }, {
    key: "getLoadBalancingPolicy",
    value: function getLoadBalancingPolicy() {
      return this._profile.loadBalancing;
    }
  }, {
    key: "getOrGenerateTimestamp",
    value: function getOrGenerateTimestamp() {
      var result = this.getTimestamp();

      if (result === undefined) {
        var generator = this._client.options.policies.timestampGeneration;

        if (types$p.protocolVersion.supportsTimestamp(this._client.controlConnection.protocolVersion) && generator) {
          result = generator.next(this._client);
        } else {
          result = null;
        }
      }

      return typeof result === 'number' ? types$p.Long.fromNumber(result) : result;
    }
  }, {
    key: "getPageState",
    value: function getPageState() {
      return this._pageState;
    }
    /**
     * Gets the profile defined by the user or the default profile
     * @internal
     * @ignore
     */

  }, {
    key: "getProfile",
    value: function getProfile() {
      return this._profile;
    }
  }, {
    key: "getRawQueryOptions",
    value: function getRawQueryOptions() {
      return this._queryOptions;
    }
  }, {
    key: "getReadTimeout",
    value: function getReadTimeout() {
      return ifUndefined3(this._queryOptions.readTimeout, this._profile.readTimeout, this._client.options.socketOptions.readTimeout);
    }
  }, {
    key: "getRetryPolicy",
    value: function getRetryPolicy() {
      return ifUndefined3(this._queryOptions.retry, this._profile.retry, this._client.options.policies.retry);
    }
  }, {
    key: "getRoutingIndexes",
    value: function getRoutingIndexes() {
      return this._routingIndexes;
    }
  }, {
    key: "getRoutingKey",
    value: function getRoutingKey() {
      return this._routingKey;
    }
  }, {
    key: "getRoutingNames",
    value: function getRoutingNames() {
      return this._queryOptions.routingNames;
    }
    /**
     * Internal method to obtain the row callback, for "by row" results.
     * @ignore
     */

  }, {
    key: "getRowCallback",
    value: function getRowCallback() {
      return this._rowCallback;
    }
  }, {
    key: "getSerialConsistency",
    value: function getSerialConsistency() {
      return ifUndefined3(this._queryOptions.serialConsistency, this._profile.serialConsistency, this._defaultQueryOptions.serialConsistency);
    }
  }, {
    key: "getTimestamp",
    value: function getTimestamp() {
      return this._queryOptions.timestamp;
    }
    /**
     * Internal property to set the custom payload.
     * @ignore
     * @internal
     * @param {Object} payload
     */

  }, {
    key: "setCustomPayload",
    value: function setCustomPayload(payload) {
      this._customPayload = payload;
    }
    /**
     * @param {Array} hints
     */

  }, {
    key: "setHints",
    value: function setHints(hints) {
      this._hints = hints;
    }
    /**
     * @param {String} keyspace
     */

  }, {
    key: "setKeyspace",
    value: function setKeyspace(keyspace) {
      this._keyspace = keyspace;
    }
    /**
     * @param {Buffer} pageState
     */

  }, {
    key: "setPageState",
    value: function setPageState(pageState) {
      this._pageState = pageState;
    }
    /**
     * @param {Array} routingIndexes
     */

  }, {
    key: "setRoutingIndexes",
    value: function setRoutingIndexes(routingIndexes) {
      this._routingIndexes = routingIndexes;
    }
  }, {
    key: "setRoutingKey",
    value: function setRoutingKey(value) {
      this._routingKey = value;
    }
  }], [{
    key: "createCustomPayload",
    value: function createCustomPayload(userOptions, defaultQueryOptions) {
      var customPayload = userOptions.customPayload || defaultQueryOptions.customPayload;
      var executeAs = userOptions.executeAs || defaultQueryOptions.executeAs;

      if (executeAs) {
        if (!customPayload) {
          customPayload = {};
          customPayload[proxyExecuteKey$1] = utils$z.allocBufferFromString(executeAs);
        } else if (!customPayload[proxyExecuteKey$1]) {
          // Avoid appending to the existing payload object
          customPayload = utils$z.extend({}, customPayload);
          customPayload[proxyExecuteKey$1] = utils$z.allocBufferFromString(executeAs);
        }
      }

      return customPayload;
    }
    /**
     * Creates a new instance {@link ExecutionOptions}, based on the query options.
     * @param {QueryOptions|null} queryOptions
     * @param {Client} client
     * @param {Function|null} [rowCallback]
     * @ignore
     * @return {ExecutionOptions}
     */

  }, {
    key: "create",
    value: function create(queryOptions, client, rowCallback) {
      if (!queryOptions || typeof queryOptions === 'function') {
        // queryOptions can be null/undefined and could be of type function when is an optional parameter
        queryOptions = utils$z.emptyObject;
      }

      return new DefaultExecutionOptions(queryOptions, client, rowCallback);
    }
  }]);

  return DefaultExecutionOptions;
}(ExecutionOptions$4);

function ifUndefined(v1, v2) {
  return v1 !== undefined ? v1 : v2;
}

function ifUndefined3(v1, v2, v3) {
  if (v1 !== undefined) {
    return v1;
  }

  return v2 !== undefined ? v2 : v3;
}

var executionOptions = {
  ExecutionOptions: ExecutionOptions$4,
  DefaultExecutionOptions: DefaultExecutionOptions$2,
  proxyExecuteKey: proxyExecuteKey$1
};

var _from = "cassandra-driver";
var _id = "cassandra-driver@4.6.3";
var _inBundle = false;
var _integrity = "sha512-npW670TXjTHrdb15LUFN01wssb9vvz6SuNYcppesoKcUXx3Q29nXVhRtnvsnkG0BaSnDGvCCR4udrzYLsbh+sg==";
var _location = "/cassandra-driver";
var _phantomChildren = {
};
var _requested = {
	type: "tag",
	registry: true,
	raw: "cassandra-driver",
	name: "cassandra-driver",
	escapedName: "cassandra-driver",
	rawSpec: "",
	saveSpec: null,
	fetchSpec: "latest"
};
var _requiredBy = [
	"#USER",
	"/"
];
var _resolved = "https://registry.npmjs.org/cassandra-driver/-/cassandra-driver-4.6.3.tgz";
var _shasum = "134cd797ad11c8a51da153db3aa5917589e17088";
var _spec = "cassandra-driver";
var _where = "/data/www/websites/nft-social/backend";
var author = {
	name: "DataStax"
};
var bugs = {
	url: "https://groups.google.com/a/lists.datastax.com/forum/#!forum/nodejs-driver-user"
};
var bundleDependencies = false;
var dependencies = {
	"@types/long": "^4.0.0",
	"@types/node": ">=8",
	"adm-zip": "^0.5.3",
	long: "^2.2.0"
};
var deprecated = false;
var description$1 = "DataStax Node.js Driver for Apache Cassandra";
var devDependencies = {
	chai: "4.2.0",
	mocha: "~7.1.1",
	proxyquire: "~2.1.3",
	sinon: "~7.5.0",
	temp: ">= 0.8.3"
};
var engines = {
	node: ">=8"
};
var homepage = "https://github.com/datastax/nodejs-driver#readme";
var keywords = [
	"cassandra",
	"cql",
	"cql3",
	"connection",
	"gremlin",
	"datastax",
	"nosql",
	"driver",
	"database",
	"dse",
	"graph",
	"graphdb"
];
var license = "Apache-2.0";
var name = "cassandra-driver";
var repository = {
	type: "git",
	url: "git+https://github.com/datastax/nodejs-driver.git"
};
var scripts = {
	ci_appveyor: "mocha test/unit test/integration/short --recursive -R mocha-appveyor-reporter --exit",
	ci_jenkins: "mocha test/unit test/integration/short --recursive -R mocha-jenkins-reporter --exit",
	ci_unit_appveyor: "mocha test/unit --recursive -R mocha-appveyor-reporter --exit",
	eslint: "eslint lib test",
	foo: "mocha test/integration/short --recursive -R spec --exit -g 'should subscribe to TOPOLOGY_CHANGE'",
	server_api: "mocha test/integration/short -g '@SERVER_API' --recursive --exit",
	test: "mocha test/unit -R spec -t 5000 --recursive"
};
var types$o = "./index.d.ts";
var version$1 = "4.6.3";
var require$$17 = {
	_from: _from,
	_id: _id,
	_inBundle: _inBundle,
	_integrity: _integrity,
	_location: _location,
	_phantomChildren: _phantomChildren,
	_requested: _requested,
	_requiredBy: _requiredBy,
	_resolved: _resolved,
	_shasum: _shasum,
	_spec: _spec,
	_where: _where,
	author: author,
	bugs: bugs,
	bundleDependencies: bundleDependencies,
	dependencies: dependencies,
	deprecated: deprecated,
	description: description$1,
	devDependencies: devDependencies,
	engines: engines,
	homepage: homepage,
	keywords: keywords,
	license: license,
	name: name,
	repository: repository,
	scripts: scripts,
	types: types$o,
	version: version$1
};

var util$q = require$$0__default$1["default"];
var FrameWriter = writers.FrameWriter;
var types$n = types$u;
var utils$y = utils$V;
var ExecutionOptions$3 = executionOptions.ExecutionOptions;
var packageInfo$1 = require$$17;
/**
 * Options for the execution of the query / prepared statement
 * @private
 */

var queryFlag = {
  values: 0x01,
  skipMetadata: 0x02,
  pageSize: 0x04,
  withPagingState: 0x08,
  withSerialConsistency: 0x10,
  withDefaultTimestamp: 0x20,
  withNameForValues: 0x40,
  withKeyspace: 0x80,
  withPageSizeBytes: 0x40000000,
  withContinuousPaging: 0x80000000
};
/**
 * Options for the execution of a batch request from protocol v3 and above
 * @private
 */

var batchFlag = {
  withSerialConsistency: 0x10,
  withDefaultTimestamp: 0x20,
  withNameForValues: 0x40,
  withKeyspace: 0x80
};
/**
 * Options for execution of a prepare request from protocol DSE_V2 and above
 * @private
 */

var prepareFlag = {
  withKeyspace: 0x01
};
var batchType = {
  logged: 0,
  unlogged: 1,
  counter: 2
};
/**
 * Abstract class Request
 */

var Request = /*#__PURE__*/function () {
  function Request() {
    _classCallCheck(this, Request);

    this.length = 0;
  }
  /**
   * @abstract
   * @param {Encoder} encoder
   * @param {Number} streamId
   * @throws {TypeError}
   * @returns {Buffer}
   */


  _createClass(Request, [{
    key: "write",
    value: function write(encoder, streamId) {
      throw new Error('Method must be implemented');
    }
    /**
     * Creates a new instance using the same constructor as the current instance, copying the properties.
     * @return {Request}
     */

  }, {
    key: "clone",
    value: function clone() {
      var newRequest = new this.constructor();
      var keysArray = Object.keys(this);

      for (var i = 0; i < keysArray.length; i++) {
        var key = keysArray[i];
        newRequest[key] = this[key];
      }

      return newRequest;
    }
  }]);

  return Request;
}();
/**
 * Writes a execute query (given a prepared queryId)
 * @param {String} query
 * @param {Buffer} queryId
 * @param {Array} params
 * @param options
 */


var ExecuteRequest$1 = /*#__PURE__*/function (_Request) {
  _inherits(ExecuteRequest, _Request);

  var _super = _createSuper(ExecuteRequest);

  /**
   * @param {String} query
   * @param queryId
   * @param params
   * @param {ExecutionOptions} execOptions
   * @param meta
   */
  function ExecuteRequest(query, queryId, params, execOptions, meta) {
    var _this;

    _classCallCheck(this, ExecuteRequest);

    _this = _super.call(this);
    _this.query = query;
    _this.queryId = queryId;
    _this.params = params;
    _this.meta = meta;
    _this.options = execOptions || ExecutionOptions$3.empty();
    _this.consistency = _this.options.getConsistency() || types$n.consistencies.one; // Only QUERY request parameters are encoded as named parameters
    // EXECUTE request parameters are always encoded as positional parameters

    _this.namedParameters = false;
    return _this;
  }

  _createClass(ExecuteRequest, [{
    key: "getParamType",
    value: function getParamType(index) {
      var columnInfo = this.meta.columns[index];
      return columnInfo ? columnInfo.type : null;
    }
  }, {
    key: "write",
    value: function write(encoder, streamId) {
      //v1: <queryId>
      //      <n><value_1>....<value_n><consistency>
      //v2: <queryId>
      //      <consistency><flags>[<n><value_1>...<value_n>][<result_page_size>][<paging_state>][<serial_consistency>]
      //v3: <queryId>
      //      <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>][<serial_consistency>][<timestamp>]
      var frameWriter = new FrameWriter(types$n.opcodes.execute);
      var headerFlags = this.options.isQueryTracing() ? types$n.frameFlags.tracing : 0;

      if (this.options.getCustomPayload()) {
        //The body may contain the custom payload
        headerFlags |= types$n.frameFlags.customPayload;
        frameWriter.writeCustomPayload(this.options.getCustomPayload());
      }

      frameWriter.writeShortBytes(this.queryId);

      if (types$n.protocolVersion.supportsResultMetadataId(encoder.protocolVersion)) {
        frameWriter.writeShortBytes(this.meta.resultId);
      }

      this.writeQueryParameters(frameWriter, encoder); // Record the length of the body of the request before writing it

      this.length = frameWriter.bodyLength;
      return frameWriter.write(encoder.protocolVersion, streamId, headerFlags);
    }
    /**
     * Writes v1 and v2 execute query parameters
     * @param {FrameWriter} frameWriter
     * @param {Encoder} encoder
     * @param {Boolean} [isQuery] True if query, otherwise assumed to be execute request.
     */

  }, {
    key: "writeQueryParameters",
    value: function writeQueryParameters(frameWriter, encoder, isQuery) {
      //v1: <n><value_1>....<value_n><consistency>
      //v2: <consistency><flags>[<n><value_1>...<value_n>][<result_page_size>][<paging_state>][<serial_consistency>]
      //v3: <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>][<serial_consistency>][<timestamp>]
      //dse_v1: <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>]
      //          [<serial_consistency>][<timestamp>][continuous_paging_options]
      //dse_v2: <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>]
      //          [<serial_consistency>][<timestamp>][keyspace][continuous_paging_options]
      var flags = 0;
      var timestamp = this.options.getOrGenerateTimestamp();

      if (types$n.protocolVersion.supportsPaging(encoder.protocolVersion)) {
        flags |= this.params && this.params.length ? queryFlag.values : 0;
        flags |= this.options.getFetchSize() > 0 ? queryFlag.pageSize : 0;
        flags |= this.options.getPageState() ? queryFlag.withPagingState : 0;
        flags |= this.options.getSerialConsistency() ? queryFlag.withSerialConsistency : 0;
        flags |= timestamp !== null && timestamp !== undefined ? queryFlag.withDefaultTimestamp : 0;
        flags |= this.namedParameters ? queryFlag.withNameForValues : 0; // Don't inject keyspace for EXECUTE requests as inherited from prepared statement.

        var supportsKeyspace = isQuery && types$n.protocolVersion.supportsKeyspaceInRequest(encoder.protocolVersion);
        flags |= supportsKeyspace && this.options.getKeyspace() ? queryFlag.withKeyspace : 0;
        frameWriter.writeShort(this.consistency);

        if (types$n.protocolVersion.uses4BytesQueryFlags(encoder.protocolVersion)) {
          frameWriter.writeInt(flags);
        } else {
          frameWriter.writeByte(flags);
        }
      }

      if (this.params && this.params.length) {
        frameWriter.writeShort(this.params.length);

        for (var i = 0; i < this.params.length; i++) {
          var paramValue = this.params[i];

          if (flags & queryFlag.withNameForValues) {
            //parameter is composed by name / value
            frameWriter.writeString(paramValue.name);
            paramValue = paramValue.value;
          }

          frameWriter.writeBytes(encoder.encode(paramValue, this.getParamType(i)));
        }
      }

      if (!types$n.protocolVersion.supportsPaging(encoder.protocolVersion)) {
        if (!this.params || !this.params.length) {
          //zero parameters
          frameWriter.writeShort(0);
        }

        frameWriter.writeShort(this.consistency);
        return;
      }

      if (flags & queryFlag.pageSize) {
        frameWriter.writeInt(this.options.getFetchSize());
      }

      if (flags & queryFlag.withPagingState) {
        frameWriter.writeBytes(this.options.getPageState());
      }

      if (flags & queryFlag.withSerialConsistency) {
        frameWriter.writeShort(this.options.getSerialConsistency());
      }

      if (flags & queryFlag.withDefaultTimestamp) {
        frameWriter.writeLong(timestamp);
      }

      if (flags & queryFlag.withKeyspace) {
        frameWriter.writeString(this.options.getKeyspace());
      }
    }
  }]);

  return ExecuteRequest;
}(Request);

var QueryRequest$1 = /*#__PURE__*/function (_ExecuteRequest) {
  _inherits(QueryRequest, _ExecuteRequest);

  var _super2 = _createSuper(QueryRequest);

  /**
   * @param {String} query
   * @param params
   * @param {ExecutionOptions} [execOptions]
   * @param {Boolean} [namedParameters]
   */
  function QueryRequest(query, params, execOptions, namedParameters) {
    var _this2;

    _classCallCheck(this, QueryRequest);

    _this2 = _super2.call(this, query, null, params, execOptions, null);
    _this2.hints = _this2.options.getHints() || utils$y.emptyArray;
    _this2.namedParameters = namedParameters;
    return _this2;
  }

  _createClass(QueryRequest, [{
    key: "getParamType",
    value: function getParamType(index) {
      return this.hints[index];
    }
  }, {
    key: "write",
    value: function write(encoder, streamId) {
      //v1: <query><consistency>
      //v2: <query>
      //      <consistency><flags>[<n><value_1>...<value_n>][<result_page_size>][<paging_state>][<serial_consistency>]
      //v3: <query>
      //      <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>][<serial_consistency>][<timestamp>]
      var frameWriter = new FrameWriter(types$n.opcodes.query);
      var headerFlags = this.options.isQueryTracing() ? types$n.frameFlags.tracing : 0;

      if (this.options.getCustomPayload()) {
        //The body may contain the custom payload
        headerFlags |= types$n.frameFlags.customPayload;
        frameWriter.writeCustomPayload(this.options.getCustomPayload());
      }

      frameWriter.writeLString(this.query);

      if (!types$n.protocolVersion.supportsPaging(encoder.protocolVersion)) {
        frameWriter.writeShort(this.consistency);
      } else {
        //Use the same fields as the execute writer
        this.writeQueryParameters(frameWriter, encoder, true);
      } // Record the length of the body of the request before writing it


      this.length = frameWriter.bodyLength;
      return frameWriter.write(encoder.protocolVersion, streamId, headerFlags);
    }
  }]);

  return QueryRequest;
}(ExecuteRequest$1);

var PrepareRequest = /*#__PURE__*/function (_Request2) {
  _inherits(PrepareRequest, _Request2);

  var _super3 = _createSuper(PrepareRequest);

  function PrepareRequest(query, keyspace) {
    var _this3;

    _classCallCheck(this, PrepareRequest);

    _this3 = _super3.call(this);
    _this3.query = query;
    _this3.keyspace = keyspace;
    return _this3;
  }

  _createClass(PrepareRequest, [{
    key: "write",
    value: function write(encoder, streamId) {
      var frameWriter = new FrameWriter(types$n.opcodes.prepare);
      frameWriter.writeLString(this.query);

      if (types$n.protocolVersion.supportsPrepareFlags(encoder.protocolVersion)) {
        var flags = this.keyspace && types$n.protocolVersion.supportsKeyspaceInRequest(encoder.protocolVersion) ? prepareFlag.withKeyspace : 0;
        frameWriter.writeInt(flags);

        if (flags & prepareFlag.withKeyspace) {
          frameWriter.writeString(this.keyspace);
        }
      }

      return frameWriter.write(encoder.protocolVersion, streamId);
    }
  }]);

  return PrepareRequest;
}(Request);

var StartupRequest = /*#__PURE__*/function (_Request3) {
  _inherits(StartupRequest, _Request3);

  var _super4 = _createSuper(StartupRequest);

  /**
   * Creates a new instance of {@link StartupRequest}.
   * @param {Object} [options]
   * @param [options.cqlVersion]
   * @param [options.noCompact]
   * @param [options.clientId]
   * @param [options.applicationName]
   * @param [options.applicationVersion]
   */
  function StartupRequest(options) {
    var _this4;

    _classCallCheck(this, StartupRequest);

    _this4 = _super4.call(this);
    _this4.options = options || {};
    return _this4;
  }

  _createClass(StartupRequest, [{
    key: "write",
    value: function write(encoder, streamId) {
      var frameWriter = new FrameWriter(types$n.opcodes.startup);
      var startupOptions = {
        CQL_VERSION: this.options.cqlVersion || '3.0.0',
        DRIVER_NAME: packageInfo$1.description,
        DRIVER_VERSION: packageInfo$1.version
      };

      if (this.options.noCompact) {
        startupOptions['NO_COMPACT'] = 'true';
      }

      if (this.options.clientId) {
        startupOptions['CLIENT_ID'] = this.options.clientId.toString();
      }

      if (this.options.applicationName) {
        startupOptions['APPLICATION_NAME'] = this.options.applicationName;
      }

      if (this.options.applicationVersion) {
        startupOptions['APPLICATION_VERSION'] = this.options.applicationVersion;
      }

      frameWriter.writeStringMap(startupOptions);
      return frameWriter.write(encoder.protocolVersion, streamId);
    }
  }]);

  return StartupRequest;
}(Request);

var RegisterRequest = /*#__PURE__*/function (_Request4) {
  _inherits(RegisterRequest, _Request4);

  var _super5 = _createSuper(RegisterRequest);

  function RegisterRequest(events) {
    var _this5;

    _classCallCheck(this, RegisterRequest);

    _this5 = _super5.call(this);
    _this5.events = events;
    return _this5;
  }

  _createClass(RegisterRequest, [{
    key: "write",
    value: function write(encoder, streamId) {
      var frameWriter = new FrameWriter(types$n.opcodes.register);
      frameWriter.writeStringList(this.events);
      return frameWriter.write(encoder.protocolVersion, streamId);
    }
  }]);

  return RegisterRequest;
}(Request);
/**
 * Represents an AUTH_RESPONSE request
 * @param {Buffer} token
 */


var AuthResponseRequest = /*#__PURE__*/function (_Request5) {
  _inherits(AuthResponseRequest, _Request5);

  var _super6 = _createSuper(AuthResponseRequest);

  function AuthResponseRequest(token) {
    var _this6;

    _classCallCheck(this, AuthResponseRequest);

    _this6 = _super6.call(this);
    _this6.token = token;
    return _this6;
  }

  _createClass(AuthResponseRequest, [{
    key: "write",
    value: function write(encoder, streamId) {
      var frameWriter = new FrameWriter(types$n.opcodes.authResponse);
      frameWriter.writeBytes(this.token);
      return frameWriter.write(encoder.protocolVersion, streamId);
    }
  }]);

  return AuthResponseRequest;
}(Request);
/**
 * Represents a protocol v1 CREDENTIALS request message
 */


var CredentialsRequest = /*#__PURE__*/function (_Request6) {
  _inherits(CredentialsRequest, _Request6);

  var _super7 = _createSuper(CredentialsRequest);

  function CredentialsRequest(username, password) {
    var _this7;

    _classCallCheck(this, CredentialsRequest);

    _this7 = _super7.call(this);
    _this7.username = username;
    _this7.password = password;
    return _this7;
  }

  _createClass(CredentialsRequest, [{
    key: "write",
    value: function write(encoder, streamId) {
      var frameWriter = new FrameWriter(types$n.opcodes.credentials);
      frameWriter.writeStringMap({
        username: this.username,
        password: this.password
      });
      return frameWriter.write(encoder.protocolVersion, streamId);
    }
  }]);

  return CredentialsRequest;
}(Request);

var BatchRequest = /*#__PURE__*/function (_Request7) {
  _inherits(BatchRequest, _Request7);

  var _super8 = _createSuper(BatchRequest);

  /**
   * Creates a new instance of BatchRequest.
   * @param {Array.<{query, params, [info]}>} queries Array of objects with the properties query and params
   * @param {ExecutionOptions} execOptions
   */
  function BatchRequest(queries, execOptions) {
    var _this8;

    _classCallCheck(this, BatchRequest);

    _this8 = _super8.call(this);
    _this8.queries = queries;
    _this8.options = execOptions;
    _this8.hints = execOptions.getHints() || utils$y.emptyArray;
    _this8.type = batchType.logged;

    if (execOptions.isBatchCounter()) {
      _this8.type = batchType.counter;
    } else if (!execOptions.isBatchLogged()) {
      _this8.type = batchType.unlogged;
    }

    return _this8;
  }
  /**
  * Writes a batch request
  */


  _createClass(BatchRequest, [{
    key: "write",
    value: function write(encoder, streamId) {
      //v2: <type><n><query_1>...<query_n><consistency>
      //v3: <type><n><query_1>...<query_n><consistency><flags>[<serial_consistency>][<timestamp>]
      //dseV1+: similar to v3/v4, flags is an int instead of a byte
      if (!this.queries || !(this.queries.length > 0)) {
        throw new TypeError(util$q.format('Invalid queries provided %s', this.queries));
      }

      var frameWriter = new FrameWriter(types$n.opcodes.batch);
      var headerFlags = this.options.isQueryTracing() ? types$n.frameFlags.tracing : 0;

      if (this.options.getCustomPayload()) {
        //The body may contain the custom payload
        headerFlags |= types$n.frameFlags.customPayload;
        frameWriter.writeCustomPayload(this.options.getCustomPayload());
      }

      frameWriter.writeByte(this.type);
      frameWriter.writeShort(this.queries.length);
      var self = this;
      this.queries.forEach(function eachQuery(item, i) {
        var hints = self.hints[i];
        var params = item.params || utils$y.emptyArray;
        var getParamType;

        if (item.queryId) {
          // Contains prepared queries
          frameWriter.writeByte(1);
          frameWriter.writeShortBytes(item.queryId);

          getParamType = function getParamType(i) {
            return item.meta.columns[i].type;
          };
        } else {
          // Contains string queries
          frameWriter.writeByte(0);
          frameWriter.writeLString(item.query);
          getParamType = hints ? function (i) {
            return hints[i];
          } : function () {
            return null;
          };
        }

        frameWriter.writeShort(params.length);
        params.forEach(function (param, index) {
          return frameWriter.writeBytes(encoder.encode(param, getParamType(index)));
        });
      }, this);
      frameWriter.writeShort(this.options.getConsistency());

      if (types$n.protocolVersion.supportsTimestamp(encoder.protocolVersion)) {
        // Batch flags
        var flags = this.options.getSerialConsistency() ? batchFlag.withSerialConsistency : 0;
        var timestamp = this.options.getOrGenerateTimestamp();
        flags |= timestamp !== null && timestamp !== undefined ? batchFlag.withDefaultTimestamp : 0;
        flags |= this.options.getKeyspace() && types$n.protocolVersion.supportsKeyspaceInRequest(encoder.protocolVersion) ? batchFlag.withKeyspace : 0;

        if (types$n.protocolVersion.uses4BytesQueryFlags(encoder.protocolVersion)) {
          frameWriter.writeInt(flags);
        } else {
          frameWriter.writeByte(flags);
        }

        if (flags & batchFlag.withSerialConsistency) {
          frameWriter.writeShort(this.options.getSerialConsistency());
        }

        if (flags & batchFlag.withDefaultTimestamp) {
          frameWriter.writeLong(timestamp);
        }

        if (flags & batchFlag.withKeyspace) {
          frameWriter.writeString(this.options.getKeyspace());
        }
      } // Set the length of the body of the request before writing it


      this.length = frameWriter.bodyLength;
      return frameWriter.write(encoder.protocolVersion, streamId, headerFlags);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new BatchRequest(this.queries, this.options);
    }
  }]);

  return BatchRequest;
}(Request);

function CancelRequest(operationId) {
  this.streamId = null;
  this.operationId = operationId;
}

util$q.inherits(CancelRequest, Request);

CancelRequest.prototype.write = function (encoder, streamId) {
  var frameWriter = new FrameWriter(types$n.opcodes.cancel);
  frameWriter.writeInt(1);
  frameWriter.writeInt(this.operationId);
  return frameWriter.write(encoder.protocolVersion, streamId);
};

var OptionsRequest = /*#__PURE__*/function (_Request8) {
  _inherits(OptionsRequest, _Request8);

  var _super9 = _createSuper(OptionsRequest);

  function OptionsRequest() {
    _classCallCheck(this, OptionsRequest);

    return _super9.apply(this, arguments);
  }

  _createClass(OptionsRequest, [{
    key: "write",
    value: function write(encoder, streamId) {
      var frameWriter = new FrameWriter(types$n.opcodes.options);
      return frameWriter.write(encoder.protocolVersion, streamId, 0);
    }
  }, {
    key: "clone",
    value: function clone() {
      // since options has no unique state, simply return self.
      return this;
    }
  }]);

  return OptionsRequest;
}(Request);

var options$1 = new OptionsRequest();
requests$7.AuthResponseRequest = AuthResponseRequest;
requests$7.BatchRequest = BatchRequest;
requests$7.CancelRequest = CancelRequest;
requests$7.CredentialsRequest = CredentialsRequest;
requests$7.ExecuteRequest = ExecuteRequest$1;
requests$7.PrepareRequest = PrepareRequest;
requests$7.QueryRequest = QueryRequest$1;
requests$7.Request = Request;
requests$7.RegisterRequest = RegisterRequest;
requests$7.StartupRequest = StartupRequest;
requests$7.options = options$1;

var util$p = require$$0__default$1["default"];
var errors$h = errors$s;
/**
 * Represents the state of a {@link Client}.
 * <p>
 * Exposes information on the connections maintained by a Client at a specific time.
 * </p>
 * @alias module:metadata~ClientState
 * @constructor
 */

var ClientState$1 = /*#__PURE__*/function () {
  /**
   * Creates a new instance of <code>ClientState</code>.
   * @param {Array<Host>} hosts
   * @param {Object.<String, Number>} openConnections
   * @param {Object.<String, Number>} inFlightQueries
   */
  function ClientState(hosts, openConnections, inFlightQueries) {
    _classCallCheck(this, ClientState);

    this._hosts = hosts;
    this._openConnections = openConnections;
    this._inFlightQueries = inFlightQueries;
  }
  /**
   * Get an array of hosts to which the client is connected to.
   * @return {Array<Host>}
   */


  _createClass(ClientState, [{
    key: "getConnectedHosts",
    value: function getConnectedHosts() {
      return this._hosts;
    }
    /**
     * Gets the amount of open connections to a given host.
     * @param {Host} host
     * @return {Number}
     */

  }, {
    key: "getOpenConnections",
    value: function getOpenConnections(host) {
      if (!host) {
        throw new errors$h.ArgumentError('Host is not defined');
      }

      return this._openConnections[host.address] || 0;
    }
    /**
     * Gets the amount of queries that are currently being executed through a given host.
     * <p>
     * This corresponds to the number of queries that have been sent by the Client to server Host on one of its connections
     * but haven't yet obtained a response.
     * </p>
     * @param {Host} host
     * @return {Number}
     */

  }, {
    key: "getInFlightQueries",
    value: function getInFlightQueries(host) {
      if (!host) {
        throw new errors$h.ArgumentError('Host is not defined');
      }

      return this._inFlightQueries[host.address] || 0;
    }
    /**
     * Returns the string representation of the instance.
     */

  }, {
    key: "toString",
    value: function toString() {
      return util$p.format('{"hosts": %j, "openConnections": %j, "inFlightQueries": %j}', this._hosts.map(function (h) {
        return h.address;
      }), this._openConnections, this._inFlightQueries);
    }
    /**
     * Creates a new instance from the provided client.
     * @param {Client} client
     * @internal
     * @ignore
     */

  }], [{
    key: "from",
    value: function from(client) {
      var openConnections = {};
      var inFlightQueries = {};
      var hostArray = [];
      client.hosts.forEach(function (host) {
        if (host.pool.connections.length === 0) {
          return;
        }

        hostArray.push(host);
        openConnections[host.address] = host.pool.connections.length;
        inFlightQueries[host.address] = host.getInFlight();
      });
      return new ClientState(hostArray, openConnections, inFlightQueries);
    }
  }]);

  return ClientState;
}();

var clientState = ClientState$1;

var Long$3 = Long$9.exports;
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
/**
 * Constructs a signed int64 representation.
 * @ignore
 */

var MutableLong$2 = /*#__PURE__*/function () {
  function MutableLong(b00, b16, b32, b48) {
    _classCallCheck(this, MutableLong);

    // Use an array of uint16
    this._arr = [b00 & 0xffff, b16 & 0xffff, b32 & 0xffff, b48 & 0xffff];
  }

  _createClass(MutableLong, [{
    key: "toString",
    value: function toString() {
      return this.toImmutable().toString();
    }
    /**
     * Compares this value with the provided value.
     * @param {MutableLong} other
     * @return {number}
     */

  }, {
    key: "compare",
    value: function compare(other) {
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();

      if (thisNeg && !otherNeg) {
        return -1;
      }

      if (!thisNeg && otherNeg) {
        return 1;
      } // At this point the sign bits are the same


      return this._compareBits(other);
    }
  }, {
    key: "_compareBits",
    value: function _compareBits(other) {
      for (var i = 3; i >= 0; i--) {
        if (this._arr[i] > other._arr[i]) {
          return 1;
        }

        if (this._arr[i] < other._arr[i]) {
          return -1;
        }
      }

      return 0;
    }
  }, {
    key: "getUint16",
    value: function getUint16(index) {
      return this._arr[index];
    }
  }, {
    key: "getLowBitsUnsigned",
    value: function getLowBitsUnsigned() {
      return (this._arr[0] | (this._arr[1] & 0xffff) << 16) >>> 0;
    }
  }, {
    key: "getHighBitsUnsigned",
    value: function getHighBitsUnsigned() {
      return (this._arr[2] | this._arr[3] << 16) >>> 0;
    }
  }, {
    key: "toNumber",
    value: function toNumber() {
      return (this._arr[3] << 16 | this._arr[2]) * TWO_PWR_32_DBL + ((this._arr[1] << 16 | this._arr[0]) >>> 0);
    }
    /**
     * Performs the bitwise NOT of this value.
     * @return {MutableLong}
     */

  }, {
    key: "not",
    value: function not() {
      this._arr[0] = ~this._arr[0] & 0xffff;
      this._arr[1] = ~this._arr[1] & 0xffff;
      this._arr[2] = ~this._arr[2] & 0xffff;
      this._arr[3] = ~this._arr[3] & 0xffff;
      return this;
    }
  }, {
    key: "add",
    value: function add(addend) {
      var c48 = 0,
          c32 = 0,
          c16 = 0,
          c00 = 0;
      c00 += this._arr[0] + addend._arr[0];
      this._arr[0] = c00 & 0xffff;
      c16 += c00 >>> 16;
      c16 += this._arr[1] + addend._arr[1];
      this._arr[1] = c16 & 0xffff;
      c32 += c16 >>> 16;
      c32 += this._arr[2] + addend._arr[2];
      this._arr[2] = c32 & 0xffff;
      c48 += c32 >>> 16;
      c48 += this._arr[3] + addend._arr[3];
      this._arr[3] = c48 & 0xffff;
      return this;
    }
  }, {
    key: "shiftLeft",
    value: function shiftLeft(numBits) {
      if (numBits === 0) {
        return this;
      }

      if (numBits >= 64) {
        return this.toZero();
      }

      var remainingBits = numBits % 16;
      var pos = Math.floor(numBits / 16);

      if (pos > 0) {
        this._arr[3] = this._arr[3 - pos];
        this._arr[2] = pos > 2 ? 0 : this._arr[2 - pos];
        this._arr[1] = pos > 1 ? 0 : this._arr[0];
        this._arr[0] = 0;
      }

      if (remainingBits > 0) {
        // shift left within the int16 and the next one
        this._arr[3] = (this._arr[3] << remainingBits | this._arr[2] >>> 16 - remainingBits) & 0xffff;
        this._arr[2] = (this._arr[2] << remainingBits | this._arr[1] >>> 16 - remainingBits) & 0xffff;
        this._arr[1] = (this._arr[1] << remainingBits | this._arr[0] >>> 16 - remainingBits) & 0xffff;
        this._arr[0] = this._arr[0] << remainingBits & 0xffff;
      }

      return this;
    }
  }, {
    key: "shiftRightUnsigned",
    value: function shiftRightUnsigned(numBits) {
      if (numBits === 0) {
        return this;
      }

      if (numBits >= 64) {
        return this.toZero();
      }

      var remainingBits = numBits % 16;
      var pos = Math.floor(numBits / 16);

      if (pos > 0) {
        this._arr[0] = this._arr[pos];
        this._arr[1] = pos > 2 ? 0 : this._arr[1 + pos];
        this._arr[2] = pos > 1 ? 0 : this._arr[3];
        this._arr[3] = 0;
      }

      if (remainingBits > 0) {
        this._arr[0] = this._arr[0] >>> remainingBits | this._arr[1] << 16 - remainingBits & 0xffff;
        this._arr[1] = this._arr[1] >>> remainingBits | this._arr[2] << 16 - remainingBits & 0xffff;
        this._arr[2] = this._arr[2] >>> remainingBits | this._arr[3] << 16 - remainingBits & 0xffff;
        this._arr[3] = this._arr[3] >>> remainingBits;
      }

      return this;
    }
  }, {
    key: "or",
    value: function or(other) {
      this._arr[0] |= other._arr[0];
      this._arr[1] |= other._arr[1];
      this._arr[2] |= other._arr[2];
      this._arr[3] |= other._arr[3];
      return this;
    }
    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {MutableLong} other
     * @returns {MutableLong} this instance.
     */

  }, {
    key: "xor",
    value: function xor(other) {
      this._arr[0] ^= other._arr[0];
      this._arr[1] ^= other._arr[1];
      this._arr[2] ^= other._arr[2];
      this._arr[3] ^= other._arr[3];
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new MutableLong(this._arr[0], this._arr[1], this._arr[2], this._arr[3]);
    }
    /**
     * Performs the product of this and the specified Long.
     * @param {MutableLong} multiplier
     * @returns {MutableLong} this instance.
     */

  }, {
    key: "multiply",
    value: function multiply(multiplier) {
      var negate = false;

      if (this.isZero() || multiplier.isZero()) {
        return this.toZero();
      }

      if (this.isNegative()) {
        this.negate();
        negate = !negate;
      }

      if (multiplier.isNegative()) {
        multiplier = multiplier.clone().negate();
        negate = !negate;
      } // We can skip products that would overflow.


      var c48 = 0,
          c32 = 0,
          c16 = 0,
          c00 = 0;
      c00 += this._arr[0] * multiplier._arr[0];
      c16 += c00 >>> 16;
      c16 += this._arr[1] * multiplier._arr[0];
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c16 += this._arr[0] * multiplier._arr[1];
      c32 += c16 >>> 16;
      c32 += this._arr[2] * multiplier._arr[0];
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c32 += this._arr[1] * multiplier._arr[1];
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c32 += this._arr[0] * multiplier._arr[2];
      c48 += c32 >>> 16;
      c48 += this._arr[3] * multiplier._arr[0] + this._arr[2] * multiplier._arr[1] + this._arr[1] * multiplier._arr[2] + this._arr[0] * multiplier._arr[3];
      this._arr[0] = c00 & 0xffff;
      this._arr[1] = c16 & 0xffff;
      this._arr[2] = c32 & 0xffff;
      this._arr[3] = c48 & 0xffff;

      if (negate) {
        this.negate();
      }

      return this;
    }
  }, {
    key: "toZero",
    value: function toZero() {
      this._arr[3] = this._arr[2] = this._arr[1] = this._arr[0] = 0;
      return this;
    }
  }, {
    key: "isZero",
    value: function isZero() {
      return this._arr[3] === 0 && this._arr[2] === 0 && this._arr[1] === 0 && this._arr[0] === 0;
    }
  }, {
    key: "isNegative",
    value: function isNegative() {
      // most significant bit turned on
      return (this._arr[3] & 0x8000) > 0;
    }
    /**
     * Negates this value.
     * @return {MutableLong}
     */

  }, {
    key: "negate",
    value: function negate() {
      return this.not().add(MutableLong.one);
    }
  }, {
    key: "equals",
    value: function equals(other) {
      if (!(other instanceof MutableLong)) {
        return false;
      }

      return this._arr[0] === other._arr[0] && this._arr[1] === other._arr[1] && this._arr[2] === other._arr[2] && this._arr[3] === other._arr[3];
    }
  }, {
    key: "toImmutable",
    value: function toImmutable() {
      return Long$3.fromBits(this.getLowBitsUnsigned(), this.getHighBitsUnsigned(), false);
    }
  }], [{
    key: "fromNumber",
    value: function fromNumber(value) {
      if (isNaN(value) || !isFinite(value)) {
        return new MutableLong();
      }

      if (value < 0) {
        return MutableLong.fromNumber(-value).negate();
      }

      var low32Bits = value % TWO_PWR_32_DBL;
      var high32Bits = value / TWO_PWR_32_DBL;
      return MutableLong.fromBits(low32Bits, high32Bits);
    }
  }, {
    key: "fromBits",
    value: function fromBits(low32Bits, high32Bits) {
      return new MutableLong(low32Bits, low32Bits >>> 16, high32Bits, high32Bits >>> 16);
    }
    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @param {String} str
     * @param {Number} [radix]
     * @return {MutableLong}
     */

  }, {
    key: "fromString",
    value: function fromString(str, radix) {
      if (typeof str !== 'string') {
        throw new Error('String format is not valid: ' + str);
      }

      if (str.length === 0) {
        throw Error('number format error: empty string');
      }

      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") {
        return new MutableLong();
      }

      radix = radix || 10;

      if (radix < 2 || radix > 36) {
        throw Error('radix out of range: ' + radix);
      }

      var p;

      if ((p = str.indexOf('-')) > 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }

      if (p === 0) {
        return MutableLong.fromString(str.substring(1), radix).negate();
      } // Do several (8) digits each time through the loop


      var radixToPower = MutableLong.fromNumber(Math.pow(radix, 8));
      var result = new MutableLong();

      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);

        if (size < 8) {
          var power = MutableLong.fromNumber(Math.pow(radix, size));
          result.multiply(power).add(MutableLong.fromNumber(value));
          break;
        }

        result.multiply(radixToPower);
        result.add(MutableLong.fromNumber(value));
      }

      return result;
    }
  }]);

  return MutableLong;
}();

MutableLong$2.one = new MutableLong$2(1, 0, 0, 0);
var mutableLong = MutableLong$2;

var token$2 = {};

var types$m = types$u;
var util$o = require$$0__default$1["default"];

var _Murmur3TokenType = types$m.dataTypes.getByName('bigint');

var _RandomTokenType = types$m.dataTypes.getByName('varint');

var _OrderedTokenType = types$m.dataTypes.getByName('blob');
/**
 * Represents a token on the Cassandra ring.
 */


var Token = /*#__PURE__*/function () {
  function Token(value) {
    _classCallCheck(this, Token);

    this._value = value;
  }
  /**
   * @returns {{code: number, info: *|Object}} The type info for the
   *                                           type of the value of the token.
   */


  _createClass(Token, [{
    key: "getType",
    value: function getType() {
      throw new Error('You must implement a getType function for this Token instance');
    }
    /**
     * @returns {*} The raw value of the token.
     */

  }, {
    key: "getValue",
    value: function getValue() {
      return this._value;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this._value.toString();
    }
    /**
     * Returns 0 if the values are equal, 1 if greater than other, -1
     * otherwise.
     *
     * @param {Token} other 
     * @returns {Number}
     */

  }, {
    key: "compare",
    value: function compare(other) {
      return this._value.compare(other._value);
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return this.compare(other) === 0;
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return this.constructor.name + ' { ' + this.toString() + ' }';
    }
  }]);

  return Token;
}();
/**
 * Represents a token from a Cassandra ring where the partitioner
 * is Murmur3Partitioner.
 * 
 * The raw token type is a varint (represented by MutableLong).
 */


var Murmur3Token = /*#__PURE__*/function (_Token) {
  _inherits(Murmur3Token, _Token);

  var _super = _createSuper(Murmur3Token);

  function Murmur3Token(value) {
    _classCallCheck(this, Murmur3Token);

    return _super.call(this, value);
  }

  _createClass(Murmur3Token, [{
    key: "getType",
    value: function getType() {
      return _Murmur3TokenType;
    }
  }]);

  return Murmur3Token;
}(Token);
/**
 * Represents a token from a Cassandra ring where the partitioner
 * is RandomPartitioner.
 * 
 * The raw token type is a bigint (represented by Number).
 */


var RandomToken = /*#__PURE__*/function (_Token2) {
  _inherits(RandomToken, _Token2);

  var _super2 = _createSuper(RandomToken);

  function RandomToken(value) {
    _classCallCheck(this, RandomToken);

    return _super2.call(this, value);
  }

  _createClass(RandomToken, [{
    key: "getType",
    value: function getType() {
      return _RandomTokenType;
    }
  }]);

  return RandomToken;
}(Token);
/**
 * Represents a token from a Cassandra ring where the partitioner
 * is ByteOrderedPartitioner.
 * 
 * The raw token type is a blob (represented by Buffer or Array).
 */


var ByteOrderedToken = /*#__PURE__*/function (_Token3) {
  _inherits(ByteOrderedToken, _Token3);

  var _super3 = _createSuper(ByteOrderedToken);

  function ByteOrderedToken(value) {
    _classCallCheck(this, ByteOrderedToken);

    return _super3.call(this, value);
  }

  _createClass(ByteOrderedToken, [{
    key: "getType",
    value: function getType() {
      return _OrderedTokenType;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this._value.toString('hex').toUpperCase();
    }
  }]);

  return ByteOrderedToken;
}(Token);
/** 
 * Represents a range of tokens on a Cassandra ring.
 *
 * A range is start-exclusive and end-inclusive.  It is empty when
 * start and end are the same token, except if that is the minimum
 * token, in which case the range covers the whole ring (this is
 * consistent with the behavior of CQL range queries).
 *
 * Note that CQL does not handle wrapping.  To query all partitions
 * in a range, see {@link unwrap}.
 */


var TokenRange$1 = /*#__PURE__*/function () {
  function TokenRange(start, end, tokenizer) {
    _classCallCheck(this, TokenRange);

    this.start = start;
    this.end = end;
    Object.defineProperty(this, '_tokenizer', {
      value: tokenizer,
      enumerable: false
    });
  }
  /**
   * Splits this range into a number of smaller ranges of equal "size"
   * (referring to the number of tokens, not the actual amount of data).
   *
   * Splitting an empty range is not permitted.  But not that, in edge
   * cases, splitting a range might produce one or more empty ranges.
   *
   * @param {Number} numberOfSplits Number of splits to make.
   * @returns {TokenRange[]} Split ranges.
   * @throws {Error} If splitting an empty range.
   */


  _createClass(TokenRange, [{
    key: "splitEvenly",
    value: function splitEvenly(numberOfSplits) {
      if (numberOfSplits < 1) {
        throw new Error(util$o.format("numberOfSplits (%d) must be greater than 0.", numberOfSplits));
      }

      if (this.isEmpty()) {
        throw new Error("Can't split empty range " + this.toString());
      }

      var tokenRanges = [];

      var splitPoints = this._tokenizer.split(this.start, this.end, numberOfSplits);

      var splitStart = this.start;
      var splitEnd;

      for (var splitIndex = 0; splitIndex < splitPoints.length; splitIndex++) {
        splitEnd = splitPoints[splitIndex];
        tokenRanges.push(new TokenRange(splitStart, splitEnd, this._tokenizer));
        splitStart = splitEnd;
      }

      tokenRanges.push(new TokenRange(splitStart, this.end, this._tokenizer));
      return tokenRanges;
    }
    /**
     * A range is empty when start and end are the same token, except if
     * that is the minimum token, in which case the range covers the
     * whole ring.  This is consistent with the behavior of CQL range
     * queries.
     *
     * @returns {boolean} Whether this range is empty.
     */

  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.start.equals(this.end) && !this.start.equals(this._tokenizer.minToken());
    }
    /**
     * A range wraps around the end of the ring when the start token
     * is greater than the end token and the end token is not the 
     * minimum token.
     *
     * @returns {boolean} Whether this range wraps around.
     */

  }, {
    key: "isWrappedAround",
    value: function isWrappedAround() {
      return this.start.compare(this.end) > 0 && !this.end.equals(this._tokenizer.minToken());
    }
    /**
     * Splits this range into a list of two non-wrapping ranges.
     *
     * This will return the range itself if it is non-wrapped, or two
     * ranges otherwise.
     *
     * This is useful for CQL range queries, which do not handle
     * wrapping.
     *
     * @returns {TokenRange[]} The list of non-wrapping ranges.
     */

  }, {
    key: "unwrap",
    value: function unwrap() {
      if (this.isWrappedAround()) {
        return [new TokenRange(this.start, this._tokenizer.minToken(), this._tokenizer), new TokenRange(this._tokenizer.minToken(), this.end, this._tokenizer)];
      }

      return [this];
    }
    /**
     * Whether this range contains a given Token.
     * 
     * @param {*} token Token to check for.
     * @returns {boolean} Whether or not the Token is in this range.
     */

  }, {
    key: "contains",
    value: function contains(token) {
      if (this.isEmpty()) {
        return false;
      }

      var minToken = this._tokenizer.minToken();

      if (this.end.equals(minToken)) {
        if (this.start.equals(minToken)) {
          return true; // ]minToken, minToken] === full ring
        } else if (token.equals(minToken)) {
          return true;
        }

        return token.compare(this.start) > 0;
      }

      var isAfterStart = token.compare(this.start) > 0;
      var isBeforeEnd = token.compare(this.end) <= 0; // if wrapped around ring, token is in ring if its after start or before end.
      // otherwise, token is in ring if its after start and before end.

      return this.isWrappedAround() ? isAfterStart || isBeforeEnd : isAfterStart && isBeforeEnd;
    }
    /**
     * Determines if the input range is equivalent to this one.
     * 
     * @param {TokenRange} other Range to compare with.
     * @returns {boolean} Whether or not the ranges are equal.
     */

  }, {
    key: "equals",
    value: function equals(other) {
      if (other === this) {
        return true;
      } else if (other instanceof TokenRange) {
        return this.compare(other) === 0;
      }

      return false;
    }
    /**
     * Returns 0 if the values are equal, otherwise compares against
     * start, if start is equal, compares against end.
     *  
     * @param {TokenRange} other Range to compare with.
     * @returns {Number} 
     */

  }, {
    key: "compare",
    value: function compare(other) {
      var compareStart = this.start.compare(other.start);
      return compareStart !== 0 ? compareStart : this.end.compare(other.end);
    }
  }, {
    key: "toString",
    value: function toString() {
      return util$o.format(']%s, %s]', this.start.toString(), this.end.toString());
    }
  }]);

  return TokenRange;
}();

token$2.Token = Token;
token$2.TokenRange = TokenRange$1;
token$2.ByteOrderedToken = ByteOrderedToken;
token$2.Murmur3Token = Murmur3Token;
token$2.RandomToken = RandomToken;

var search = {};

var dateRange = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var utils$x = utils$V;
var Long$2 = Long$9.exports;
/**
 * Regex to parse dates in the following format YYYY-MM-DDThh:mm:ss.mssZ
 * Looks cumbersome but it's straightforward:
 * - "(\d{1,6})": year mandatory 1 to 6 digits
 * - (?:-(\d{1,2}))?(?:-(\d{1,2}))? two non-capturing groups representing the month and day (1 to 2 digits captured).
 * - (?:T(\d{1,2}?)?(?::(\d{1,2}))?(?::(\d{1,2}))?)?Z? A non-capturing group for the time portion
 * @private
 */

var dateRegex = /^[-+]?(\d{1,6})(?:-(\d{1,2}))?(?:-(\d{1,2}))?(?:T(\d{1,2}?)?(?::(\d{1,2}))?(?::(\d{1,2})(?:\.(\d{1,3}))?)?)?Z?$/;
var multipleBoundariesRegex = /^\[(.+?) TO (.+)]$/;
var unbounded = Object.freeze(new DateRangeBound(null, -1));
var dateRangeType = {
  // single value as in "2001-01-01"
  singleValue: 0,
  // closed range as in "[2001-01-01 TO 2001-01-31]"
  closedRange: 1,
  // open range high as in "[2001-01-01 TO *]"
  openRangeHigh: 2,
  // - 0x03 - open range low as in "[* TO 2001-01-01]"
  openRangeLow: 3,
  // - 0x04 - both ranges open as in "[* TO *]"
  openBoth: 4,
  // - 0x05 - single open range as in "[*]"
  openSingle: 5
};
/**
 * Defines the possible values of date range precision.
 * @type {Object}
 * @property {Number} year
 * @property {Number} month
 * @property {Number} day
 * @property {Number} hour
 * @property {Number} minute
 * @property {Number} second
 * @property {Number} millisecond
 * @memberof module:search
 */

var dateRangePrecision = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5,
  millisecond: 6
};
/**
 * Creates a new instance of <code>DateRange</code> using a lower bound and an upper bound.
 * <p>Consider using <code>DateRange.fromString()</code> to create instances more easily.</p>
 * @classdesc
 * Represents a range of dates, corresponding to the Apache Solr type
 * <a href="https://cwiki.apache.org/confluence/display/solr/Working+with+Dates"><code>DateRangeField</code></a>.
 * <p>
 *   A date range can have one or two bounds, namely lower bound and upper bound, to represent an interval of time.
 *   Date range bounds are both inclusive. For example:
 * </p>
 * <ul>
 *   <li><code>2015 TO 2016-10</code> represents from the first day of 2015 to the last day of October 2016</li>
 *   <li><code>2015</code> represents during the course of the year 2015.</li>
 *   <li><code>2017 TO *</code> represents any date greater or equals to the first day of the year 2017.</li>
 * </ul>
 * <p>
 *   Note that this JavaScript representation of <code>DateRangeField</code> does not support Dates outside of the range
 *   supported by ECMAScript Date: –100,000,000 days to 100,000,000 days measured relative to midnight at the
 *   beginning of 01 January, 1970 UTC. Being <code>-271821-04-20T00:00:00.000Z</code> the minimum lower boundary
 *   and <code>275760-09-13T00:00:00.000Z</code> the maximum higher boundary.
 * <p>
 * @param {DateRangeBound} lowerBound A value representing the range lower bound, composed by a
 * <code>Date</code> and a precision. Use <code>DateRangeBound.unbounded</code> for an open lower bound.
 * @param {DateRangeBound} [upperBound] A value representing the range upper bound, composed by a
 * <code>Date</code> and a precision. Use <code>DateRangeBound.unbounded</code> for an open upper bound. When it's not
 * defined, the <code>DateRange</code> instance is considered as a single value range.
 * @constructor
 * @memberOf module:datastax/search
 */

function DateRange$1(lowerBound, upperBound) {
  if (!lowerBound) {
    throw new TypeError('The lower boundaries must be defined');
  }
  /**
   * Gets the lower bound of this range (inclusive).
   * @type {DateRangeBound}
   */


  this.lowerBound = lowerBound;
  /**
   * Gets the upper bound of this range (inclusive).
   * @type {DateRangeBound|null}
   */

  this.upperBound = upperBound || null; // Define the type

  if (this.upperBound === null) {
    if (this.lowerBound !== unbounded) {
      this._type = dateRangeType.singleValue;
    } else {
      this._type = dateRangeType.openSingle;
    }
  } else {
    if (this.lowerBound !== unbounded) {
      this._type = this.upperBound !== unbounded ? dateRangeType.closedRange : dateRangeType.openRangeHigh;
    } else {
      this._type = this.upperBound !== unbounded ? dateRangeType.openRangeLow : dateRangeType.openBoth;
    }
  }
}
/**
 * Returns true if the value of this DateRange instance and other are the same.
 * @param {DateRange} other
 * @returns {Boolean}
 */


DateRange$1.prototype.equals = function (other) {
  if (!(other instanceof DateRange$1)) {
    return false;
  }

  return other.lowerBound.equals(this.lowerBound) && (other.upperBound ? other.upperBound.equals(this.upperBound) : !this.upperBound);
};
/**
 * Returns the string representation of the instance.
 * @return {String}
 */


DateRange$1.prototype.toString = function () {
  if (this.upperBound === null) {
    return this.lowerBound.toString();
  }

  return '[' + this.lowerBound.toString() + ' TO ' + this.upperBound.toString() + ']';
};

DateRange$1.prototype.toBuffer = function () {
  // Serializes the value containing:
  // <type>[<time0><precision0><time1><precision1>]
  if (this._type === dateRangeType.openBoth || this._type === dateRangeType.openSingle) {
    return utils$x.allocBufferFromArray([this._type]);
  }

  var buffer;
  var offset = 0;

  if (this._type !== dateRangeType.closedRange) {
    // byte + long + byte
    var boundary = this._type !== dateRangeType.openRangeLow ? this.lowerBound : this.upperBound;
    buffer = utils$x.allocBufferUnsafe(10);
    buffer.writeUInt8(this._type, offset++);
    offset = writeDate(boundary.date, buffer, offset);
    buffer.writeUInt8(boundary.precision, offset);
    return buffer;
  } // byte + long + byte + long + byte


  buffer = utils$x.allocBufferUnsafe(19);
  buffer.writeUInt8(this._type, offset++);
  offset = writeDate(this.lowerBound.date, buffer, offset);
  buffer.writeUInt8(this.lowerBound.precision, offset++);
  offset = writeDate(this.upperBound.date, buffer, offset);
  buffer.writeUInt8(this.upperBound.precision, offset);
  return buffer;
};
/**
 * Returns the <code>DateRange</code> representation of a given string.
 * <p>String representations of dates are always expressed in Coordinated Universal Time (UTC)</p>
 * @param {String} dateRangeString
 */


DateRange$1.fromString = function (dateRangeString) {
  var matches = multipleBoundariesRegex.exec(dateRangeString);

  if (!matches) {
    return new DateRange$1(DateRangeBound.toLowerBound(DateRangeBound.fromString(dateRangeString)));
  }

  return new DateRange$1(DateRangeBound.toLowerBound(DateRangeBound.fromString(matches[1])), DateRangeBound.toUpperBound(DateRangeBound.fromString(matches[2])));
};
/**
 * Deserializes the buffer into a <code>DateRange</code>
 * @param {Buffer} buffer
 * @return {DateRange}
 */


DateRange$1.fromBuffer = function (buffer) {
  if (buffer.length === 0) {
    throw new TypeError('DateRange serialized value must have at least 1 byte');
  }

  var type = buffer.readUInt8(0);

  if (type === dateRangeType.openBoth) {
    return new DateRange$1(unbounded, unbounded);
  }

  if (type === dateRangeType.openSingle) {
    return new DateRange$1(unbounded);
  }

  var offset = 1;
  var date1;
  var lowerBound;
  var upperBound = null;

  if (type !== dateRangeType.closedRange) {
    date1 = readDate(buffer, offset);
    offset += 8;
    lowerBound = new DateRangeBound(date1, buffer.readUInt8(offset));

    if (type === dateRangeType.openRangeLow) {
      // lower boundary is open, the first serialized boundary is the upperBound
      upperBound = lowerBound;
      lowerBound = unbounded;
    } else {
      upperBound = type === dateRangeType.openRangeHigh ? unbounded : null;
    }

    return new DateRange$1(lowerBound, upperBound);
  }

  date1 = readDate(buffer, offset);
  offset += 8;
  lowerBound = new DateRangeBound(date1, buffer.readUInt8(offset++));
  var date2 = readDate(buffer, offset);
  offset += 8;
  upperBound = new DateRangeBound(date2, buffer.readUInt8(offset));
  return new DateRange$1(lowerBound, upperBound);
};
/**
 * Writes a Date, long millis since epoch, to a buffer starting from offset.
 * @param {Date} date
 * @param {Buffer} buffer
 * @param {Number} offset
 * @return {Number} The new offset.
 * @private
 */


function writeDate(date, buffer, offset) {
  var _long = Long$2.fromNumber(date.getTime());

  buffer.writeUInt32BE(_long.getHighBitsUnsigned(), offset);
  buffer.writeUInt32BE(_long.getLowBitsUnsigned(), offset + 4);
  return offset + 8;
}
/**
 * Reads a Date, long millis since epoch, from a buffer starting from offset.
 * @param {Buffer} buffer
 * @param {Number} offset
 * @return {Date}
 * @private
 */


function readDate(buffer, offset) {
  var _long2 = new Long$2(buffer.readInt32BE(offset + 4), buffer.readInt32BE(offset));

  return new Date(_long2.toNumber());
}
/**
 * @classdesc
 * Represents a date range boundary, composed by a <code>Date</code> and a precision.
 * @param {Date} date The timestamp portion, representing a single moment in time. Consider using
 * <code>Date.UTC()</code> method to build the <code>Date</code> instance.
 * @param {Number} precision The precision portion. Valid values for <code>DateRangeBound</code> precision are
 * defined in the [dateRangePrecision]{@link module:datastax/search~dateRangePrecision} member.
 * @constructor
 * @memberOf module:datastax/search
 */


function DateRangeBound(date, precision) {
  /**
   * The timestamp portion of the boundary.
   * @type {Date}
   */
  this.date = date;
  /**
   * The precision portion of the boundary. Valid values are defined in the
   * [dateRangePrecision]{@link module:datastax/search~dateRangePrecision} member.
   * @type {Number}
   */

  this.precision = precision;
}
/**
 * Returns the string representation of the instance.
 * @return {String}
 */


DateRangeBound.prototype.toString = function () {
  if (this.precision === -1) {
    return '*';
  }

  var precision = 0;
  var isoString = this.date.toISOString();
  var i;

  var _char; // The years take at least the first 4 characters


  for (i = 4; i < isoString.length && precision <= this.precision; i++) {
    _char = isoString.charAt(i);

    if (precision === dateRangePrecision.day && _char === 'T') {
      precision = dateRangePrecision.hour;
      continue;
    }

    if (precision >= dateRangePrecision.hour && _char === ':' || _char === '.') {
      precision++;
      continue;
    }

    if (precision < dateRangePrecision.day && _char === '-') {
      precision++;
    }
  }

  var start = 0;
  var firstChar = isoString.charAt(0);
  var sign = '';
  var toRemoveIndex = 4;

  if (firstChar === '+' || firstChar === '-') {
    sign = firstChar;

    if (firstChar === '-') {
      // since we are retaining the -, don't remove as many zeros.
      toRemoveIndex = 3;
    } // Remove additional zeros


    for (start = 1; start < toRemoveIndex; start++) {
      if (isoString.charAt(start) !== '0') {
        break;
      }
    }
  }

  if (this.precision !== dateRangePrecision.millisecond) {
    // i holds the position of the first char that marks the end of a precision (ie: '-', 'T', ...),
    // we should not include it in the result, except its the 'Z' char for the complete representation
    i--;
  }

  return sign + isoString.substring(start, i);
};
/**
 * Returns true if the value of this DateRange instance and other are the same.
 * @param {DateRangeBound} other
 * @return {boolean}
 */


DateRangeBound.prototype.equals = function (other) {
  if (!(other instanceof DateRangeBound)) {
    return false;
  }

  if (other.precision !== this.precision) {
    return false;
  }

  return datesEqual(other.date, this.date);
};

function datesEqual(d1, d2) {
  var t1 = d1 ? d1.getTime() : null;
  var t2 = d2 ? d2.getTime() : null;
  return t1 === t2;
}

DateRangeBound.prototype.isUnbounded = function () {
  return this.precision === -1;
};
/**
 * Parses a date string and returns a DateRangeBound.
 * @param {String} boundaryString
 * @return {DateRangeBound}
 */


DateRangeBound.fromString = function (boundaryString) {
  if (!boundaryString) {
    return null;
  }

  if (boundaryString === '*') {
    return unbounded;
  }

  var matches = dateRegex.exec(boundaryString);

  if (!matches) {
    throw TypeError('String provided is not a valid date ' + boundaryString);
  }

  if (matches[7] !== undefined && matches[5] === undefined) {
    // Due to a limitation in the regex, its possible to match dates like 2015T03:02.001, without the seconds
    // portion but with the milliseconds specified.
    throw new TypeError('String representation of the date contains the milliseconds portion but not the seconds: ' + boundaryString);
  }

  var builder = new BoundaryBuilder(boundaryString.charAt(0) === '-');

  for (var i = 1; i < matches.length; i++) {
    builder.set(i - 1, matches[i], boundaryString);
  }

  return builder.build();
};
/**
 * The unbounded {@link DateRangeBound} instance. Unbounded bounds are syntactically represented by a <code>*</code>
 * (star) sign.
 * @type {DateRangeBound}
 */


DateRangeBound.unbounded = unbounded;
/**
 * Converts a {DateRangeBound} into a lower-bounded bound by rounding down its date
 * based on its precision.
 *
 * @param {DateRangeBound} bound The bound to round down.
 * @returns {DateRangeBound} with the date rounded down to the given precision.
 */

DateRangeBound.toLowerBound = function (bound) {
  if (bound === unbounded) {
    return bound;
  }

  var rounded = new Date(bound.date.getTime()); // in this case we want to fallthrough

  /* eslint-disable no-fallthrough */

  switch (bound.precision) {
    case dateRangePrecision.year:
      rounded.setUTCMonth(0);

    case dateRangePrecision.month:
      rounded.setUTCDate(1);

    case dateRangePrecision.day:
      rounded.setUTCHours(0);

    case dateRangePrecision.hour:
      rounded.setUTCMinutes(0);

    case dateRangePrecision.minute:
      rounded.setUTCSeconds(0);

    case dateRangePrecision.second:
      rounded.setUTCMilliseconds(0);
  }
  /* eslint-enable no-fallthrough */


  return new DateRangeBound(rounded, bound.precision);
};
/**
 * Converts a {DateRangeBound} into a upper-bounded bound by rounding up its date
 * based on its precision.
 *
 * @param {DateRangeBound} bound The bound to round up.
 * @returns {DateRangeBound} with the date rounded up to the given precision.
 */


DateRangeBound.toUpperBound = function (bound) {
  if (bound === unbounded) {
    return bound;
  }

  var rounded = new Date(bound.date.getTime()); // in this case we want to fallthrough

  /* eslint-disable no-fallthrough */

  switch (bound.precision) {
    case dateRangePrecision.year:
      rounded.setUTCMonth(11);

    case dateRangePrecision.month:
      // Advance to the beginning of next month and set day of month to 0
      // which sets the date to the last day of the previous month.
      // This gives us the effect of YYYY-MM-LastDayOfThatMonth
      rounded.setUTCMonth(rounded.getUTCMonth() + 1, 0);

    case dateRangePrecision.day:
      rounded.setUTCHours(23);

    case dateRangePrecision.hour:
      rounded.setUTCMinutes(59);

    case dateRangePrecision.minute:
      rounded.setUTCSeconds(59);

    case dateRangePrecision.second:
      rounded.setUTCMilliseconds(999);
  }
  /* eslint-enable no-fallthrough */


  return new DateRangeBound(rounded, bound.precision);
};
/** @private */


function BoundaryBuilder(isNegative) {
  this._sign = isNegative ? -1 : 1;
  this._index = 0;
  this._values = new Int32Array(7);
}

BoundaryBuilder.prototype.set = function (index, value, stringDate) {
  if (value === undefined) {
    return;
  }

  if (index > 6) {
    throw new TypeError('Index out of bounds: ' + index);
  }

  if (index > this._index) {
    this._index = index;
  }

  var numValue = +value;

  switch (index) {
    case dateRangePrecision.month:
      if (numValue < 1 || numValue > 12) {
        throw new TypeError('Month portion is not valid for date: ' + stringDate);
      }

      break;

    case dateRangePrecision.day:
      if (numValue < 1 || numValue > 31) {
        throw new TypeError('Day portion is not valid for date: ' + stringDate);
      }

      break;

    case dateRangePrecision.hour:
      if (numValue > 23) {
        throw new TypeError('Hour portion is not valid for date: ' + stringDate);
      }

      break;

    case dateRangePrecision.minute:
    case dateRangePrecision.second:
      if (numValue > 59) {
        throw new TypeError('Minute/second portion is not valid for date: ' + stringDate);
      }

      break;

    case dateRangePrecision.millisecond:
      if (numValue > 999) {
        throw new TypeError('Millisecond portion is not valid for date: ' + stringDate);
      }

      break;
  }

  this._values[index] = numValue;
};
/** @return {DateRangeBound} */


BoundaryBuilder.prototype.build = function () {
  var date = new Date(0);
  var month = this._values[1];

  if (month) {
    // ES Date months are represented from 0 to 11
    month--;
  }

  date.setUTCFullYear(this._sign * this._values[0], month, this._values[2] || 1);
  date.setUTCHours(this._values[3], this._values[4], this._values[5], this._values[6]);
  return new DateRangeBound(date, this._index);
};

dateRange.unbounded = unbounded;
dateRange.dateRangePrecision = dateRangePrecision;
dateRange.DateRange = DateRange$1;
dateRange.DateRangeBound = DateRangeBound;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var dateRangeModule = dateRange;
/**
 * Search module.
 * <p>
 *   Contains the classes to represent the set of  types for search data that come with DSE 5.1+
 * </p>
 * @module datastax/search
 */

search.DateRange = dateRangeModule.DateRange;
search.DateRangeBound = dateRangeModule.DateRangeBound;
search.dateRangePrecision = dateRangeModule.dateRangePrecision;

var geometry$1 = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var endianness = {
  '0': 'BE',
  '1': 'LE'
};

function Geometry$4() {}

Geometry$4.types = {
  Point2D: 1,
  LineString: 2,
  Polygon: 3
};
/**
 * @protected
 * @param {Number} code
 * @returns {String}
 * @ignore
 */

Geometry$4.getEndianness = function (code) {
  var value = endianness[code.toString()];

  if (typeof value === 'undefined') {
    throw new TypeError('Invalid endianness with code ' + code);
  }

  return value;
};
/**
 * Reads an int32 from binary representation based on endianness.
 * @protected
 * @param {Buffer} buffer
 * @param {String} endianness
 * @param {Number} offset
 * @returns Number
 * @ignore
 */


Geometry$4.readInt32 = function (buffer, endianness, offset) {
  if (endianness === 'BE') {
    return buffer.readInt32BE(offset, true);
  }

  return buffer.readInt32LE(offset, true);
};
/**
 * Reads an 64-bit double from binary representation based on endianness.
 * @protected
 * @param {Buffer} buffer
 * @param {String} endianness
 * @param {Number} offset
 * @returns Number
 * @ignore
 */


Geometry$4.readDouble = function (buffer, endianness, offset) {
  if (endianness === 'BE') {
    return buffer.readDoubleBE(offset, true);
  }

  return buffer.readDoubleLE(offset, true);
};
/**
 * Writes an 32-bit integer to binary representation based on OS endianness.
 * @protected
 * @param {Number} val
 * @param {Buffer} buffer
 * @param {Number} offset
 * @ignore
 */


Geometry$4.prototype.writeInt32 = function (val, buffer, offset) {
  if (this.useBESerialization()) {
    return buffer.writeInt32BE(val, offset, true);
  }

  return buffer.writeInt32LE(val, offset, true);
};
/**
 * Writes an 64-bit double to binary representation based on OS endianness.
 * @protected
 * @param {Number} val
 * @param {Buffer} buffer
 * @param {Number} offset
 * @ignore
 */


Geometry$4.prototype.writeDouble = function (val, buffer, offset) {
  if (this.useBESerialization()) {
    return buffer.writeDoubleBE(val, offset, true);
  }

  return buffer.writeDoubleLE(val, offset, true);
};
/**
 * Writes an 8-bit int that represents the OS endianness.
 * @protected
 * @param {Buffer} buffer
 * @param {Number} offset
 * @ignore
 */


Geometry$4.prototype.writeEndianness = function (buffer, offset) {
  if (this.useBESerialization()) {
    return buffer.writeInt8(0, offset, true);
  }

  return buffer.writeInt8(1, offset, true);
};
/**
 * Returns true if the serialization must be done in big-endian format.
 * Designed to allow injection of OS endianness.
 * @abstract
 * @ignore
 */


Geometry$4.prototype.useBESerialization = function () {
  throw new Error('Not Implemented');
};

var geometry = Geometry$4;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$n = require$$0__default$1["default"];
var utils$w = utils$V;
var Geometry$3 = geometry;
/**
 * Creates a new {@link Point} instance.
 * @classdesc
 * A Point is a zero-dimensional object that represents a specific (X,Y)
 * location in a two-dimensional XY-Plane. In case of Geographic Coordinate
 * Systems, the X coordinate is the longitude and the Y is the latitude.
 * @param {Number} x The X coordinate.
 * @param {Number} y The Y coordinate.
 * @extends {Geometry}
 * @alias module:geometry~Point
 * @constructor
 */

function Point$4(x, y) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    throw new TypeError('X and Y must be numbers');
  }

  if (isNaN(x) || isNaN(y)) {
    throw new TypeError('X and Y must be numbers');
  }
  /**
   * Returns the X coordinate of this 2D point.
   * @type {Number}
   */


  this.x = x;
  /**
   * Returns the Y coordinate of this 2D point.
   * @type {Number}
   */

  this.y = y;
} //noinspection JSCheckFunctionSignatures


util$n.inherits(Point$4, Geometry$3);
/**
 * Creates a {@link Point} instance from
 * a <a href="https://en.wikipedia.org/wiki/Well-known_text">Well-known Text (WKT)</a>
 * representation of a 2D point.
 * @param {Buffer} buffer
 * @returns {Point}
 */

Point$4.fromBuffer = function (buffer) {
  if (!buffer || buffer.length !== 21) {
    throw new TypeError('2D Point buffer should contain 21 bytes');
  }

  var endianness = Geometry$3.getEndianness(buffer.readInt8(0, true));

  if (Geometry$3.readInt32(buffer, endianness, 1) !== Geometry$3.types.Point2D) {
    throw new TypeError('Binary representation was not a point');
  }

  return new Point$4(Geometry$3.readDouble(buffer, endianness, 5), Geometry$3.readDouble(buffer, endianness, 13));
};
/**
 * Creates a {@link Point} instance from
 * a <a href="https://en.wikipedia.org/wiki/Well-known_text">Well-known Text (WKT)</a>
 * representation of a 2D point.
 * @param {String} textValue
 * @returns {Point}
 */


Point$4.fromString = function (textValue) {
  var wktRegex = /^POINT\s?\(([-0-9.]+) ([-0-9.]+)\)$/g;
  var matches = wktRegex.exec(textValue);

  if (!matches || matches.length !== 3) {
    throw new TypeError('2D Point WTK should contain 2 coordinates');
  }

  return new Point$4(parseFloat(matches[1]), parseFloat(matches[2]));
};
/**
 * Returns a <a href="https://en.wikipedia.org/wiki/Well-known_text#Well-known_binary">Well-known Binary</a> (WKB)
 * representation of this instance.
 * @returns {Buffer}
 */


Point$4.prototype.toBuffer = function () {
  var buffer = utils$w.allocBufferUnsafe(21);
  this.writeEndianness(buffer, 0);
  this.writeInt32(Geometry$3.types.Point2D, buffer, 1);
  this.writeDouble(this.x, buffer, 5);
  this.writeDouble(this.y, buffer, 13);
  return buffer;
};
/**
 * Returns true if the values of the point are the same, otherwise it returns false.
 * @param {Point} other
 * @returns {Boolean}
 */


Point$4.prototype.equals = function (other) {
  if (!(other instanceof Point$4)) {
    return false;
  }

  return this.x === other.x && this.y === other.y;
};
/**
 * Returns Well-known text (WKT) representation of the geometry object.
 * @returns {String}
 */


Point$4.prototype.toString = function () {
  return util$n.format('POINT (%d %d)', this.x, this.y);
};

Point$4.prototype.useBESerialization = function () {
  return false;
};
/**
 * Returns a JSON representation of this geo-spatial type.
 */


Point$4.prototype.toJSON = function () {
  return {
    type: 'Point',
    coordinates: [this.x, this.y]
  };
};

var point = Point$4;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$m = require$$0__default$1["default"];
var utils$v = utils$V;
var Geometry$2 = geometry;
var Point$3 = point;
/**
 * Creates a new {@link LineString} instance.
 * @classdesc
 * A LineString is a one-dimensional object representing a sequence of points and the line segments connecting them.
 * @param {...Point}[point] A sequence of [Point]{@link module:geometry~Point} items as arguments.
 * @example
 * new LineString(new Point(10.99, 20.02), new Point(14, 26), new Point(34, 1.2));
 * @constructor
 * @alias module:geometry~LineString
 * @extends {Geometry}
 */

function LineString$3(point) {
  var points = Array.prototype.slice.call(arguments);

  if (points.length === 1 && Array.isArray(points) && Array.isArray(points[0])) {
    //The first argument is an array of the points
    points = points[0];
  }

  if (points.length === 1) {
    throw new TypeError('LineString can be either empty or contain 2 or more points');
  }
  /**
   * Returns a frozen Array of points that represent the line.
   * @type {Array.<Point>}
   */


  this.points = Object.freeze(points);
} //noinspection JSCheckFunctionSignatures


util$m.inherits(LineString$3, Geometry$2);
/**
 * Creates a {@link LineString} instance from
 * a <a href="https://en.wikipedia.org/wiki/Well-known_text">Well-known Text (WKT)</a>
 * representation of a line.
 * @param {Buffer} buffer
 * @returns {LineString}
 */

LineString$3.fromBuffer = function (buffer) {
  if (!buffer || buffer.length < 9) {
    throw new TypeError('A linestring buffer should contain at least 9 bytes');
  }

  var endianness = Geometry$2.getEndianness(buffer.readInt8(0, true));
  var offset = 1;

  if (Geometry$2.readInt32(buffer, endianness, offset) !== Geometry$2.types.LineString) {
    throw new TypeError('Binary representation was not a LineString');
  }

  offset += 4;
  var length = Geometry$2.readInt32(buffer, endianness, offset);
  offset += 4;

  if (buffer.length !== offset + length * 16) {
    throw new TypeError(util$m.format('Length of the buffer does not match %d !== %d', buffer.length, offset + length * 8));
  }

  var points = new Array(length);

  for (var i = 0; i < length; i++) {
    points[i] = new Point$3(Geometry$2.readDouble(buffer, endianness, offset), Geometry$2.readDouble(buffer, endianness, offset + 8));
    offset += 16;
  } //noinspection JSCheckFunctionSignatures


  return new LineString$3(points);
};
/**
 * Creates a {@link LineString} instance from
 * a <a href="https://en.wikipedia.org/wiki/Well-known_text">Well-known Text (WKT)</a>
 * representation of a line.
 * @param {String} textValue
 * @returns {LineString}
 */


LineString$3.fromString = function (textValue) {
  var wktRegex = /^LINESTRING ?\(([-0-9. ,]+)\)+$/g;
  var matches = wktRegex.exec(textValue);

  if (!matches || matches.length !== 2) {
    throw new TypeError('Invalid WKT: ' + textValue);
  }

  var points = LineString$3.parseSegments(matches[1]);
  return new LineString$3(points);
};
/**
 * Internal method that parses a series of WKT points.
 * @param {String} textValue
 * @returns {Array<Point>}
 * @internal
 * @ignore
 */


LineString$3.parseSegments = function (textValue) {
  var points = [];
  var pointParts = textValue.split(',');

  for (var i = 0; i < pointParts.length; i++) {
    var p = pointParts[i].trim();

    if (p.length === 0) {
      throw new TypeError('Invalid WKT segment: ' + textValue);
    }

    var xyText = p.split(' ').filter(function (element) {
      return element.trim().length > 0;
    });

    if (xyText.length !== 2) {
      throw new TypeError('Invalid WKT segment: ' + textValue);
    }

    points.push(new Point$3(parseFloat(xyText[0]), parseFloat(xyText[1])));
  }

  return points;
};
/**
 * Returns a <a href="https://en.wikipedia.org/wiki/Well-known_text#Well-known_binary">Well-known Binary</a> (WKB)
 * representation of this instance.
 * @returns {Buffer}
 */


LineString$3.prototype.toBuffer = function () {
  var buffer = utils$v.allocBufferUnsafe(9 + this.points.length * 16);
  this.writeEndianness(buffer, 0);
  var offset = 1;
  this.writeInt32(Geometry$2.types.LineString, buffer, offset);
  offset += 4;
  this.writeInt32(this.points.length, buffer, offset);
  offset += 4;
  this.points.forEach(function (p) {
    this.writeDouble(p.x, buffer, offset);
    this.writeDouble(p.y, buffer, offset + 8);
    offset += 16;
  }, this);
  return buffer;
};
/**
 * Returns true if the values of the linestrings are the same, otherwise it returns false.
 * @param {LineString} other
 * @returns {Boolean}
 */


LineString$3.prototype.equals = function (other) {
  if (!(other instanceof LineString$3)) {
    return false;
  }

  if (this.points.length !== other.points.length) {
    return false;
  }

  for (var i = 0; i < this.points.length; i++) {
    if (!this.points[i].equals(other.points[i])) {
      return false;
    }
  }

  return true;
};
/**
 * Returns Well-known text (WKT) representation of the geometry object.
 * @returns {String}
 */


LineString$3.prototype.toString = function () {
  if (this.points.length === 0) {
    return 'LINESTRING EMPTY';
  }

  return 'LINESTRING (' + this.points.map(function (p) {
    return p.x + ' ' + p.y;
  }).join(', ') + ')';
};

LineString$3.prototype.useBESerialization = function () {
  return false;
};
/**
 * Returns a JSON representation of this geo-spatial type.
 */


LineString$3.prototype.toJSON = function () {
  return {
    type: 'LineString',
    coordinates: this.points.map(function (p) {
      return [p.x, p.y];
    })
  };
};

var lineString = LineString$3;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$l = require$$0__default$1["default"];
var utils$u = utils$V;
var Geometry$1 = geometry;
var Point$2 = point;
var LineString$2 = lineString;
/**
 * Creates a new {@link Polygon} instance.
 * @classdesc
 * Represents is a plane geometry figure that is bounded by a finite chain of straight line segments closing in a loop
 * to form a closed chain or circuit.
 * @param {...Array.<Point>}[ringPoints] A sequence of Array of [Point]{@link module:geometry~Point} items as arguments
 * representing the rings of the polygon.
 * @example
 * new Polygon([ new Point(30, 10), new Point(40, 40), new Point(10, 20), new Point(30, 10) ]);
 * @example
 * //polygon with a hole
 * new Polygon(
 *  [ new Point(30, 10), new Point(40, 40), new Point(10, 20), new Point(30, 10) ],
 *  [ new Point(25, 20), new Point(30, 30), new Point(20, 20), new Point(25, 20) ]
 * );
 * @alias module:geometry~Polygon
 * @constructor
 */

function Polygon$2(ringPoints) {
  var rings = Array.prototype.slice.call(arguments);
  /**
   * Returns a frozen Array of array of points that represent the different rings in the polygon.
   * @type {Array}
   */

  this.rings = Object.freeze(rings);
} //noinspection JSCheckFunctionSignatures


util$l.inherits(Polygon$2, Geometry$1);
/**
 * Creates a {@link Polygon} instance from
 * a <a href="https://en.wikipedia.org/wiki/Well-known_text">Well-known Text (WKT)</a>
 * representation of a polygon.
 * @param {Buffer} buffer
 * @returns {Polygon}
 */

Polygon$2.fromBuffer = function (buffer) {
  if (!buffer || buffer.length < 9) {
    throw new TypeError('A Polygon buffer should contain at least 9 bytes');
  }

  var endianness = Geometry$1.getEndianness(buffer.readInt8(0, true));
  var offset = 1;

  if (Geometry$1.readInt32(buffer, endianness, offset) !== Geometry$1.types.Polygon) {
    throw new TypeError('Binary representation was not a Polygon');
  }

  offset += 4;
  var ringsLength = Geometry$1.readInt32(buffer, endianness, offset);
  offset += 4;
  var ringsArray = new Array(ringsLength);

  for (var ringIndex = 0; ringIndex < ringsLength; ringIndex++) {
    var pointsLength = Geometry$1.readInt32(buffer, endianness, offset);
    offset += 4;

    if (buffer.length < offset + pointsLength * 16) {
      throw new TypeError(util$l.format('Length of the buffer does not match'));
    }

    var ring = new Array(pointsLength);

    for (var i = 0; i < pointsLength; i++) {
      ring[i] = new Point$2(Geometry$1.readDouble(buffer, endianness, offset), Geometry$1.readDouble(buffer, endianness, offset + 8));
      offset += 16;
    }

    ringsArray[ringIndex] = ring;
  } //Invoke the constructor with each ring as a parameter
  //ringsArray.unshift(null);
  //return new (Function.prototype.bind.apply(Polygon, ringsArray));


  return construct(ringsArray);
};
/**
 * Creates a {@link Polygon} instance from
 * a <a href="https://en.wikipedia.org/wiki/Well-known_text">Well-known Text (WKT)</a>
 * representation of a shape.
 * @param {String} textValue
 * @returns {Polygon}
 */


Polygon$2.fromString = function (textValue) {
  var wktRegex = /^POLYGON ?\((\(.*\))\)$/g;
  var matches = wktRegex.exec(textValue);

  function validateWkt(condition) {
    if (condition) {
      throw new TypeError('Invalid WKT: ' + textValue);
    }
  }

  validateWkt(!matches || matches.length !== 2);
  var ringsText = matches[1];
  var ringsArray = [];
  var ringStart = null;

  for (var i = 0; i < ringsText.length; i++) {
    var c = ringsText[i];

    if (c === '(') {
      validateWkt(ringStart !== null);
      ringStart = i + 1;
      continue;
    }

    if (c === ')') {
      validateWkt(ringStart === null);
      ringsArray.push(ringsText.substring(ringStart, i));
      ringStart = null;
      continue;
    }

    validateWkt(ringStart === null && c !== ' ' && c !== ',');
  }

  return construct(ringsArray.map(LineString$2.parseSegments));
};
/**
 * Creates a new instance of Polygon with each array item as a parameter
 * @private
 * @param {Array<Array<Point>>} argsArray
 * @returns {Polygon}
 */


function construct(argsArray) {
  function F() {
    return Polygon$2.apply(this, argsArray);
  }

  F.prototype = Polygon$2.prototype;
  return new F();
}
/**
 * Returns a <a href="https://en.wikipedia.org/wiki/Well-known_text#Well-known_binary">Well-known Binary</a> (WKB)
 * representation of this instance.
 * @returns {Buffer}
 */


Polygon$2.prototype.toBuffer = function () {
  var totalRingsLength = 0;
  this.rings.forEach(function (ring) {
    totalRingsLength += 4 + ring.length * 16;
  }, this);
  var buffer = utils$u.allocBufferUnsafe(9 + totalRingsLength);
  this.writeEndianness(buffer, 0);
  var offset = 1;
  this.writeInt32(Geometry$1.types.Polygon, buffer, offset);
  offset += 4;
  this.writeInt32(this.rings.length, buffer, offset);
  offset += 4;
  this.rings.forEach(function (ring) {
    this.writeInt32(ring.length, buffer, offset);
    offset += 4;
    ring.forEach(function (p) {
      this.writeDouble(p.x, buffer, offset);
      this.writeDouble(p.y, buffer, offset + 8);
      offset += 16;
    }, this);
  }, this);
  return buffer;
};
/**
 * Returns true if the values of the polygons are the same, otherwise it returns false.
 * @param {Polygon} other
 * @returns {Boolean}
 */


Polygon$2.prototype.equals = function (other) {
  if (!(other instanceof Polygon$2)) {
    return false;
  }

  if (this.rings.length !== other.rings.length) {
    return false;
  }

  for (var i = 0; i < this.rings.length; i++) {
    var r1 = this.rings[i];
    var r2 = other.rings[i];

    if (r1.length !== r2.length) {
      return false;
    }

    for (var j = 0; j < r1.length; j++) {
      if (!r1[i].equals(r2[i])) {
        return false;
      }
    }
  }

  return true;
};

Polygon$2.prototype.useBESerialization = function () {
  return false;
};
/**
 * Returns Well-known text (WKT) representation of the geometry object.
 * @returns {String}
 */


Polygon$2.prototype.toString = function () {
  if (this.rings.length === 0) {
    return 'POLYGON EMPTY';
  }

  var ringStrings = '';
  this.rings.forEach(function (r, i) {
    if (i > 0) {
      ringStrings += ', ';
    }

    ringStrings += '(' + r.map(function (p) {
      return p.x + ' ' + p.y;
    }).join(', ') + ')';
  });
  return 'POLYGON (' + ringStrings + ')';
};
/**
 * Returns a JSON representation of this geo-spatial type.
 */


Polygon$2.prototype.toJSON = function () {
  return {
    type: 'Polygon',
    coordinates: this.rings.map(function (r) {
      return r.map(function (p) {
        return [p.x, p.y];
      });
    })
  };
};

var polygon = Polygon$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Geometry module.
 * <p>
 *   Contains the classes to represent the set of additional CQL types for geospatial data that come with
 *   DSE 5.0.
 * </p>
 * @module geometry
 */


geometry$1.Geometry = geometry;
geometry$1.LineString = lineString;
geometry$1.Point = point;
geometry$1.Polygon = polygon;

var util$k = require$$0__default$1["default"];
var types$l = types$u;
var dataTypes$4 = types$l.dataTypes;
var Long$1 = types$l.Long;
var Integer$1 = types$l.Integer;
var BigDecimal = types$l.BigDecimal;
var MutableLong$1 = mutableLong;
var utils$t = utils$V;
var token$1 = token$2;
var DateRange = search.DateRange;
var geo = geometry$1;
var Geometry = geo.Geometry;
var LineString$1 = geo.LineString;
var Point$1 = geo.Point;
var Polygon$1 = geo.Polygon;
var uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
var buffers = {
  int16Zero: utils$t.allocBufferFromArray([0, 0]),
  int32Zero: utils$t.allocBufferFromArray([0, 0, 0, 0]),
  int8Zero: utils$t.allocBufferFromArray([0]),
  int8One: utils$t.allocBufferFromArray([1]),
  int8MaxValue: utils$t.allocBufferFromArray([0xff])
}; // BigInt: Avoid using literals (e.g., 32n) as we must be able to compile with older engines

var isBigIntSupported = typeof BigInt !== 'undefined';
var bigInt32 = isBigIntSupported ? BigInt(32) : null;
var bigInt8 = isBigIntSupported ? BigInt(8) : null;
var bigInt0 = isBigIntSupported ? BigInt(0) : null;
var bigIntMinus1 = isBigIntSupported ? BigInt(-1) : null;
var bigInt32BitsOn = isBigIntSupported ? BigInt(0xffffffff) : null;
var bigInt8BitsOn = isBigIntSupported ? BigInt(0xff) : null;
var complexTypeNames = Object.freeze({
  list: 'org.apache.cassandra.db.marshal.ListType',
  set: 'org.apache.cassandra.db.marshal.SetType',
  map: 'org.apache.cassandra.db.marshal.MapType',
  udt: 'org.apache.cassandra.db.marshal.UserType',
  tuple: 'org.apache.cassandra.db.marshal.TupleType',
  frozen: 'org.apache.cassandra.db.marshal.FrozenType',
  reversed: 'org.apache.cassandra.db.marshal.ReversedType',
  composite: 'org.apache.cassandra.db.marshal.CompositeType',
  empty: 'org.apache.cassandra.db.marshal.EmptyType',
  collection: 'org.apache.cassandra.db.marshal.ColumnToCollectionType'
});
var cqlNames = Object.freeze({
  frozen: 'frozen',
  list: 'list',
  'set': 'set',
  map: 'map',
  tuple: 'tuple',
  empty: 'empty',
  duration: 'duration'
});
var singleTypeNames = Object.freeze({
  'org.apache.cassandra.db.marshal.UTF8Type': dataTypes$4.varchar,
  'org.apache.cassandra.db.marshal.AsciiType': dataTypes$4.ascii,
  'org.apache.cassandra.db.marshal.UUIDType': dataTypes$4.uuid,
  'org.apache.cassandra.db.marshal.TimeUUIDType': dataTypes$4.timeuuid,
  'org.apache.cassandra.db.marshal.Int32Type': dataTypes$4["int"],
  'org.apache.cassandra.db.marshal.BytesType': dataTypes$4.blob,
  'org.apache.cassandra.db.marshal.FloatType': dataTypes$4["float"],
  'org.apache.cassandra.db.marshal.DoubleType': dataTypes$4["double"],
  'org.apache.cassandra.db.marshal.BooleanType': dataTypes$4["boolean"],
  'org.apache.cassandra.db.marshal.InetAddressType': dataTypes$4.inet,
  'org.apache.cassandra.db.marshal.SimpleDateType': dataTypes$4.date,
  'org.apache.cassandra.db.marshal.TimeType': dataTypes$4.time,
  'org.apache.cassandra.db.marshal.ShortType': dataTypes$4.smallint,
  'org.apache.cassandra.db.marshal.ByteType': dataTypes$4.tinyint,
  'org.apache.cassandra.db.marshal.DateType': dataTypes$4.timestamp,
  'org.apache.cassandra.db.marshal.TimestampType': dataTypes$4.timestamp,
  'org.apache.cassandra.db.marshal.LongType': dataTypes$4.bigint,
  'org.apache.cassandra.db.marshal.DecimalType': dataTypes$4.decimal,
  'org.apache.cassandra.db.marshal.IntegerType': dataTypes$4.varint,
  'org.apache.cassandra.db.marshal.CounterColumnType': dataTypes$4.counter
});
var singleFqTypeNamesLength = Object.keys(singleTypeNames).reduce(function (previous, current) {
  return current.length > previous ? current.length : previous;
}, 0);
var customTypeNames = Object.freeze({
  duration: 'org.apache.cassandra.db.marshal.DurationType',
  lineString: 'org.apache.cassandra.db.marshal.LineStringType',
  point: 'org.apache.cassandra.db.marshal.PointType',
  polygon: 'org.apache.cassandra.db.marshal.PolygonType',
  dateRange: 'org.apache.cassandra.db.marshal.DateRangeType'
});
var nullValueBuffer = utils$t.allocBufferFromArray([255, 255, 255, 255]);
var unsetValueBuffer = utils$t.allocBufferFromArray([255, 255, 255, 254]);
/**
 * For backwards compatibility, empty buffers as text/blob/custom values are supported.
 * In the case of other types, they are going to be decoded as a <code>null</code> value.
 * @private
 * @type {Set}
 */

var zeroLengthTypesSupported = new Set([dataTypes$4.text, dataTypes$4.ascii, dataTypes$4.varchar, dataTypes$4.custom, dataTypes$4.blob]);
/**
 * Serializes and deserializes to and from a CQL type and a Javascript Type.
 * @param {Number} protocolVersion
 * @param {ClientOptions} options
 * @constructor
 */

function Encoder$2(protocolVersion, options) {
  this.encodingOptions = options.encoding || utils$t.emptyObject;
  defineInstanceMembers.call(this);
  this.setProtocolVersion(protocolVersion);
  setEncoders.call(this);

  if (this.encodingOptions.copyBuffer) {
    this.handleBuffer = handleBufferCopy;
  } else {
    this.handleBuffer = handleBufferRef;
  }
}
/**
 * Declares the privileged instance members.
 * @private
 */


function defineInstanceMembers() {
  var _customDecoders, _customEncoders;

  /**
   * Sets the protocol version and the encoding/decoding methods depending on the protocol version
   * @param {Number} value
   * @ignore
   * @internal
   */
  this.setProtocolVersion = function (value) {
    this.protocolVersion = value; //Set the collection serialization based on the protocol version

    this.decodeCollectionLength = decodeCollectionLengthV3;
    this.getLengthBuffer = getLengthBufferV3;
    this.collectionLengthSize = 4;

    if (!types$l.protocolVersion.uses4BytesCollectionLength(this.protocolVersion)) {
      this.decodeCollectionLength = decodeCollectionLengthV2;
      this.getLengthBuffer = getLengthBufferV2;
      this.collectionLengthSize = 2;
    }
  };

  var customDecoders = (_customDecoders = {}, _defineProperty(_customDecoders, customTypeNames.duration, decodeDuration), _defineProperty(_customDecoders, customTypeNames.lineString, decodeLineString), _defineProperty(_customDecoders, customTypeNames.point, decodePoint), _defineProperty(_customDecoders, customTypeNames.polygon, decodePolygon), _defineProperty(_customDecoders, customTypeNames.dateRange, decodeDateRange), _customDecoders);
  var customEncoders = (_customEncoders = {}, _defineProperty(_customEncoders, customTypeNames.duration, encodeDuration), _defineProperty(_customEncoders, customTypeNames.lineString, encodeLineString), _defineProperty(_customEncoders, customTypeNames.point, encodePoint), _defineProperty(_customEncoders, customTypeNames.polygon, encodePolygon), _defineProperty(_customEncoders, customTypeNames.dateRange, encodeDateRange), _customEncoders); // Decoding methods

  this.decodeBlob = function (bytes) {
    return this.handleBuffer(bytes);
  };

  this.decodeCustom = function (bytes, typeName) {
    var handler = customDecoders[typeName];

    if (handler) {
      return handler.call(this, bytes);
    }

    return this.handleBuffer(bytes);
  };

  this.decodeUtf8String = function (bytes) {
    return bytes.toString('utf8');
  };

  this.decodeAsciiString = function (bytes) {
    return bytes.toString('ascii');
  };

  this.decodeBoolean = function (bytes) {
    return !!bytes.readUInt8(0);
  };

  this.decodeDouble = function (bytes) {
    return bytes.readDoubleBE(0);
  };

  this.decodeFloat = function (bytes) {
    return bytes.readFloatBE(0);
  };

  this.decodeInt = function (bytes) {
    return bytes.readInt32BE(0);
  };

  this.decodeSmallint = function (bytes) {
    return bytes.readInt16BE(0);
  };

  this.decodeTinyint = function (bytes) {
    return bytes.readInt8(0);
  };

  this._decodeCqlLongAsLong = function (bytes) {
    return Long$1.fromBuffer(bytes);
  };

  this._decodeCqlLongAsBigInt = function (bytes) {
    return BigInt.asIntN(64, BigInt(bytes.readUInt32BE(0)) << bigInt32 | BigInt(bytes.readUInt32BE(4)));
  };

  this.decodeLong = this.encodingOptions.useBigIntAsLong ? this._decodeCqlLongAsBigInt : this._decodeCqlLongAsLong;

  this._decodeVarintAsInteger = function (bytes) {
    return Integer$1.fromBuffer(bytes);
  };

  this._decodeVarintAsBigInt = function decodeVarintAsBigInt(bytes) {
    var result = bigInt0;

    if (bytes[0] <= 0x7f) {
      for (var i = 0; i < bytes.length; i++) {
        var b = BigInt(bytes[bytes.length - 1 - i]);
        result = result | b << BigInt(i * 8);
      }
    } else {
      for (var _i = 0; _i < bytes.length; _i++) {
        var _b = BigInt(bytes[bytes.length - 1 - _i]);

        result = result | (~_b & bigInt8BitsOn) << BigInt(_i * 8);
      }

      result = ~result;
    }

    return result;
  };

  this.decodeVarint = this.encodingOptions.useBigIntAsVarint ? this._decodeVarintAsBigInt : this._decodeVarintAsInteger;

  this.decodeDecimal = function (bytes) {
    return BigDecimal.fromBuffer(bytes);
  };

  this.decodeTimestamp = function (bytes) {
    return new Date(this._decodeCqlLongAsLong(bytes).toNumber());
  };

  this.decodeDate = function (bytes) {
    return types$l.LocalDate.fromBuffer(bytes);
  };

  this.decodeTime = function (bytes) {
    return types$l.LocalTime.fromBuffer(bytes);
  };
  /*
   * Reads a list from bytes
   */


  this.decodeList = function (bytes, subtype) {
    var totalItems = this.decodeCollectionLength(bytes, 0);
    var offset = this.collectionLengthSize;
    var list = new Array(totalItems);

    for (var i = 0; i < totalItems; i++) {
      //bytes length of the item
      var length = this.decodeCollectionLength(bytes, offset);
      offset += this.collectionLengthSize; //slice it

      list[i] = this.decode(bytes.slice(offset, offset + length), subtype);
      offset += length;
    }

    return list;
  };
  /*
   * Reads a Set from bytes
   */


  this.decodeSet = function (bytes, subtype) {
    var arr = this.decodeList(bytes, subtype);

    if (this.encodingOptions.set) {
      var setConstructor = this.encodingOptions.set;
      return new setConstructor(arr);
    }

    return arr;
  };
  /*
   * Reads a map (key / value) from bytes
   */


  this.decodeMap = function (bytes, subtypes) {
    var map;
    var totalItems = this.decodeCollectionLength(bytes, 0);
    var offset = this.collectionLengthSize;
    var self = this;

    function readValues(callback, thisArg) {
      for (var i = 0; i < totalItems; i++) {
        var keyLength = self.decodeCollectionLength(bytes, offset);
        offset += self.collectionLengthSize;
        var key = self.decode(bytes.slice(offset, offset + keyLength), subtypes[0]);
        offset += keyLength;
        var valueLength = self.decodeCollectionLength(bytes, offset);
        offset += self.collectionLengthSize;

        if (valueLength < 0) {
          callback.call(thisArg, key, null);
          continue;
        }

        var value = self.decode(bytes.slice(offset, offset + valueLength), subtypes[1]);
        offset += valueLength;
        callback.call(thisArg, key, value);
      }
    }

    if (this.encodingOptions.map) {
      var mapConstructor = this.encodingOptions.map;
      map = new mapConstructor();
      readValues(map.set, map);
    } else {
      map = {};
      readValues(function (key, value) {
        map[key] = value;
      });
    }

    return map;
  };

  this.decodeUuid = function (bytes) {
    return new types$l.Uuid(this.handleBuffer(bytes));
  };

  this.decodeTimeUuid = function (bytes) {
    return new types$l.TimeUuid(this.handleBuffer(bytes));
  };

  this.decodeInet = function (bytes) {
    return new types$l.InetAddress(this.handleBuffer(bytes));
  };
  /**
   * Decodes a user defined type into an object
   * @param {Buffer} bytes
   * @param {{fields: Array}} udtInfo
   * @private
   */


  this.decodeUdt = function (bytes, udtInfo) {
    var result = {};
    var offset = 0;

    for (var i = 0; i < udtInfo.fields.length && offset < bytes.length; i++) {
      //bytes length of the field value
      var length = bytes.readInt32BE(offset);
      offset += 4; //slice it

      var field = udtInfo.fields[i];

      if (length < 0) {
        result[field.name] = null;
        continue;
      }

      result[field.name] = this.decode(bytes.slice(offset, offset + length), field.type);
      offset += length;
    }

    return result;
  };

  this.decodeTuple = function (bytes, tupleInfo) {
    var elements = new Array(tupleInfo.length);
    var offset = 0;

    for (var i = 0; i < tupleInfo.length && offset < bytes.length; i++) {
      var length = bytes.readInt32BE(offset);
      offset += 4;

      if (length < 0) {
        elements[i] = null;
        continue;
      }

      elements[i] = this.decode(bytes.slice(offset, offset + length), tupleInfo[i]);
      offset += length;
    }

    return types$l.Tuple.fromArray(elements);
  }; //Encoding methods


  this.encodeFloat = function (value) {
    if (typeof value === 'string') {
      // All numeric types are supported as strings for historical reasons
      value = parseFloat(value);

      if (Number.isNaN(value)) {
        throw new TypeError("Expected string representation of a number, obtained ".concat(util$k.inspect(value)));
      }
    }

    if (typeof value !== 'number') {
      throw new TypeError('Expected Number, obtained ' + util$k.inspect(value));
    }

    var buf = utils$t.allocBufferUnsafe(4);
    buf.writeFloatBE(value, 0);
    return buf;
  };

  this.encodeDouble = function (value) {
    if (typeof value === 'string') {
      // All numeric types are supported as strings for historical reasons
      value = parseFloat(value);

      if (Number.isNaN(value)) {
        throw new TypeError("Expected string representation of a number, obtained ".concat(util$k.inspect(value)));
      }
    }

    if (typeof value !== 'number') {
      throw new TypeError('Expected Number, obtained ' + util$k.inspect(value));
    }

    var buf = utils$t.allocBufferUnsafe(8);
    buf.writeDoubleBE(value, 0);
    return buf;
  };
  /**
   * @param {Date|String|Long|Number} value
   * @private
   */


  this.encodeTimestamp = function (value) {
    var originalValue = value;

    if (typeof value === 'string') {
      value = new Date(value);
    }

    if (value instanceof Date) {
      //milliseconds since epoch
      value = value.getTime();

      if (isNaN(value)) {
        throw new TypeError('Invalid date: ' + originalValue);
      }
    }

    if (this.encodingOptions.useBigIntAsLong) {
      value = BigInt(value);
    }

    return this.encodeLong(value);
  };
  /**
   * @param {Date|String|LocalDate} value
   * @returns {Buffer}
   * @throws {TypeError}
   * @private
   */


  this.encodeDate = function (value) {
    var originalValue = value;

    try {
      if (typeof value === 'string') {
        value = types$l.LocalDate.fromString(value);
      }

      if (value instanceof Date) {
        value = types$l.LocalDate.fromDate(value);
      }
    } catch (err) {
      //Wrap into a TypeError
      throw new TypeError('LocalDate could not be parsed ' + err);
    }

    if (!(value instanceof types$l.LocalDate)) {
      throw new TypeError('Expected Date/String/LocalDate, obtained ' + util$k.inspect(originalValue));
    }

    return value.toBuffer();
  };
  /**
   * @param {String|LocalDate} value
   * @returns {Buffer}
   * @throws {TypeError}
   * @private
   */


  this.encodeTime = function (value) {
    var originalValue = value;

    try {
      if (typeof value === 'string') {
        value = types$l.LocalTime.fromString(value);
      }
    } catch (err) {
      //Wrap into a TypeError
      throw new TypeError('LocalTime could not be parsed ' + err);
    }

    if (!(value instanceof types$l.LocalTime)) {
      throw new TypeError('Expected String/LocalTime, obtained ' + util$k.inspect(originalValue));
    }

    return value.toBuffer();
  };
  /**
   * @param {Uuid|String|Buffer} value
   * @private
   */


  this.encodeUuid = function (value) {
    if (typeof value === 'string') {
      try {
        value = types$l.Uuid.fromString(value).getBuffer();
      } catch (err) {
        throw new TypeError(err.message);
      }
    } else if (value instanceof types$l.Uuid) {
      value = value.getBuffer();
    } else {
      throw new TypeError('Not a valid Uuid, expected Uuid/String/Buffer, obtained ' + util$k.inspect(value));
    }

    return value;
  };
  /**
   * @param {String|InetAddress|Buffer} value
   * @returns {Buffer}
   * @private
   */


  this.encodeInet = function (value) {
    if (typeof value === 'string') {
      value = types$l.InetAddress.fromString(value);
    }

    if (value instanceof types$l.InetAddress) {
      value = value.getBuffer();
    }

    if (!(value instanceof Buffer)) {
      throw new TypeError('Not a valid Inet, expected InetAddress/Buffer, obtained ' + util$k.inspect(value));
    }

    return value;
  };
  /**
   * @param {Long|Buffer|String|Number} value
   * @private
   */


  this._encodeBigIntFromLong = function (value) {
    if (typeof value === 'number') {
      value = Long$1.fromNumber(value);
    } else if (typeof value === 'string') {
      value = Long$1.fromString(value);
    }

    var buf = null;

    if (value instanceof Long$1) {
      buf = Long$1.toBuffer(value);
    } else if (value instanceof MutableLong$1) {
      buf = Long$1.toBuffer(value.toImmutable());
    }

    if (buf === null) {
      throw new TypeError('Not a valid bigint, expected Long/Number/String/Buffer, obtained ' + util$k.inspect(value));
    }

    return buf;
  };

  this._encodeBigIntFromBigInt = function (value) {
    if (typeof value === 'string') {
      // All numeric types are supported as strings for historical reasons
      value = BigInt(value);
    } // eslint-disable-next-line valid-typeof


    if (typeof value !== 'bigint') {
      // Only BigInt values are supported
      throw new TypeError('Not a valid BigInt value, obtained ' + util$k.inspect(value));
    }

    var buffer = utils$t.allocBufferUnsafe(8);
    buffer.writeUInt32BE(Number(value >> bigInt32) >>> 0, 0);
    buffer.writeUInt32BE(Number(value & bigInt32BitsOn), 4);
    return buffer;
  };

  this.encodeLong = this.encodingOptions.useBigIntAsLong ? this._encodeBigIntFromBigInt : this._encodeBigIntFromLong;
  /**
   * @param {Integer|Buffer|String|Number} value
   * @returns {Buffer}
   * @private
   */

  this._encodeVarintFromInteger = function (value) {
    if (typeof value === 'number') {
      value = Integer$1.fromNumber(value);
    }

    if (typeof value === 'string') {
      value = Integer$1.fromString(value);
    }

    var buf = null;

    if (value instanceof Buffer) {
      buf = value;
    }

    if (value instanceof Integer$1) {
      buf = Integer$1.toBuffer(value);
    }

    if (buf === null) {
      throw new TypeError('Not a valid varint, expected Integer/Number/String/Buffer, obtained ' + util$k.inspect(value));
    }

    return buf;
  };

  this._encodeVarintFromBigInt = function (value) {
    if (typeof value === 'string') {
      // All numeric types are supported as strings for historical reasons
      value = BigInt(value);
    } // eslint-disable-next-line valid-typeof


    if (typeof value !== 'bigint') {
      throw new TypeError('Not a valid varint, expected BigInt, obtained ' + util$k.inspect(value));
    }

    if (value === bigInt0) {
      return buffers.int8Zero;
    } else if (value === bigIntMinus1) {
      return buffers.int8MaxValue;
    }

    var parts = [];

    if (value > bigInt0) {
      while (value !== bigInt0) {
        parts.unshift(Number(value & bigInt8BitsOn));
        value = value >> bigInt8;
      }

      if (parts[0] > 0x7f) {
        // Positive value needs a padding
        parts.unshift(0);
      }
    } else {
      while (value !== bigIntMinus1) {
        parts.unshift(Number(value & bigInt8BitsOn));
        value = value >> bigInt8;
      }

      if (parts[0] <= 0x7f) {
        // Negative value needs a padding
        parts.unshift(0xff);
      }
    }

    return utils$t.allocBufferFromArray(parts);
  };

  this.encodeVarint = this.encodingOptions.useBigIntAsVarint ? this._encodeVarintFromBigInt : this._encodeVarintFromInteger;
  /**
   * @param {BigDecimal|Buffer|String|Number} value
   * @returns {Buffer}
   * @private
   */

  this.encodeDecimal = function (value) {
    if (typeof value === 'number') {
      value = BigDecimal.fromNumber(value);
    } else if (typeof value === 'string') {
      value = BigDecimal.fromString(value);
    }

    var buf = null;

    if (value instanceof BigDecimal) {
      buf = BigDecimal.toBuffer(value);
    } else {
      throw new TypeError('Not a valid varint, expected BigDecimal/Number/String/Buffer, obtained ' + util$k.inspect(value));
    }

    return buf;
  };

  this.encodeString = function (value, encoding) {
    if (typeof value !== 'string') {
      throw new TypeError('Not a valid text value, expected String obtained ' + util$k.inspect(value));
    }

    return utils$t.allocBufferFromString(value, encoding);
  };

  this.encodeUtf8String = function (value) {
    return this.encodeString(value, 'utf8');
  };

  this.encodeAsciiString = function (value) {
    return this.encodeString(value, 'ascii');
  };

  this.encodeBlob = function (value) {
    if (!(value instanceof Buffer)) {
      throw new TypeError('Not a valid blob, expected Buffer obtained ' + util$k.inspect(value));
    }

    return value;
  };

  this.encodeCustom = function (value, name) {
    var handler = customEncoders[name];

    if (handler) {
      return handler.call(this, value);
    }

    throw new TypeError('No encoding handler found for type ' + name);
  };
  /**
   * @param {Boolean} value
   * @returns {Buffer}
   * @private
   */


  this.encodeBoolean = function (value) {
    return value ? buffers.int8One : buffers.int8Zero;
  };
  /**
   * @param {Number|String} value
   * @private
   */


  this.encodeInt = function (value) {
    if (isNaN(value)) {
      throw new TypeError('Expected Number, obtained ' + util$k.inspect(value));
    }

    var buf = utils$t.allocBufferUnsafe(4);
    buf.writeInt32BE(value, 0);
    return buf;
  };
  /**
   * @param {Number|String} value
   * @private
   */


  this.encodeSmallint = function (value) {
    if (isNaN(value)) {
      throw new TypeError('Expected Number, obtained ' + util$k.inspect(value));
    }

    var buf = utils$t.allocBufferUnsafe(2);
    buf.writeInt16BE(value, 0);
    return buf;
  };
  /**
   * @param {Number|String} value
   * @private
   */


  this.encodeTinyint = function (value) {
    if (isNaN(value)) {
      throw new TypeError('Expected Number, obtained ' + util$k.inspect(value));
    }

    var buf = utils$t.allocBufferUnsafe(1);
    buf.writeInt8(value, 0);
    return buf;
  };

  this.encodeList = function (value, subtype) {
    if (!Array.isArray(value)) {
      throw new TypeError('Not a valid list value, expected Array obtained ' + util$k.inspect(value));
    }

    if (value.length === 0) {
      return null;
    }

    var parts = [];
    parts.push(this.getLengthBuffer(value));

    for (var i = 0; i < value.length; i++) {
      var val = value[i];

      if (val === null || typeof val === 'undefined' || val === types$l.unset) {
        throw new TypeError('A collection can\'t contain null or unset values');
      }

      var bytes = this.encode(val, subtype); //include item byte length

      parts.push(this.getLengthBuffer(bytes)); //include item

      parts.push(bytes);
    }

    return Buffer.concat(parts);
  };

  this.encodeSet = function (value, subtype) {
    if (this.encodingOptions.set && value instanceof this.encodingOptions.set) {
      var arr = [];
      value.forEach(function (x) {
        arr.push(x);
      });
      return this.encodeList(arr, subtype);
    }

    return this.encodeList(value, subtype);
  };
  /**
   * Serializes a map into a Buffer
   * @param value
   * @param {Array} [subtypes]
   * @returns {Buffer}
   * @private
   */


  this.encodeMap = function (value, subtypes) {
    var parts = [];
    var propCounter = 0;
    var keySubtype = null;
    var valueSubtype = null;
    var self = this;

    if (subtypes) {
      keySubtype = subtypes[0];
      valueSubtype = subtypes[1];
    }

    function addItem(val, key) {
      if (key === null || typeof key === 'undefined' || key === types$l.unset) {
        throw new TypeError('A map can\'t contain null or unset keys');
      }

      if (val === null || typeof val === 'undefined' || val === types$l.unset) {
        throw new TypeError('A map can\'t contain null or unset values');
      }

      var keyBuffer = self.encode(key, keySubtype); //include item byte length

      parts.push(self.getLengthBuffer(keyBuffer)); //include item

      parts.push(keyBuffer); //value

      var valueBuffer = self.encode(val, valueSubtype); //include item byte length

      parts.push(self.getLengthBuffer(valueBuffer)); //include item

      if (valueBuffer !== null) {
        parts.push(valueBuffer);
      }

      propCounter++;
    }

    if (this.encodingOptions.map && value instanceof this.encodingOptions.map) {
      //Use Map#forEach() method to iterate
      value.forEach(addItem);
    } else {
      //Use object
      for (var key in value) {
        if (!value.hasOwnProperty(key)) {
          continue;
        }

        var val = value[key];
        addItem(val, key);
      }
    }

    parts.unshift(this.getLengthBuffer(propCounter));
    return Buffer.concat(parts);
  };

  this.encodeUdt = function (value, udtInfo) {
    var parts = [];
    var totalLength = 0;

    for (var i = 0; i < udtInfo.fields.length; i++) {
      var field = udtInfo.fields[i];
      var item = this.encode(value[field.name], field.type);

      if (!item) {
        parts.push(nullValueBuffer);
        totalLength += 4;
        continue;
      }

      if (item === types$l.unset) {
        parts.push(unsetValueBuffer);
        totalLength += 4;
        continue;
      }

      var lengthBuffer = utils$t.allocBufferUnsafe(4);
      lengthBuffer.writeInt32BE(item.length, 0);
      parts.push(lengthBuffer);
      parts.push(item);
      totalLength += item.length + 4;
    }

    return Buffer.concat(parts, totalLength);
  };

  this.encodeTuple = function (value, tupleInfo) {
    var parts = [];
    var totalLength = 0;
    var length = Math.min(tupleInfo.length, value.length);

    for (var i = 0; i < length; i++) {
      var type = tupleInfo[i];
      var item = this.encode(value.get(i), type);

      if (!item) {
        parts.push(nullValueBuffer);
        totalLength += 4;
        continue;
      }

      if (item === types$l.unset) {
        parts.push(unsetValueBuffer);
        totalLength += 4;
        continue;
      }

      var lengthBuffer = utils$t.allocBufferUnsafe(4);
      lengthBuffer.writeInt32BE(item.length, 0);
      parts.push(lengthBuffer);
      parts.push(item);
      totalLength += item.length + 4;
    }

    return Buffer.concat(parts, totalLength);
  };
  /**
   * If not provided, it uses the array of buffers or the parameters and hints to build the routingKey
   * @param {Array} params
   * @param {ExecutionOptions} execOptions
   * @param [keys] parameter keys and positions in the params array
   * @throws TypeError
   * @internal
   * @ignore
   */


  this.setRoutingKeyFromUser = function (params, execOptions, keys) {
    var _this = this;

    var totalLength = 0;
    var userRoutingKey = execOptions.getRoutingKey();

    if (Array.isArray(userRoutingKey)) {
      if (userRoutingKey.length === 1) {
        execOptions.setRoutingKey(userRoutingKey[0]);
        return;
      } // Its a composite routing key


      totalLength = 0;

      for (var i = 0; i < userRoutingKey.length; i++) {
        var item = userRoutingKey[i];

        if (!item) {
          // Invalid routing key part provided by the user, clear the value
          execOptions.setRoutingKey(null);
          return;
        }

        totalLength += item.length + 3;
      }

      execOptions.setRoutingKey(concatRoutingKey(userRoutingKey, totalLength));
      return;
    } // If routingKey is present, ensure it is a Buffer, Token, or TokenRange.  Otherwise throw an error.


    if (userRoutingKey) {
      if (userRoutingKey instanceof Buffer || userRoutingKey instanceof token$1.Token || userRoutingKey instanceof token$1.TokenRange) {
        return;
      }

      throw new TypeError("Unexpected routingKey '".concat(util$k.inspect(userRoutingKey), "' provided. ") + "Expected Buffer, Array<Buffer>, Token, or TokenRange.");
    } // If no params are present, return as routing key cannot be determined.


    if (!params || params.length === 0) {
      return;
    }

    var routingIndexes = execOptions.getRoutingIndexes();

    if (execOptions.getRoutingNames()) {
      routingIndexes = execOptions.getRoutingNames().map(function (k) {
        return keys[k];
      });
    }

    if (!routingIndexes) {
      return;
    }

    var parts = [];
    var hints = execOptions.getHints() || utils$t.emptyArray;
    var encodeParam = !keys ? function (i) {
      return _this.encode(params[i], hints[i]);
    } : function (i) {
      return _this.encode(params[i].value, hints[i]);
    };

    try {
      totalLength = this._encodeRoutingKeyParts(parts, routingIndexes, encodeParam);
    } catch (e) {// There was an error encoding a parameter that is part of the routing key,
      // ignore now to fail afterwards
    }

    if (totalLength === 0) {
      return;
    }

    execOptions.setRoutingKey(concatRoutingKey(parts, totalLength));
  };
  /**
   * Sets the routing key in the options based on the prepared statement metadata.
   * @param {Object} meta Prepared metadata
   * @param {Array} params Array of parameters
   * @param {ExecutionOptions} execOptions
   * @throws TypeError
   * @internal
   * @ignore
   */


  this.setRoutingKeyFromMeta = function (meta, params, execOptions) {
    var _this2 = this;

    var routingIndexes = execOptions.getRoutingIndexes();

    if (!routingIndexes) {
      return;
    }

    var parts = new Array(routingIndexes.length);

    var encodeParam = function encodeParam(i) {
      var columnInfo = meta.columns[i];
      return _this2.encode(params[i], columnInfo ? columnInfo.type : null);
    };

    var totalLength = 0;

    try {
      totalLength = this._encodeRoutingKeyParts(parts, routingIndexes, encodeParam);
    } catch (e) {// There was an error encoding a parameter that is part of the routing key,
      // ignore now to fail afterwards
    }

    if (totalLength === 0) {
      return;
    }

    execOptions.setRoutingKey(concatRoutingKey(parts, totalLength));
  };
  /**
   * @param {Array} parts
   * @param {Array} routingIndexes
   * @param {Function} encodeParam
   * @returns {Number} The total length
   * @private
   */


  this._encodeRoutingKeyParts = function (parts, routingIndexes, encodeParam) {
    var totalLength = 0;

    for (var i = 0; i < routingIndexes.length; i++) {
      var paramIndex = routingIndexes[i];

      if (paramIndex === undefined) {
        // Bad input from the user, ignore
        return 0;
      }

      var item = encodeParam(paramIndex);

      if (item === null || item === undefined || item === types$l.unset) {
        // The encoded partition key should an instance of Buffer
        // Let it fail later in the pipeline for null/undefined parameter values
        return 0;
      } // Per each part of the routing key, 3 extra bytes are needed


      totalLength += item.length + 3;
      parts[i] = item;
    }

    return totalLength;
  };
  /**
   * Parses a CQL name string into data type information
   * @param {String} keyspace
   * @param {String} typeName
   * @param {Number} startIndex
   * @param {Number|null} length
   * @param {Function} udtResolver
   * @returns {Promise<{err, info, options}>} callback Callback invoked with err and  {{code: number, info: Object|Array|null, options: {frozen: Boolean}}}
   * @internal
   * @ignore
   */


  this.parseTypeName = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(keyspace, typeName, startIndex, length, udtResolver) {
      var dataType, innerTypes, quoted, typeCode, udtInfo;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              startIndex = startIndex || 0;

              if (!length) {
                length = typeName.length;
              }

              dataType = {
                code: 0,
                info: null,
                options: {
                  frozen: false
                }
              };

              if (!(typeName.indexOf("'", startIndex) === startIndex)) {
                _context.next = 6;
                break;
              }

              //If quoted, this is a custom type.
              dataType.info = typeName.substr(startIndex + 1, length - 2);
              return _context.abrupt("return", dataType);

            case 6:
              if (!length) {
                length = typeName.length;
              }

              if (typeName.indexOf(cqlNames.frozen, startIndex) === startIndex) {
                //Remove the frozen token
                startIndex += cqlNames.frozen.length + 1;
                length -= cqlNames.frozen.length + 2;
                dataType.options.frozen = true;
              }

              if (!(typeName.indexOf(cqlNames.list, startIndex) === startIndex)) {
                _context.next = 19;
                break;
              }

              //move cursor across the name and bypass the angle brackets
              startIndex += cqlNames.list.length + 1;
              length -= cqlNames.list.length + 2;
              innerTypes = parseParams(typeName, startIndex, length, '<', '>');

              if (!(innerTypes.length !== 1)) {
                _context.next = 14;
                break;
              }

              throw new TypeError('Not a valid type ' + typeName);

            case 14:
              dataType.code = dataTypes$4.list;
              _context.next = 17;
              return this.parseTypeName(keyspace, innerTypes[0], 0, null, udtResolver);

            case 17:
              dataType.info = _context.sent;
              return _context.abrupt("return", dataType);

            case 19:
              if (!(typeName.indexOf(cqlNames.set, startIndex) === startIndex)) {
                _context.next = 30;
                break;
              }

              //move cursor across the name and bypass the angle brackets
              startIndex += cqlNames.set.length + 1;
              length -= cqlNames.set.length + 2;
              innerTypes = parseParams(typeName, startIndex, length, '<', '>');

              if (!(innerTypes.length !== 1)) {
                _context.next = 25;
                break;
              }

              throw new TypeError('Not a valid type ' + typeName);

            case 25:
              dataType.code = dataTypes$4.set;
              _context.next = 28;
              return this.parseTypeName(keyspace, innerTypes[0], 0, null, udtResolver);

            case 28:
              dataType.info = _context.sent;
              return _context.abrupt("return", dataType);

            case 30:
              if (!(typeName.indexOf(cqlNames.map, startIndex) === startIndex)) {
                _context.next = 41;
                break;
              }

              //move cursor across the name and bypass the angle brackets
              startIndex += cqlNames.map.length + 1;
              length -= cqlNames.map.length + 2;
              innerTypes = parseParams(typeName, startIndex, length, '<', '>'); //It should contain the key and value types

              if (!(innerTypes.length !== 2)) {
                _context.next = 36;
                break;
              }

              throw new TypeError('Not a valid type ' + typeName);

            case 36:
              dataType.code = dataTypes$4.map;
              _context.next = 39;
              return this._parseChildTypes(keyspace, innerTypes, udtResolver);

            case 39:
              dataType.info = _context.sent;
              return _context.abrupt("return", dataType);

            case 41:
              if (!(typeName.indexOf(cqlNames.tuple, startIndex) === startIndex)) {
                _context.next = 52;
                break;
              }

              //move cursor across the name and bypass the angle brackets
              startIndex += cqlNames.tuple.length + 1;
              length -= cqlNames.tuple.length + 2;
              innerTypes = parseParams(typeName, startIndex, length, '<', '>');

              if (!(innerTypes.length < 1)) {
                _context.next = 47;
                break;
              }

              throw new TypeError('Not a valid type ' + typeName);

            case 47:
              dataType.code = dataTypes$4.tuple;
              _context.next = 50;
              return this._parseChildTypes(keyspace, innerTypes, udtResolver);

            case 50:
              dataType.info = _context.sent;
              return _context.abrupt("return", dataType);

            case 52:
              quoted = typeName.indexOf('"', startIndex) === startIndex;

              if (quoted) {
                // Remove quotes
                startIndex++;
                length -= 2;
              } // Quick check if its a single type


              if (startIndex > 0) {
                typeName = typeName.substr(startIndex, length);
              } // Un-escape double quotes if quoted.


              if (quoted) {
                typeName = typeName.replace('""', '"');
              }

              typeCode = dataTypes$4[typeName];

              if (!(typeof typeCode === 'number')) {
                _context.next = 60;
                break;
              }

              dataType.code = typeCode;
              return _context.abrupt("return", dataType);

            case 60:
              if (!(typeName === cqlNames.duration)) {
                _context.next = 63;
                break;
              }

              dataType.info = customTypeNames.duration;
              return _context.abrupt("return", dataType);

            case 63:
              if (!(typeName === cqlNames.empty)) {
                _context.next = 66;
                break;
              }

              // Set as custom
              dataType.info = 'empty';
              return _context.abrupt("return", dataType);

            case 66:
              _context.next = 68;
              return udtResolver(keyspace, typeName);

            case 68:
              udtInfo = _context.sent;

              if (!udtInfo) {
                _context.next = 73;
                break;
              }

              dataType.code = dataTypes$4.udt;
              dataType.info = udtInfo;
              return _context.abrupt("return", dataType);

            case 73:
              throw new TypeError('Not a valid type "' + typeName + '"');

            case 74:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    return function (_x, _x2, _x3, _x4, _x5) {
      return _ref.apply(this, arguments);
    };
  }();
  /**
   * @param {String} keyspace
   * @param {Array} typeNames
   * @param {Function} udtResolver
   * @returns {Promise}
   * @private
   */


  this._parseChildTypes = function (keyspace, typeNames, udtResolver) {
    var _this3 = this;

    return Promise.all(typeNames.map(function (name) {
      return _this3.parseTypeName(keyspace, name.trim(), 0, null, udtResolver);
    }));
  };
  /**
   * Parses a Cassandra fully-qualified class name string into data type information
   * @param {String} typeName
   * @param {Number} [startIndex]
   * @param {Number} [length]
   * @throws TypeError
   * @returns {{code: number, info: Object|Array|null, options: {frozen: Boolean, reversed: Boolean}}}
   * @internal
   * @ignore
   */


  this.parseFqTypeName = function (typeName, startIndex, length) {
    var _this4 = this;

    var dataType = {
      code: 0,
      info: null,
      options: {
        reversed: false,
        frozen: false
      }
    };
    startIndex = startIndex || 0;
    var innerTypes;

    if (!length) {
      length = typeName.length;
    }

    if (length > complexTypeNames.reversed.length && typeName.indexOf(complexTypeNames.reversed) === startIndex) {
      //Remove the reversed token
      startIndex += complexTypeNames.reversed.length + 1;
      length -= complexTypeNames.reversed.length + 2;
      dataType.options.reversed = true;
    }

    if (length > complexTypeNames.frozen.length && typeName.indexOf(complexTypeNames.frozen, startIndex) === startIndex) {
      //Remove the frozen token
      startIndex += complexTypeNames.frozen.length + 1;
      length -= complexTypeNames.frozen.length + 2;
      dataType.options.frozen = true;
    }

    if (typeName === complexTypeNames.empty) {
      //set as custom
      dataType.info = 'empty';
      return dataType;
    } //Quick check if its a single type


    if (length <= singleFqTypeNamesLength) {
      if (startIndex > 0) {
        typeName = typeName.substr(startIndex, length);
      }

      var typeCode = singleTypeNames[typeName];

      if (typeof typeCode === 'number') {
        dataType.code = typeCode;
        return dataType;
      }

      throw new TypeError('Not a valid type "' + typeName + '"');
    }

    if (typeName.indexOf(complexTypeNames.list, startIndex) === startIndex) {
      //Its a list
      //org.apache.cassandra.db.marshal.ListType(innerType)
      //move cursor across the name and bypass the parenthesis
      startIndex += complexTypeNames.list.length + 1;
      length -= complexTypeNames.list.length + 2;
      innerTypes = parseParams(typeName, startIndex, length);

      if (innerTypes.length !== 1) {
        throw new TypeError('Not a valid type ' + typeName);
      }

      dataType.code = dataTypes$4.list;
      dataType.info = this.parseFqTypeName(innerTypes[0]);
      return dataType;
    }

    if (typeName.indexOf(complexTypeNames.set, startIndex) === startIndex) {
      //Its a set
      //org.apache.cassandra.db.marshal.SetType(innerType)
      //move cursor across the name and bypass the parenthesis
      startIndex += complexTypeNames.set.length + 1;
      length -= complexTypeNames.set.length + 2;
      innerTypes = parseParams(typeName, startIndex, length);

      if (innerTypes.length !== 1) {
        throw new TypeError('Not a valid type ' + typeName);
      }

      dataType.code = dataTypes$4.set;
      dataType.info = this.parseFqTypeName(innerTypes[0]);
      return dataType;
    }

    if (typeName.indexOf(complexTypeNames.map, startIndex) === startIndex) {
      //org.apache.cassandra.db.marshal.MapType(keyType,valueType)
      //move cursor across the name and bypass the parenthesis
      startIndex += complexTypeNames.map.length + 1;
      length -= complexTypeNames.map.length + 2;
      innerTypes = parseParams(typeName, startIndex, length); //It should contain the key and value types

      if (innerTypes.length !== 2) {
        throw new TypeError('Not a valid type ' + typeName);
      }

      dataType.code = dataTypes$4.map;
      dataType.info = [this.parseFqTypeName(innerTypes[0]), this.parseFqTypeName(innerTypes[1])];
      return dataType;
    }

    if (typeName.indexOf(complexTypeNames.udt, startIndex) === startIndex) {
      //move cursor across the name and bypass the parenthesis
      startIndex += complexTypeNames.udt.length + 1;
      length -= complexTypeNames.udt.length + 2;
      return this._parseUdtName(typeName, startIndex, length);
    }

    if (typeName.indexOf(complexTypeNames.tuple, startIndex) === startIndex) {
      //move cursor across the name and bypass the parenthesis
      startIndex += complexTypeNames.tuple.length + 1;
      length -= complexTypeNames.tuple.length + 2;
      innerTypes = parseParams(typeName, startIndex, length);

      if (innerTypes.length < 1) {
        throw new TypeError('Not a valid type ' + typeName);
      }

      dataType.code = dataTypes$4.tuple;
      dataType.info = innerTypes.map(function (x) {
        return _this4.parseFqTypeName(x);
      });
      return dataType;
    } // Assume custom type if cannot be parsed up to this point.


    dataType.info = typeName.substr(startIndex, length);
    return dataType;
  };
  /**
   * Parses type names with composites
   * @param {String} typesString
   * @returns {{types: Array, isComposite: Boolean, hasCollections: Boolean}}
   * @internal
   * @ignore
   */


  this.parseKeyTypes = function (typesString) {
    var _this5 = this;

    var i = 0;
    var length = typesString.length;
    var isComposite = typesString.indexOf(complexTypeNames.composite) === 0;

    if (isComposite) {
      i = complexTypeNames.composite.length + 1;
      length--;
    }

    var types = [];
    var startIndex = i;
    var nested = 0;
    var inCollectionType = false;
    var hasCollections = false; //as collection types are not allowed, it is safe to split by ,

    while (++i < length) {
      switch (typesString[i]) {
        case ',':
          if (nested > 0) {
            break;
          }

          if (inCollectionType) {
            //remove type id
            startIndex = typesString.indexOf(':', startIndex) + 1;
          }

          types.push(typesString.substring(startIndex, i));
          startIndex = i + 1;
          break;

        case '(':
          if (nested === 0 && typesString.indexOf(complexTypeNames.collection, startIndex) === startIndex) {
            inCollectionType = true;
            hasCollections = true; //skip collection type

            i++;
            startIndex = i;
            break;
          }

          nested++;
          break;

        case ')':
          if (inCollectionType && nested === 0) {
            types.push(typesString.substring(typesString.indexOf(':', startIndex) + 1, i));
            startIndex = i + 1;
            break;
          }

          nested--;
          break;
      }
    }

    if (startIndex < length) {
      types.push(typesString.substring(startIndex, length));
    }

    return {
      types: types.map(function (name) {
        return _this5.parseFqTypeName(name);
      }),
      hasCollections: hasCollections,
      isComposite: isComposite
    };
  };

  this._parseUdtName = function (typeName, startIndex, length) {
    var udtParams = parseParams(typeName, startIndex, length);

    if (udtParams.length < 2) {
      //It should contain at least the keyspace, name of the udt and a type
      throw new TypeError('Not a valid type ' + typeName);
    }

    var dataType = {
      code: dataTypes$4.udt,
      info: null
    };
    var udtInfo = {
      keyspace: udtParams[0],
      name: utils$t.allocBufferFromString(udtParams[1], 'hex').toString(),
      fields: []
    };

    for (var i = 2; i < udtParams.length; i++) {
      var p = udtParams[i];
      var separatorIndex = p.indexOf(':');
      var fieldType = this.parseFqTypeName(p, separatorIndex + 1, p.length - (separatorIndex + 1));
      udtInfo.fields.push({
        name: utils$t.allocBufferFromString(p.substr(0, separatorIndex), 'hex').toString(),
        type: fieldType
      });
    }

    dataType.info = udtInfo;
    return dataType;
  };
}
/**
 * Sets the encoder and decoder methods for this instance
 * @private
 */


function setEncoders() {
  var _this$decoders, _this$encoders;

  this.decoders = (_this$decoders = {}, _defineProperty(_this$decoders, dataTypes$4.custom, this.decodeCustom), _defineProperty(_this$decoders, dataTypes$4.ascii, this.decodeAsciiString), _defineProperty(_this$decoders, dataTypes$4.bigint, this.decodeLong), _defineProperty(_this$decoders, dataTypes$4.blob, this.decodeBlob), _defineProperty(_this$decoders, dataTypes$4["boolean"], this.decodeBoolean), _defineProperty(_this$decoders, dataTypes$4.counter, this.decodeLong), _defineProperty(_this$decoders, dataTypes$4.decimal, this.decodeDecimal), _defineProperty(_this$decoders, dataTypes$4["double"], this.decodeDouble), _defineProperty(_this$decoders, dataTypes$4["float"], this.decodeFloat), _defineProperty(_this$decoders, dataTypes$4["int"], this.decodeInt), _defineProperty(_this$decoders, dataTypes$4.text, this.decodeUtf8String), _defineProperty(_this$decoders, dataTypes$4.timestamp, this.decodeTimestamp), _defineProperty(_this$decoders, dataTypes$4.uuid, this.decodeUuid), _defineProperty(_this$decoders, dataTypes$4.varchar, this.decodeUtf8String), _defineProperty(_this$decoders, dataTypes$4.varint, this.decodeVarint), _defineProperty(_this$decoders, dataTypes$4.timeuuid, this.decodeTimeUuid), _defineProperty(_this$decoders, dataTypes$4.inet, this.decodeInet), _defineProperty(_this$decoders, dataTypes$4.date, this.decodeDate), _defineProperty(_this$decoders, dataTypes$4.time, this.decodeTime), _defineProperty(_this$decoders, dataTypes$4.smallint, this.decodeSmallint), _defineProperty(_this$decoders, dataTypes$4.tinyint, this.decodeTinyint), _defineProperty(_this$decoders, dataTypes$4.duration, decodeDuration), _defineProperty(_this$decoders, dataTypes$4.list, this.decodeList), _defineProperty(_this$decoders, dataTypes$4.map, this.decodeMap), _defineProperty(_this$decoders, dataTypes$4.set, this.decodeSet), _defineProperty(_this$decoders, dataTypes$4.udt, this.decodeUdt), _defineProperty(_this$decoders, dataTypes$4.tuple, this.decodeTuple), _this$decoders);
  this.encoders = (_this$encoders = {}, _defineProperty(_this$encoders, dataTypes$4.custom, this.encodeCustom), _defineProperty(_this$encoders, dataTypes$4.ascii, this.encodeAsciiString), _defineProperty(_this$encoders, dataTypes$4.bigint, this.encodeLong), _defineProperty(_this$encoders, dataTypes$4.blob, this.encodeBlob), _defineProperty(_this$encoders, dataTypes$4["boolean"], this.encodeBoolean), _defineProperty(_this$encoders, dataTypes$4.counter, this.encodeLong), _defineProperty(_this$encoders, dataTypes$4.decimal, this.encodeDecimal), _defineProperty(_this$encoders, dataTypes$4["double"], this.encodeDouble), _defineProperty(_this$encoders, dataTypes$4["float"], this.encodeFloat), _defineProperty(_this$encoders, dataTypes$4["int"], this.encodeInt), _defineProperty(_this$encoders, dataTypes$4.text, this.encodeUtf8String), _defineProperty(_this$encoders, dataTypes$4.timestamp, this.encodeTimestamp), _defineProperty(_this$encoders, dataTypes$4.uuid, this.encodeUuid), _defineProperty(_this$encoders, dataTypes$4.varchar, this.encodeUtf8String), _defineProperty(_this$encoders, dataTypes$4.varint, this.encodeVarint), _defineProperty(_this$encoders, dataTypes$4.timeuuid, this.encodeUuid), _defineProperty(_this$encoders, dataTypes$4.inet, this.encodeInet), _defineProperty(_this$encoders, dataTypes$4.date, this.encodeDate), _defineProperty(_this$encoders, dataTypes$4.time, this.encodeTime), _defineProperty(_this$encoders, dataTypes$4.smallint, this.encodeSmallint), _defineProperty(_this$encoders, dataTypes$4.tinyint, this.encodeTinyint), _defineProperty(_this$encoders, dataTypes$4.duration, encodeDuration), _defineProperty(_this$encoders, dataTypes$4.list, this.encodeList), _defineProperty(_this$encoders, dataTypes$4.map, this.encodeMap), _defineProperty(_this$encoders, dataTypes$4.set, this.encodeSet), _defineProperty(_this$encoders, dataTypes$4.udt, this.encodeUdt), _defineProperty(_this$encoders, dataTypes$4.tuple, this.encodeTuple), _this$encoders);
}
/**
 * Decodes Cassandra bytes into Javascript values.
 * <p>
 * This is part of an <b>experimental</b> API, this can be changed future releases.
 * </p>
 * @param {Buffer} buffer Raw buffer to be decoded.
 * @param {Object} type An object containing the data type <code>code</code> and <code>info</code>.
 * @param {Number} type.code Type code.
 * @param {Object} [type.info] Additional information on the type for complex / nested types.
 */


Encoder$2.prototype.decode = function (buffer, type) {
  if (buffer === null || buffer.length === 0 && !zeroLengthTypesSupported.has(type.code)) {
    return null;
  }

  var decoder = this.decoders[type.code];

  if (!decoder) {
    throw new Error('Unknown data type: ' + type.code);
  }

  return decoder.call(this, buffer, type.info);
};
/**
 * Encodes Javascript types into Buffer according to the Cassandra protocol.
 * <p>
 * This is part of an <b>experimental</b> API, this can be changed future releases.
 * </p>
 * @param {*} value The value to be converted.
 * @param {{code: number, info: *|Object}|String|Number} [typeInfo] The type information.
 * <p>It can be either a:</p>
 * <ul>
 *   <li>A <code>String</code> representing the data type.</li>
 *   <li>A <code>Number</code> with one of the values of {@link module:types~dataTypes dataTypes}.</li>
 *   <li>An <code>Object</code> containing the <code>type.code</code> as one of the values of
 *   {@link module:types~dataTypes dataTypes} and <code>type.info</code>.
 *   </li>
 * </ul>
 * @returns {Buffer}
 * @throws {TypeError} When there is an encoding error
 */


Encoder$2.prototype.encode = function (value, typeInfo) {
  if (value === undefined) {
    value = this.encodingOptions.useUndefinedAsUnset && this.protocolVersion >= 4 ? types$l.unset : null;
  }

  if (value === types$l.unset) {
    if (!types$l.protocolVersion.supportsUnset(this.protocolVersion)) {
      throw new TypeError('Unset value can not be used for this version of Cassandra, protocol version: ' + this.protocolVersion);
    }

    return value;
  }

  if (value === null || value instanceof Buffer) {
    return value;
  }
  /** @type {{code: Number, info: object}} */


  var type = {
    code: null,
    info: null
  };

  if (typeInfo) {
    if (typeof typeInfo === 'number') {
      type.code = typeInfo;
    } else if (typeof typeInfo === 'string') {
      type = dataTypes$4.getByName(typeInfo);
    }

    if (typeof typeInfo.code === 'number') {
      type.code = typeInfo.code;
      type.info = typeInfo.info;
    }

    if (typeof type.code !== 'number') {
      throw new TypeError('Type information not valid, only String and Number values are valid hints');
    }
  } else {
    //Lets guess
    type = Encoder$2.guessDataType(value);

    if (!type) {
      throw new TypeError('Target data type could not be guessed, you should use prepared statements for accurate type mapping. Value: ' + util$k.inspect(value));
    }
  }

  var encoder = this.encoders[type.code];

  if (!encoder) {
    throw new Error('Type not supported ' + type.code);
  }

  return encoder.call(this, value, type.info);
};
/**
 * Try to guess the Cassandra type to be stored, based on the javascript value type
 * @param value
 * @returns {{code: number, info: object}|null}
 * @ignore
 * @internal
 */


Encoder$2.guessDataType = function (value) {
  var code = null;
  var info = null;

  var esTypeName = _typeof(value);

  if (esTypeName === 'number') {
    code = dataTypes$4["double"];
  } else if (esTypeName === 'string') {
    code = dataTypes$4.text;

    if (value.length === 36 && uuidRegex.test(value)) {
      code = dataTypes$4.uuid;
    }
  } else if (esTypeName === 'boolean') {
    code = dataTypes$4["boolean"];
  } else if (value instanceof Buffer) {
    code = dataTypes$4.blob;
  } else if (value instanceof Date) {
    code = dataTypes$4.timestamp;
  } else if (value instanceof Long$1) {
    code = dataTypes$4.bigint;
  } else if (value instanceof Integer$1) {
    code = dataTypes$4.varint;
  } else if (value instanceof BigDecimal) {
    code = dataTypes$4.decimal;
  } else if (value instanceof types$l.Uuid) {
    code = dataTypes$4.uuid;
  } else if (value instanceof types$l.InetAddress) {
    code = dataTypes$4.inet;
  } else if (value instanceof types$l.Tuple) {
    code = dataTypes$4.tuple;
  } else if (value instanceof types$l.LocalDate) {
    code = dataTypes$4.date;
  } else if (value instanceof types$l.LocalTime) {
    code = dataTypes$4.time;
  } else if (value instanceof types$l.Duration) {
    code = dataTypes$4.custom;
    info = customTypeNames.duration;
  } else if (Array.isArray(value)) {
    code = dataTypes$4.list;
  } else if (value instanceof Geometry) {
    code = dataTypes$4.custom;

    if (value instanceof LineString$1) {
      info = customTypeNames.lineString;
    } else if (value instanceof Point$1) {
      info = customTypeNames.point;
    } else if (value instanceof Polygon$1) {
      info = customTypeNames.polygon;
    }
  } else if (value instanceof DateRange) {
    code = dataTypes$4.custom;
    info = customTypeNames.dateRange;
  }

  if (code === null) {
    return null;
  }

  return {
    code: code,
    info: info
  };
};
/**
 * Gets a buffer containing with the bytes (BE) representing the collection length for protocol v2 and below
 * @param {Buffer|Number} value
 * @returns {Buffer}
 * @private
 */


function getLengthBufferV2(value) {
  if (!value) {
    return buffers.int16Zero;
  }

  var lengthBuffer = utils$t.allocBufferUnsafe(2);

  if (typeof value === 'number') {
    lengthBuffer.writeUInt16BE(value, 0);
  } else {
    lengthBuffer.writeUInt16BE(value.length, 0);
  }

  return lengthBuffer;
}
/**
 * Gets a buffer containing with the bytes (BE) representing the collection length for protocol v3 and above
 * @param {Buffer|Number} value
 * @returns {Buffer}
 * @private
 */


function getLengthBufferV3(value) {
  if (!value) {
    return buffers.int32Zero;
  }

  var lengthBuffer = utils$t.allocBufferUnsafe(4);

  if (typeof value === 'number') {
    lengthBuffer.writeInt32BE(value, 0);
  } else {
    lengthBuffer.writeInt32BE(value.length, 0);
  }

  return lengthBuffer;
}
/**
 * @param {Buffer} buffer
 * @private
 */


function handleBufferCopy(buffer) {
  if (buffer === null) {
    return null;
  }

  return utils$t.copyBuffer(buffer);
}
/**
 * @param {Buffer} buffer
 * @private
 */


function handleBufferRef(buffer) {
  return buffer;
}
/**
 * Decodes collection length for protocol v3 and above
 * @param bytes
 * @param offset
 * @returns {Number}
 * @private
 */


function decodeCollectionLengthV3(bytes, offset) {
  return bytes.readInt32BE(offset);
}
/**
 * Decodes collection length for protocol v2 and below
 * @param bytes
 * @param offset
 * @returns {Number}
 * @private
 */


function decodeCollectionLengthV2(bytes, offset) {
  return bytes.readUInt16BE(offset);
}

function decodeDuration(bytes) {
  return types$l.Duration.fromBuffer(bytes);
}

function encodeDuration(value) {
  if (!(value instanceof types$l.Duration)) {
    throw new TypeError('Not a valid duration, expected Duration/Buffer obtained ' + util$k.inspect(value));
  }

  return value.toBuffer();
}
/**
 * @private
 * @param {Buffer} buffer
 */


function decodeLineString(buffer) {
  return LineString$1.fromBuffer(buffer);
}
/**
 * @private
 * @param {LineString} value
 */


function encodeLineString(value) {
  return value.toBuffer();
}
/**
 * @private
 * @param {Buffer} buffer
 */


function decodePoint(buffer) {
  return Point$1.fromBuffer(buffer);
}
/**
 * @private
 * @param {LineString} value
 */


function encodePoint(value) {
  return value.toBuffer();
}
/**
 * @private
 * @param {Buffer} buffer
 */


function decodePolygon(buffer) {
  return Polygon$1.fromBuffer(buffer);
}
/**
 * @private
 * @param {Polygon} value
 */


function encodePolygon(value) {
  return value.toBuffer();
}

function decodeDateRange(buffer) {
  return DateRange.fromBuffer(buffer);
}
/**
 * @private
 * @param {DateRange} value
 */


function encodeDateRange(value) {
  return value.toBuffer();
}
/**
 * @param {String} value
 * @param {Number} startIndex
 * @param {Number} length
 * @param {String} [open]
 * @param {String} [close]
 * @returns {Array}
 * @private
 */


function parseParams(value, startIndex, length, open, close) {
  open = open || '(';
  close = close || ')';
  var types = [];
  var paramStart = startIndex;
  var level = 0;

  for (var i = startIndex; i < startIndex + length; i++) {
    var c = value[i];

    if (c === open) {
      level++;
    }

    if (c === close) {
      level--;
    }

    if (level === 0 && c === ',') {
      types.push(value.substr(paramStart, i - paramStart));
      paramStart = i + 1;
    }
  } //Add the last one


  types.push(value.substr(paramStart, length - (paramStart - startIndex)));
  return types;
}
/**
 * @param {Array.<Buffer>} parts
 * @param {Number} totalLength
 * @returns {Buffer}
 * @private
 */


function concatRoutingKey(parts, totalLength) {
  if (totalLength === 0) {
    return null;
  }

  if (parts.length === 1) {
    return parts[0];
  }

  var routingKey = utils$t.allocBufferUnsafe(totalLength);
  var offset = 0;

  for (var i = 0; i < parts.length; i++) {
    var item = parts[i];
    routingKey.writeUInt16BE(item.length, offset);
    offset += 2;
    item.copy(routingKey, offset);
    offset += item.length;
    routingKey[offset] = 0;
    offset++;
  }

  return routingKey;
}

var encoder = Encoder$2;

var streams$1 = {};

var util$j = require$$0__default$1["default"];
var utils$s = utils$V;
var types$k = types$u;
var errors$g = errors$s;
/**
 * Information on the formatting of the returned rows
 */

var resultFlag = {
  globalTablesSpec: 0x0001,
  hasMorePages: 0x0002,
  noMetadata: 0x0004,
  metadataChanged: 0x0008,
  continuousPaging: 0x40000000,
  lastContinuousPage: 0x80000000
}; // templates for derived error messages.

var _writeTimeoutQueryMessage = 'Server timeout during write query at consistency %s (%d peer(s) acknowledged the write over %d required)';
var _writeTimeoutBatchLogMessage = 'Server timeout during batchlog write at consistency %s (%d peer(s) acknowledged the write over %d required)';
var _writeFailureMessage = 'Server failure during write query at consistency %s (%d responses were required but only %d replicas responded, %d failed)';
var _unavailableMessage = 'Not enough replicas available for query at consistency %s (%d required but only %d alive)';
var _readTimeoutMessage = 'Server timeout during read query at consistency %s (%s)';
var _readFailureMessage = 'Server failure during read query at consistency %s (%d responses were required but only %d replicas responded, %d failed)';
/**
 * Buffer forward reader of CQL binary frames
 * @param {FrameHeader} header
 * @param {Buffer} body
 * @param {Number} [offset]
 */

var FrameReader$1 = /*#__PURE__*/function () {
  /**
   * Creates a new instance of the reader
   * @param {FrameHeader} header
   * @param {Buffer} body
   * @param {Number} [offset]
   */
  function FrameReader(header, body, offset) {
    _classCallCheck(this, FrameReader);

    this.header = header;
    this.opcode = header.opcode;
    this.offset = offset || 0;
    this.buf = body;
  }

  _createClass(FrameReader, [{
    key: "remainingLength",
    value: function remainingLength() {
      return this.buf.length - this.offset;
    }
  }, {
    key: "getBuffer",
    value: function getBuffer() {
      return this.buf;
    }
    /**
     * Slices the underlining buffer
     * @param {Number} begin
     * @param {Number} [end]
     * @returns {Buffer}
     */

  }, {
    key: "slice",
    value: function slice(begin, end) {
      if (typeof end === 'undefined') {
        end = this.buf.length;
      }

      return this.buf.slice(begin, end);
    }
    /**
     * Modifies the underlying buffer, it concatenates the given buffer with the original (internalBuffer = concat(bytes, internalBuffer)
     */

  }, {
    key: "unshift",
    value: function unshift(bytes) {
      if (this.offset > 0) {
        throw new Error('Can not modify the underlying buffer if already read');
      }

      this.buf = Buffer.concat([bytes, this.buf], bytes.length + this.buf.length);
    }
    /**
     * Reads any number of bytes and moves the offset.
     * if length not provided or it's larger than the remaining bytes, reads to end.
     * @param length
     * @returns {Buffer}
     */

  }, {
    key: "read",
    value: function read(length) {
      var end = this.buf.length;

      if (typeof length !== 'undefined' && this.offset + length < this.buf.length) {
        end = this.offset + length;
      }

      var bytes = this.slice(this.offset, end);
      this.offset = end;
      return bytes;
    }
    /**
     * Moves the reader cursor to the end
     */

  }, {
    key: "toEnd",
    value: function toEnd() {
      this.offset = this.buf.length;
    }
    /**
     * Reads a BE Int and moves the offset
     * @returns {Number}
     */

  }, {
    key: "readInt",
    value: function readInt() {
      var result = this.buf.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    /** @returns {Number} */

  }, {
    key: "readShort",
    value: function readShort() {
      var result = this.buf.readUInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
  }, {
    key: "readByte",
    value: function readByte() {
      var result = this.buf.readUInt8(this.offset);
      this.offset += 1;
      return result;
    }
  }, {
    key: "readString",
    value: function readString() {
      var length = this.readShort();
      this.checkOffset(length);
      var result = this.buf.toString('utf8', this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
    /**
     * Checks that the new length to read is within the range of the buffer length. Throws a RangeError if not.
     * @param {Number} newLength
     */

  }, {
    key: "checkOffset",
    value: function checkOffset(newLength) {
      if (this.offset + newLength > this.buf.length) {
        var err = new RangeError('Trying to access beyond buffer length');
        err.expectedLength = newLength;
        throw err;
      }
    }
    /**
     * Reads a protocol string list
     * @returns {Array}
     */

  }, {
    key: "readStringList",
    value: function readStringList() {
      var length = this.readShort();
      var list = new Array(length);

      for (var i = 0; i < length; i++) {
        list[i] = this.readString();
      }

      return list;
    }
    /**
     * Reads the amount of bytes that the field has and returns them (slicing them).
     * @returns {Buffer}
     */

  }, {
    key: "readBytes",
    value: function readBytes() {
      var length = this.readInt();

      if (length < 0) {
        return null;
      }

      this.checkOffset(length);
      return this.read(length);
    }
  }, {
    key: "readShortBytes",
    value: function readShortBytes() {
      var length = this.readShort();

      if (length < 0) {
        return null;
      }

      this.checkOffset(length);
      return this.read(length);
    }
    /**
     * Reads an associative array of strings as keys and bytes as values
     * @param {Number} length
     * @param {Function} keyFn
     * @param {Function} valueFn
     * @returns {Object}
     */

  }, {
    key: "readMap",
    value: function readMap(length, keyFn, valueFn) {
      if (length < 0) {
        return null;
      }

      var map = {};

      for (var i = 0; i < length; i++) {
        map[keyFn.call(this)] = valueFn.call(this);
      }

      return map;
    }
    /**
     * Reads an associative array of strings as keys and string lists as values
     * @returns {Object}
     */

  }, {
    key: "readStringMultiMap",
    value: function readStringMultiMap() {
      //A [short] n, followed by n pair <k><v> where <k> is a
      //[string] and <v> is a [string[]].
      var length = this.readShort();

      if (length < 0) {
        return null;
      }

      var map = {};

      for (var i = 0; i < length; i++) {
        map[this.readString()] = this.readStringList();
      }

      return map;
    }
    /**
     * Reads a data type definition
     * @returns {{code: Number, info: Object|null}} An array of 2 elements
     */

  }, {
    key: "readType",
    value: function readType() {
      var i;
      var type = {
        code: this.readShort(),
        type: null
      };

      switch (type.code) {
        case types$k.dataTypes.custom:
          type.info = this.readString();
          break;

        case types$k.dataTypes.list:
        case types$k.dataTypes.set:
          type.info = this.readType();
          break;

        case types$k.dataTypes.map:
          type.info = [this.readType(), this.readType()];
          break;

        case types$k.dataTypes.udt:
          type.info = {
            keyspace: this.readString(),
            name: this.readString(),
            fields: new Array(this.readShort())
          };

          for (i = 0; i < type.info.fields.length; i++) {
            type.info.fields[i] = {
              name: this.readString(),
              type: this.readType()
            };
          }

          break;

        case types$k.dataTypes.tuple:
          type.info = new Array(this.readShort());

          for (i = 0; i < type.info.length; i++) {
            type.info[i] = this.readType();
          }

          break;
      }

      return type;
    }
    /**
     * Reads an Ip address and port
     * @returns {{address: exports.InetAddress, port: Number}}
     */

  }, {
    key: "readInet",
    value: function readInet() {
      var length = this.readByte();
      var address = this.read(length);
      return {
        address: new types$k.InetAddress(address),
        port: this.readInt()
      };
    }
    /**
     * Reads an Ip address
     * @returns {InetAddress}
     */

  }, {
    key: "readInetAddress",
    value: function readInetAddress() {
      var length = this.readByte();
      return new types$k.InetAddress(this.read(length));
    }
    /**
     * Reads the body bytes corresponding to the flags
     * @returns {{traceId: Uuid, warnings: Array, customPayload}}
     * @throws {RangeError}
     */

  }, {
    key: "readFlagsInfo",
    value: function readFlagsInfo() {
      if (this.header.flags === 0) {
        return utils$s.emptyObject;
      }

      var result = {};

      if (this.header.flags & types$k.frameFlags.tracing) {
        this.checkOffset(16);
        result.traceId = new types$k.Uuid(utils$s.copyBuffer(this.read(16)));
      }

      if (this.header.flags & types$k.frameFlags.warning) {
        result.warnings = this.readStringList();
      }

      if (this.header.flags & types$k.frameFlags.customPayload) {
        // Custom payload is a Map<string, Buffer>
        result.customPayload = this.readMap(this.readShort(), this.readString, this.readBytes);
      }

      return result;
    }
    /**
     * Reads the metadata from a row or a prepared result response
     * @param {Number} kind
     * @returns {Object}
     * @throws {RangeError}
     */

  }, {
    key: "readMetadata",
    value: function readMetadata(kind) {
      var i; //Determines if its a prepared metadata

      var isPrepared = kind === types$k.resultKind.prepared;
      var meta = {};

      if (types$k.protocolVersion.supportsResultMetadataId(this.header.version) && isPrepared) {
        meta.resultId = utils$s.copyBuffer(this.readShortBytes());
      } //as used in Rows and Prepared responses


      var flags = this.readInt();
      var columnLength = this.readInt();

      if (types$k.protocolVersion.supportsPreparedPartitionKey(this.header.version) && isPrepared) {
        //read the pk columns
        meta.partitionKeys = new Array(this.readInt());

        for (i = 0; i < meta.partitionKeys.length; i++) {
          meta.partitionKeys[i] = this.readShort();
        }
      }

      if (flags & resultFlag.hasMorePages) {
        meta.pageState = utils$s.copyBuffer(this.readBytes());
      }

      if (flags & resultFlag.metadataChanged) {
        meta.newResultId = utils$s.copyBuffer(this.readShortBytes());
      }

      if (flags & resultFlag.continuousPaging) {
        meta.continuousPageIndex = this.readInt();
        meta.lastContinuousPage = !!(flags & resultFlag.lastContinuousPage);
      }

      if (flags & resultFlag.globalTablesSpec) {
        meta.global_tables_spec = true;
        meta.keyspace = this.readString();
        meta.table = this.readString();
      }

      meta.columns = new Array(columnLength);
      meta.columnsByName = utils$s.emptyObject;

      if (isPrepared) {
        //for prepared metadata, we will need a index of the columns (param) by name
        meta.columnsByName = {};
      }

      for (i = 0; i < columnLength; i++) {
        var col = {};

        if (!meta.global_tables_spec) {
          col.ksname = this.readString();
          col.tablename = this.readString();
        }

        col.name = this.readString();
        col.type = this.readType();
        meta.columns[i] = col;

        if (isPrepared) {
          meta.columnsByName[col.name] = i;
        }
      }

      return meta;
    }
    /**
     * Reads the error from the frame
     * @throws {RangeError}
     * @returns {ResponseError}
     */

  }, {
    key: "readError",
    value: function readError() {
      var code = this.readInt();
      var message = this.readString();
      var err = new errors$g.ResponseError(code, message); //read extra info

      switch (code) {
        case types$k.responseErrorCodes.unavailableException:
          err.consistencies = this.readShort();
          err.required = this.readInt();
          err.alive = this.readInt();
          err.message = util$j.format(_unavailableMessage, types$k.consistencyToString[err.consistencies], err.required, err.alive);
          break;

        case types$k.responseErrorCodes.readTimeout:
        case types$k.responseErrorCodes.readFailure:
          err.consistencies = this.readShort();
          err.received = this.readInt();
          err.blockFor = this.readInt();

          if (code === types$k.responseErrorCodes.readFailure) {
            if (types$k.protocolVersion.supportsFailureReasonMap(this.header.version)) {
              err.failures = this.readInt();
              err.reasons = this.readMap(err.failures, this.readInetAddress, this.readShort);
            } else {
              err.failures = this.readInt();
            }
          }

          err.isDataPresent = this.readByte();

          if (code === types$k.responseErrorCodes.readTimeout) {
            var details;

            if (err.received < err.blockFor) {
              details = util$j.format('%d replica(s) responded over %d required', err.received, err.blockFor);
            } else if (!err.isDataPresent) {
              details = 'the replica queried for the data didn\'t respond';
            } else {
              details = 'timeout while waiting for repair of inconsistent replica';
            }

            err.message = util$j.format(_readTimeoutMessage, types$k.consistencyToString[err.consistencies], details);
          } else {
            err.message = util$j.format(_readFailureMessage, types$k.consistencyToString[err.consistencies], err.blockFor, err.received, err.failures);
          }

          break;

        case types$k.responseErrorCodes.writeTimeout:
        case types$k.responseErrorCodes.writeFailure:
          err.consistencies = this.readShort();
          err.received = this.readInt();
          err.blockFor = this.readInt();

          if (code === types$k.responseErrorCodes.writeFailure) {
            if (types$k.protocolVersion.supportsFailureReasonMap(this.header.version)) {
              err.failures = this.readInt();
              err.reasons = this.readMap(err.failures, this.readInetAddress, this.readShort);
            } else {
              err.failures = this.readInt();
            }
          }

          err.writeType = this.readString();

          if (code === types$k.responseErrorCodes.writeTimeout) {
            var template = err.writeType === 'BATCH_LOG' ? _writeTimeoutBatchLogMessage : _writeTimeoutQueryMessage;
            err.message = util$j.format(template, types$k.consistencyToString[err.consistencies], err.received, err.blockFor);
          } else {
            err.message = util$j.format(_writeFailureMessage, types$k.consistencyToString[err.consistencies], err.blockFor, err.received, err.failures);
          }

          break;

        case types$k.responseErrorCodes.unprepared:
          err.queryId = utils$s.copyBuffer(this.readShortBytes());
          break;

        case types$k.responseErrorCodes.functionFailure:
          err.keyspace = this.readString();
          err.functionName = this.readString();
          err.argTypes = this.readStringList();
          break;

        case types$k.responseErrorCodes.alreadyExists:
          {
            err.keyspace = this.readString();
            var table = this.readString();

            if (table.length > 0) {
              err.table = table;
            }

            break;
          }
      }

      return err;
    }
    /**
     * Reads an event from Cassandra and returns the detail
     * @returns {{eventType: String, inet: {address: Buffer, port: Number}}, *}
     */

  }, {
    key: "readEvent",
    value: function readEvent() {
      var eventType = this.readString();

      switch (eventType) {
        case types$k.protocolEvents.topologyChange:
          return {
            added: this.readString() === 'NEW_NODE',
            inet: this.readInet(),
            eventType: eventType
          };

        case types$k.protocolEvents.statusChange:
          return {
            up: this.readString() === 'UP',
            inet: this.readInet(),
            eventType: eventType
          };

        case types$k.protocolEvents.schemaChange:
          return this.parseSchemaChange();
      } //Forward compatibility


      return {
        eventType: eventType
      };
    }
  }, {
    key: "parseSchemaChange",
    value: function parseSchemaChange() {
      var result;

      if (!types$k.protocolVersion.supportsSchemaChangeFullMetadata(this.header.version)) {
        //v1/v2: 3 strings, the table value can be empty
        result = {
          eventType: types$k.protocolEvents.schemaChange,
          schemaChangeType: this.readString(),
          keyspace: this.readString(),
          table: this.readString()
        };
        result.isKeyspace = !result.table;
        return result;
      } //v3+: 3 or 4 strings: change_type, target, keyspace and (table, type, functionName or aggregate)


      result = {
        eventType: types$k.protocolEvents.schemaChange,
        schemaChangeType: this.readString(),
        target: this.readString(),
        keyspace: this.readString(),
        table: null,
        udt: null,
        signature: null
      };
      result.isKeyspace = result.target === 'KEYSPACE';

      switch (result.target) {
        case 'TABLE':
          result.table = this.readString();
          break;

        case 'TYPE':
          result.udt = this.readString();
          break;

        case 'FUNCTION':
          result.functionName = this.readString();
          result.signature = this.readStringList();
          break;

        case 'AGGREGATE':
          result.aggregate = this.readString();
          result.signature = this.readStringList();
      }

      return result;
    }
  }]);

  return FrameReader;
}();

var readers = {
  FrameReader: FrameReader$1
};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$i = require$$0__default$1["default"];
var Transform = require$$0__default$5["default"].Transform,
    Writable = require$$0__default$5["default"].Writable;
var types$j = types$u;
var utils$r = utils$V;
var errors$f = errors$s;
var FrameHeader = types$j.FrameHeader;
var FrameReader = readers.FrameReader;
/**
 * Transforms chunks, emits data objects {header, chunk}
 * @param options Stream options
 * @extends Transform
 */

function Protocol(options) {
  Transform.call(this, options);
  this.header = null;
  this.bodyLength = 0;
  this.clearHeaderChunks();
  this.version = 0;
  this.headerSize = 0;
}

util$i.inherits(Protocol, Transform);

Protocol.prototype._transform = function (chunk, encoding, callback) {
  var error = null;

  try {
    this.readItems(chunk);
  } catch (err) {
    error = err;
  }

  callback(error);
};
/**
 * Parses the chunk into frames (header and body).
 * Emits (push) complete frames or frames with incomplete bodies. Following chunks containing the rest of the body will
 * be emitted using the same frame.
 * It buffers incomplete headers.
 * @param {Buffer} chunk
 */


Protocol.prototype.readItems = function (chunk) {
  if (!chunk || chunk.length === 0) {
    return;
  }

  if (this.version === 0) {
    //The server replies the first message with the max protocol version supported
    this.version = FrameHeader.getProtocolVersion(chunk);
    this.headerSize = FrameHeader.size(this.version);
  }

  var offset = 0;
  var currentHeader = this.header;
  this.header = null;

  if (this.headerChunks.byteLength !== 0) {
    //incomplete header was buffered try to read the header from the buffered chunks
    this.headerChunks.parts.push(chunk);

    if (this.headerChunks.byteLength + chunk.length < this.headerSize) {
      this.headerChunks.byteLength += chunk.length;
      return;
    }

    currentHeader = FrameHeader.fromBuffer(Buffer.concat(this.headerChunks.parts, this.headerSize));
    offset = this.headerSize - this.headerChunks.byteLength;
    this.clearHeaderChunks();
  }

  var items = [];

  while (true) {
    if (!currentHeader) {
      if (this.headerSize > chunk.length - offset) {
        if (chunk.length - offset <= 0) {
          break;
        } //the header is incomplete, buffer it until the next chunk


        var headerPart = chunk.slice(offset, chunk.length);
        this.headerChunks.parts.push(headerPart);
        this.headerChunks.byteLength = headerPart.length;
        break;
      } //read header


      currentHeader = FrameHeader.fromBuffer(chunk, offset);
      offset += this.headerSize;
    } //parse body


    var remaining = chunk.length - offset;

    if (currentHeader.bodyLength <= remaining + this.bodyLength) {
      items.push({
        header: currentHeader,
        chunk: chunk,
        offset: offset,
        frameEnded: true
      });
      offset += currentHeader.bodyLength - this.bodyLength; //reset the body length

      this.bodyLength = 0;
    } else if (remaining >= 0) {
      //the body is not fully contained in this chunk
      //will continue later
      this.header = currentHeader;
      this.bodyLength += remaining;

      if (remaining > 0) {
        //emit if there is at least a byte to emit
        items.push({
          header: currentHeader,
          chunk: chunk,
          offset: offset,
          frameEnded: false
        });
      }

      break;
    }

    currentHeader = null;
  }

  for (var i = 0; i < items.length; i++) {
    this.push(items[i]);
  }
};

Protocol.prototype.clearHeaderChunks = function () {
  this.headerChunks = {
    byteLength: 0,
    parts: []
  };
};
/**
 * A stream that gets reads header + body chunks and transforms them into header + (row | error)
 * @param {Object} streamOptions Node.js Stream options
 * @param {Encoder} encoder Encoder instance for the parser to use
 * @extends Transform
 */


function Parser(streamOptions, encoder) {
  Transform.call(this, streamOptions); //frames that are streaming, indexed by id

  this.frames = {};
  this.encoder = encoder;
}

util$i.inherits(Parser, Transform);

Parser.prototype._transform = function (item, encoding, callback) {
  var frameInfo = this.frameState(item);
  var error = null;

  try {
    this.parseBody(frameInfo, item);
  } catch (err) {
    error = err;
  }

  callback(error);

  if (item.frameEnded) {
    if (frameInfo.cellBuffer) {
      //Frame was being streamed but an error force it to buffer the result
      this.push({
        header: frameInfo.header,
        error: new errors$f.DriverInternalError('There was an problem while parsing streaming frame, opcode ' + frameInfo.header.opcode)
      });
    } //all the parsing finished and it was streamed down
    //emit an item that signals it


    this.push({
      header: frameInfo.header,
      frameEnded: true
    });
  }
};
/**
 * @param frameInfo
 * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item
 */


Parser.prototype.parseBody = function (frameInfo, item) {
  frameInfo.isStreaming = frameInfo.byRow && item.header.opcode === types$j.opcodes.result;

  if (!this.handleFrameBuffers(frameInfo, item)) {
    // Frame isn't complete and we are not streaming the frame
    return;
  }

  var reader = new FrameReader(item.header, item.chunk, item.offset); // Check that flags have not been parsed yet for this frame

  if (frameInfo.flagsInfo === undefined) {
    var originalOffset = reader.offset;

    try {
      frameInfo.flagsInfo = reader.readFlagsInfo();
    } catch (e) {
      return this.handleParsingError(e, frameInfo, reader, originalOffset);
    }
  } //All the body for most operations is already buffered at this stage
  //Except for RESULT


  switch (item.header.opcode) {
    case types$j.opcodes.result:
      return this.parseResult(frameInfo, reader);

    case types$j.opcodes.ready:
    case types$j.opcodes.authSuccess:
      return this.push({
        header: frameInfo.header,
        ready: true
      });

    case types$j.opcodes.authChallenge:
      return this.push({
        header: frameInfo.header,
        authChallenge: true,
        token: reader.readBytes()
      });

    case types$j.opcodes.authenticate:
      return this.push({
        header: frameInfo.header,
        mustAuthenticate: true,
        authenticatorName: reader.readString()
      });

    case types$j.opcodes.error:
      return this.push({
        header: frameInfo.header,
        error: reader.readError()
      });

    case types$j.opcodes.supported:
      return this.push({
        header: frameInfo.header,
        supported: reader.readStringMultiMap()
      });

    case types$j.opcodes.event:
      return this.push({
        header: frameInfo.header,
        event: reader.readEvent()
      });

    default:
      return this.push({
        header: frameInfo.header,
        error: new Error('Received invalid opcode: ' + item.header.opcode)
      });
  }
};
/**
 * Buffers if needed and returns true if it has all the necessary data to continue parsing the frame.
 * @param frameInfo
 * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item
 * @returns {Boolean}
 */


Parser.prototype.handleFrameBuffers = function (frameInfo, item) {
  if (!frameInfo.isStreaming) {
    // Handle buffering for complete frame bodies
    var currentLength = (frameInfo.bufferLength || 0) + item.chunk.length - item.offset;

    if (currentLength < item.header.bodyLength) {
      //buffer until the frame is completed
      this.addFrameBuffer(frameInfo, item);
      return false;
    } //We have received the full frame body


    if (frameInfo.buffers) {
      item.chunk = this.getFrameBuffer(frameInfo, item);
      item.offset = 0;
    }

    return true;
  }

  if (frameInfo.cellBuffer) {
    // Handle buffering for frame cells (row cells or metadata cells)
    if (item.offset !== 0) {
      throw new errors$f.DriverInternalError('Following chunks can not have an offset greater than zero');
    }

    frameInfo.cellBuffer.parts.push(item.chunk);

    if (!frameInfo.cellBuffer.expectedLength) {
      //Its a buffer outside a row cell (metadata or other)
      if (frameInfo.cellBuffer.parts.length !== 2) {
        throw new errors$f.DriverInternalError('Buffer for streaming frame can not contain more than 1 item');
      }

      item.chunk = Buffer.concat(frameInfo.cellBuffer.parts, frameInfo.cellBuffer.byteLength + item.chunk.length);
      frameInfo.cellBuffer = null;
      return true;
    }

    if (frameInfo.cellBuffer.expectedLength > frameInfo.cellBuffer.byteLength + item.chunk.length) {
      //We still haven't got the cell data
      frameInfo.cellBuffer.byteLength += item.chunk.length;
      return false;
    }

    item.chunk = Buffer.concat(frameInfo.cellBuffer.parts, frameInfo.cellBuffer.byteLength + item.chunk.length);
    frameInfo.cellBuffer = null;
  }

  return true;
};
/**
 * Adds this chunk to the frame buffers.
 * @param frameInfo
 * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item
 */


Parser.prototype.addFrameBuffer = function (frameInfo, item) {
  if (!frameInfo.buffers) {
    frameInfo.buffers = [item.chunk.slice(item.offset)];
    frameInfo.bufferLength = item.chunk.length - item.offset;
    return;
  }

  if (item.offset > 0) {
    throw new errors$f.DriverInternalError('Following chunks can not have an offset greater than zero');
  }

  frameInfo.buffers.push(item.chunk);
  frameInfo.bufferLength += item.chunk.length;
};
/**
 * Adds the last chunk and concatenates the frame buffers
 * @param frameInfo
 * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item
 */


Parser.prototype.getFrameBuffer = function (frameInfo, item) {
  frameInfo.buffers.push(item.chunk);
  var result = Buffer.concat(frameInfo.buffers, frameInfo.bodyLength);
  frameInfo.buffers = null;
  return result;
};
/**
 * Tries to read the result in the body of a message
 * @param frameInfo Frame information, header / metadata
 * @param {FrameReader} reader
 */


Parser.prototype.parseResult = function (frameInfo, reader) {
  var result; // As we might be streaming and the frame buffer might not be complete,
  // read the metadata and different types of result values in a try-catch.
  // Store the reader position

  var originalOffset = reader.offset;

  try {
    if (!frameInfo.meta) {
      frameInfo.kind = reader.readInt(); // Spec 4.2.5

      switch (frameInfo.kind) {
        case types$j.resultKind.voidResult:
          result = {
            header: frameInfo.header,
            flags: frameInfo.flagsInfo
          };
          break;

        case types$j.resultKind.rows:
          // Parse the rows metadata, the rest of the response is going to be parsed afterwards
          frameInfo.meta = reader.readMetadata(frameInfo.kind);
          break;

        case types$j.resultKind.setKeyspace:
          result = {
            header: frameInfo.header,
            keyspaceSet: reader.readString(),
            flags: frameInfo.flagsInfo
          };
          break;

        case types$j.resultKind.prepared:
          {
            var preparedId = utils$r.copyBuffer(reader.readShortBytes());
            frameInfo.meta = reader.readMetadata(frameInfo.kind);
            result = {
              header: frameInfo.header,
              id: preparedId,
              meta: frameInfo.meta,
              flags: frameInfo.flagsInfo
            };
            break;
          }

        case types$j.resultKind.schemaChange:
          result = {
            header: frameInfo.header,
            schemaChange: reader.parseSchemaChange(),
            flags: frameInfo.flagsInfo
          };
          break;

        default:
          throw errors$f.DriverInternalError('Unexpected result kind: ' + frameInfo.kind);
      }
    }
  } catch (e) {
    return this.handleParsingError(e, frameInfo, reader, originalOffset);
  }

  if (result) {
    if (frameInfo.emitted) {
      // It may contain additional metadata and info that it's not being parsed
      return;
    }

    frameInfo.emitted = true;
    return this.push(result);
  }

  if (reader.remainingLength() > 0) {
    this.parseRows(frameInfo, reader);
  }
};
/**
 * @param frameInfo
 * @param {FrameReader} reader
 */


Parser.prototype.parseRows = function (frameInfo, reader) {
  if (frameInfo.parsingError) {
    //No more processing on this frame
    return;
  }

  if (frameInfo.rowLength === undefined) {
    try {
      frameInfo.rowLength = reader.readInt();
    } catch (e) {
      return this.handleParsingError(e, frameInfo, reader);
    }
  }

  if (frameInfo.rowLength === 0) {
    return this.push({
      header: frameInfo.header,
      result: {
        rows: utils$r.emptyArray,
        meta: frameInfo.meta,
        flags: frameInfo.flagsInfo
      }
    });
  }

  var meta = frameInfo.meta;
  frameInfo.rowIndex = frameInfo.rowIndex || 0;

  for (var i = frameInfo.rowIndex; i < frameInfo.rowLength; i++) {
    var rowOffset = reader.offset;
    var row = new types$j.Row(meta.columns);
    var cellBuffer = void 0;

    for (var j = 0; j < meta.columns.length; j++) {
      var c = meta.columns[j];

      try {
        cellBuffer = reader.readBytes();
      } catch (e) {
        return this.handleParsingError(e, frameInfo, reader, rowOffset, i);
      }

      try {
        row[c.name] = this.encoder.decode(cellBuffer, c.type);
      } catch (e) {
        //Something went wrong while decoding, we are not going to be able to recover
        return this.handleParsingError(e, frameInfo, null);
      }
    }

    this.push({
      header: frameInfo.header,
      row: row,
      meta: frameInfo.meta,
      byRow: frameInfo.byRow,
      length: frameInfo.rowLength,
      flags: frameInfo.flagsInfo
    });
  }

  if (frameInfo.byRow) {
    // Use an event item to identify that all the streaming rows have finished processing
    this.push({
      header: frameInfo.header,
      byRowCompleted: true,
      meta: frameInfo.meta,
      length: frameInfo.rowLength,
      flags: frameInfo.flagsInfo
    });
  }
};
/**
 * Sets parser options (ie: how to yield the results as they are parsed)
 * @param {Number} id Id of the stream
 * @param options
 */


Parser.prototype.setOptions = function (id, options) {
  if (this.frames[id.toString()]) {
    throw new types$j.DriverError('There was already state for this frame');
  }

  this.frames[id.toString()] = options;
};
/**
 * Manually clears the frame options.
 * This class already clears the provided options when the frame ends, so it's usually not required to invoke this
 * method.
 * When manually setting the options for continuous paging, it's possible that the frame options are set while
 * it's being cancelled.
 * @param {Number} id The streamId
 */


Parser.prototype.clearOptions = function (id) {
  delete this.frames[id.toString()];
};
/**
 * Gets the frame info from the internal state.
 * In case it is not there, it creates it.
 * In case the frame ended
 */


Parser.prototype.frameState = function (item) {
  var frameInfo = this.frames[item.header.streamId];

  if (!frameInfo) {
    frameInfo = {};

    if (!item.frameEnded) {
      //store it in the frames
      this.frames[item.header.streamId] = frameInfo;
    }
  } else if (item.frameEnded) {
    //if it was already stored, remove it
    delete this.frames[item.header.streamId];
  }

  frameInfo.header = item.header;
  return frameInfo;
};
/**
 * Handles parsing error: pushing an error if its unexpected or buffer the cell if its streaming
 * @param {Error} e
 * @param frameInfo
 * @param {FrameReader} reader
 * @param {Number} [originalOffset]
 * @param {Number} [rowIndex]
 */


Parser.prototype.handleParsingError = function (e, frameInfo, reader, originalOffset, rowIndex) {
  if (reader && frameInfo.isStreaming && e instanceof RangeError) {
    //A controlled error, buffer from offset and move on
    return this.bufferResultCell(frameInfo, reader, originalOffset, rowIndex, e.expectedLength);
  }

  frameInfo.parsingError = true;
  frameInfo.cellBuffer = null;
  this.push({
    header: frameInfo.header,
    error: e
  });
};
/**
 * When streaming, it buffers data since originalOffset.
 * @param frameInfo
 * @param {FrameReader} reader
 * @param {Number} [originalOffset]
 * @param {Number} [rowIndex]
 * @param {Number} [expectedLength]
 */


Parser.prototype.bufferResultCell = function (frameInfo, reader, originalOffset, rowIndex, expectedLength) {
  if (!originalOffset && originalOffset !== 0) {
    originalOffset = reader.offset;
  }

  frameInfo.rowIndex = rowIndex;
  var buffer = reader.slice(originalOffset);
  frameInfo.cellBuffer = {
    parts: [buffer],
    byteLength: buffer.length,
    expectedLength: expectedLength
  };
};
/**
 * Represents a writable streams that emits results
 */


function ResultEmitter(options) {
  Writable.call(this, options);
  /**
   * Stores the rows for frames that needs to be yielded as one result with many rows
   */

  this.rowBuffer = {};
}

util$i.inherits(ResultEmitter, Writable);

ResultEmitter.prototype._write = function (item, encoding, callback) {
  var error = null;

  try {
    this.each(item);
  } catch (err) {
    error = err;
  }

  callback(error);
};
/**
 * Analyzes the item and emit the corresponding event
 */


ResultEmitter.prototype.each = function (item) {
  if (item.error || item.result) {
    //Its either an error or an empty array rows
    //no transformation needs to be made
    return this.emit('result', item.header, item.error, item.result);
  }

  if (item.frameEnded) {
    return this.emit('frameEnded', item.header);
  }

  if (item.lastContinuousPage) {
    return this.emit('lastContinuousPage', item.header);
  }

  if (item.byRowCompleted) {
    return this.emit('byRowCompleted', item.header, item.row, item.meta, item.flags);
  }

  if (item.byRow) {
    //it should be yielded by row
    return this.emit('row', item.header, item.row, item.meta, item.length, item.flags);
  }

  if (item.row) {
    //it should be yielded as a result
    //it needs to be buffered to an array of rows
    return this.bufferAndEmit(item);
  }

  if (item.event) {
    //its an event from Cassandra
    return this.emit('nodeEvent', item.header, item.event);
  } //its a raw response (object with flags)


  return this.emit('result', item.header, null, item);
};
/**
 * Buffers the rows until the result set is completed and emits the result event.
 */


ResultEmitter.prototype.bufferAndEmit = function (item) {
  var rows = this.rowBuffer[item.header.streamId];

  if (!rows) {
    rows = this.rowBuffer[item.header.streamId] = [];
  }

  rows.push(item.row);

  if (rows.length === item.length) {
    this.emit('result', item.header, null, {
      rows: rows,
      meta: item.meta,
      flags: item.flags
    });
    delete this.rowBuffer[item.header.streamId];
  }
};

streams$1.Protocol = Protocol;
streams$1.Parser = Parser;
streams$1.ResultEmitter = ResultEmitter;

var types$i = types$u;
/**
 * Group size
 * @type {number}
 */

var groupSize = 128;
/**
 * Number used to right shift ids to allocate them into groups
 * @const
 * @type {number}
 */

var shiftToGroup = 7;
/**
 * Amount of groups that can be released per time
 * If it grows larger than 4 groups (128 * 4), groups can be released
 * @const
 * @type {number}
 */

var releasableSize = 4;
/**
 * 32K possible stream ids depending for protocol v3 and above
 * @const
 * @type {number}
 */

var maxGroupsFor2Bytes = 256;
/**
 * Delay used to check if groups can be released
 * @const
 * @type {number}
 */

var defaultReleaseDelay = 5000;
/**
 * Represents a queue of ids from 0 to maximum stream id supported by the protocol version.
 * Clients can dequeue a stream id using {@link StreamIdStack#shift()} and enqueue (release) using
 * {@link StreamIdStack#push()}
 */

var StreamIdStack$1 = /*#__PURE__*/function () {
  /**
   * Creates a new instance of StreamIdStack.
   * @param {number} version Protocol version
   * @constructor
   */
  function StreamIdStack(version) {
    _classCallCheck(this, StreamIdStack);

    //Ecmascript Number is 64-bit double, it can be optimized by the engine into a 32-bit int, but nothing below that.
    //We try to allocate as few as possible in arrays of 128
    this.currentGroup = generateGroup(0);
    this.groupIndex = 0;
    this.groups = [this.currentGroup];
    this.releaseTimeout = null;
    this.setVersion(version);
    /**
     * Returns the amount of ids currently in use
     * @member {number}
     */

    this.inUse = 0;
    this.releaseDelay = defaultReleaseDelay;
  }
  /**
   * Sets the protocol version
   * @param {Number} version
   */


  _createClass(StreamIdStack, [{
    key: "setVersion",
    value: function setVersion(version) {
      //128 or 32K stream ids depending on the protocol version
      this.maxGroups = types$i.protocolVersion.uses2BytesStreamIds(version) ? maxGroupsFor2Bytes : 1;
    }
    /**
     * Dequeues an id.
     * Similar to {@link Array#pop()}.
     * @returns {Number} Returns an id or null
     */

  }, {
    key: "pop",
    value: function pop() {
      var id = this.currentGroup.pop();

      if (typeof id !== 'undefined') {
        this.inUse++;
        return id;
      } //try to use the following groups


      while (this.groupIndex < this.groups.length - 1) {
        //move to the following group
        this.currentGroup = this.groups[++this.groupIndex]; //try dequeue

        id = this.currentGroup.pop();

        if (typeof id !== 'undefined') {
          this.inUse++;
          return id;
        }
      }

      return this._tryCreateGroup();
    }
    /**
     * Enqueue an id for future use.
     * Similar to {@link Array#push()}.
     * @param {Number} id
     */

  }, {
    key: "push",
    value: function push(id) {
      this.inUse--;
      var groupIndex = id >> shiftToGroup;
      var group = this.groups[groupIndex];
      group.push(id);

      if (groupIndex < this.groupIndex) {
        //Set the lower group to be used to dequeue from
        this.groupIndex = groupIndex;
        this.currentGroup = group;
      }

      this._tryIssueRelease();
    }
    /**
     * Clears all timers
     */

  }, {
    key: "clear",
    value: function clear() {
      if (this.releaseTimeout) {
        clearTimeout(this.releaseTimeout);
        this.releaseTimeout = null;
      }
    }
    /**
     * Tries to create an additional group and returns a new id
     * @returns {Number} Returns a new id or null if it's not possible to create a new group
     * @private
     */

  }, {
    key: "_tryCreateGroup",
    value: function _tryCreateGroup() {
      if (this.groups.length === this.maxGroups) {
        //we can have an additional group
        return null;
      } //Add a new group at the last position


      this.groupIndex = this.groups.length; //Using 128 * groupIndex as initial value

      this.currentGroup = generateGroup(this.groupIndex << shiftToGroup);
      this.groups.push(this.currentGroup);
      this.inUse++;
      return this.currentGroup.pop();
    }
  }, {
    key: "_tryIssueRelease",
    value: function _tryIssueRelease() {
      var _this = this;

      if (this.releaseTimeout || this.groups.length <= releasableSize) {
        //Nothing to release or a release delay has been issued
        return;
      }

      this.releaseTimeout = setTimeout(function () {
        return _this._releaseGroups();
      }, this.releaseDelay);
    }
  }, {
    key: "_releaseGroups",
    value: function _releaseGroups() {
      var counter = 0;
      var index = this.groups.length - 1; //only release up to n groups (n = releasable size)
      //shrink back up to n groups not all the way up to 1

      while (counter++ < releasableSize && this.groups.length > releasableSize && index > this.groupIndex) {
        if (this.groups[index].length !== groupSize) {
          //the group is being used
          break;
        }

        this.groups.pop();
        index--;
      }

      this.releaseTimeout = null; //Issue next release if applies

      this._tryIssueRelease();
    }
  }]);

  return StreamIdStack;
}();

function generateGroup(initialValue) {
  var arr = new Array(groupSize);
  var upperBound = initialValue + groupSize - 1;

  for (var i = 0; i < groupSize; i++) {
    arr[i] = upperBound - i;
  }

  return arr;
}

var streamIdStack = StreamIdStack$1;

var util$h = require$$0__default$1["default"];
var utils$q = utils$V;
var errors$e = errors$s;
var requests$6 = requests$7;
var ExecuteRequest = requests$6.ExecuteRequest;
var QueryRequest = requests$6.QueryRequest;
var state$1 = {
  init: 0,
  completed: 1,
  timedOut: 2,
  cancelled: 3
};
/**
 * Maintains the state information of a request inside a Connection.
 */

var OperationState$1 = /*#__PURE__*/function () {
  /**
   * Creates a new instance of OperationState.
   * @param {Request} request
   * @param {Function} rowCallback
   * @param {Function} callback
   */
  function OperationState(request, rowCallback, callback) {
    _classCallCheck(this, OperationState);

    this.request = request;
    this._rowCallback = rowCallback;
    this._callback = callback;
    this._timeout = null;
    this._state = state$1.init;
    this._rowIndex = 0;
    /**
     * Stream id that is set right before being written.
     * @type {number}
     */

    this.streamId = -1;
  }
  /**
   * Marks the operation as cancelled, clearing all callbacks and timeouts.
   */


  _createClass(OperationState, [{
    key: "cancel",
    value: function cancel() {
      if (this._state !== state$1.init) {
        return;
      }

      if (this._timeout !== null) {
        clearTimeout(this._timeout);
      }

      this._state = state$1.cancelled;
      this._callback = utils$q.noop;
    }
    /**
     * Determines if the operation can be written to the wire (when it hasn't been cancelled or it hasn't timed out).
     */

  }, {
    key: "canBeWritten",
    value: function canBeWritten() {
      return this._state === state$1.init;
    }
    /**
     * Determines if the response is going to be yielded by row.
     * @return {boolean}
     */

  }, {
    key: "isByRow",
    value: function isByRow() {
      return this._rowCallback && (this.request instanceof ExecuteRequest || this.request instanceof QueryRequest);
    }
    /**
     * Creates the timeout for the request.
     * @param {ExecutionOptions} execOptions
     * @param {Number} defaultReadTimeout
     * @param {String} address
     * @param {Function} onTimeout The callback to be invoked when it times out.
     * @param {Function} onResponse The callback to be invoked if a response is obtained after it timed out.
     */

  }, {
    key: "setRequestTimeout",
    value: function setRequestTimeout(execOptions, defaultReadTimeout, address, onTimeout, onResponse) {
      if (this._state !== state$1.init) {
        // No need to set the timeout
        return;
      }

      var millis = execOptions.getReadTimeout() !== undefined ? execOptions.getReadTimeout() : defaultReadTimeout;

      if (!(millis > 0)) {
        // Read timeout disabled
        return;
      }

      var self = this;
      this._timeout = setTimeout(function requestTimedOut() {
        onTimeout();
        var message = util$h.format('The host %s did not reply before timeout %d ms', address, millis);

        self._markAsTimedOut(new errors$e.OperationTimedOutError(message, address), onResponse);
      }, millis);
    }
  }, {
    key: "setResultRow",
    value: function setResultRow(row, meta, rowLength, flags, header) {
      this._markAsCompleted();

      if (!this._rowCallback) {
        return this.setResult(new errors$e.DriverInternalError('RowCallback not found for streaming frame handler'));
      }

      this._rowCallback(this._rowIndex++, row, rowLength);

      if (this._rowIndex === rowLength) {
        this._swapCallbackAndInvoke(null, {
          rowLength: rowLength,
          meta: meta,
          flags: flags
        }, header.bodyLength);
      }
    }
    /**
     * Marks the current operation as timed out.
     * @param {Error} err
     * @param {Function} onResponse
     * @private
     */

  }, {
    key: "_markAsTimedOut",
    value: function _markAsTimedOut(err, onResponse) {
      if (this._state !== state$1.init) {
        return;
      }

      this._state = state$1.timedOut;

      this._swapCallbackAndInvoke(err, null, null, onResponse);
    }
  }, {
    key: "_markAsCompleted",
    value: function _markAsCompleted() {
      if (this._state !== state$1.init) {
        return;
      }

      if (this._timeout !== null) {
        clearTimeout(this._timeout);
      }

      this._state = state$1.completed;
    }
    /**
     * Sets the result of this operation, declaring that no further input will be processed for this operation.
     * @param {Error} err
     * @param {Object} [result]
     * @param {Number} [length]
     */

  }, {
    key: "setResult",
    value: function setResult(err, result, length) {
      this._markAsCompleted();

      this._swapCallbackAndInvoke(err, result, length);
    }
  }, {
    key: "_swapCallbackAndInvoke",
    value: function _swapCallbackAndInvoke(err, result, length, newCallback) {
      var callback = this._callback;
      this._callback = newCallback || utils$q.noop;
      callback(err, result, length);
    }
  }]);

  return OperationState;
}();

var operationState = OperationState$1;

var events$7 = require$$0__default$2["default"];
var util$g = require$$0__default$1["default"];
var tls = require$$2__default$1["default"];
var net$1 = require$$1__default["default"];
var Encoder$1 = encoder;
var WriteQueue = writers.WriteQueue;
var requests$5 = requests$7;
var streams = streams$1;
var utils$p = utils$V;
var types$h = types$u;
var errors$d = errors$s;
var StreamIdStack = streamIdStack;
var OperationState = operationState;
var promiseUtils$b = promiseUtils$e;
var ExecutionOptions$2 = executionOptions.ExecutionOptions;
/**
 * Represents a connection to a Cassandra node
 */

var Connection$2 = /*#__PURE__*/function (_events$EventEmitter) {
  _inherits(Connection, _events$EventEmitter);

  var _super = _createSuper(Connection);

  /**
   * Creates a new instance of Connection.
   * @param {String} endpoint An string containing ip address and port of the host
   * @param {Number|null} protocolVersion
   * @param {ClientOptions} options
   */
  function Connection(endpoint, protocolVersion, options) {
    var _this;

    _classCallCheck(this, Connection);

    _this = _super.call(this);

    _this.setMaxListeners(0);

    if (!options) {
      throw new Error('options is not defined');
    }
    /**
     * Gets the ip and port of the server endpoint.
     * @type {String}
     */


    _this.endpoint = endpoint;
    /**
     * Gets the friendly name of the host, used to identify the connection in log messages.
     * With direct connect, this is the address and port.
     * With SNI, this will be the address and port of the proxy, plus the server name.
     * @type {String}
     */

    _this.endpointFriendlyName = _this.endpoint;

    if (options.sni) {
      _this._serverName = endpoint;
      _this.endpoint = "".concat(options.sni.addressResolver.getIp(), ":").concat(options.sni.port);
      _this.endpointFriendlyName = "".concat(_this.endpoint, " (").concat(_this._serverName, ")");
    }

    if (!_this.endpoint || _this.endpoint.indexOf(':') < 0) {
      throw new Error('EndPoint must contain the ip address and port separated by : symbol');
    }

    var portSeparatorIndex = _this.endpoint.lastIndexOf(':');

    _this.address = _this.endpoint.substr(0, portSeparatorIndex);
    _this.port = _this.endpoint.substr(portSeparatorIndex + 1);
    Object.defineProperty(_assertThisInitialized(_this), "options", {
      value: options,
      enumerable: false,
      writable: false
    });

    if (protocolVersion === null) {
      // Set initial protocol version
      protocolVersion = types$h.protocolVersion.maxSupported;

      if (options.protocolOptions.maxVersion) {
        // User provided the protocol version
        protocolVersion = options.protocolOptions.maxVersion;
      } // Allow to check version using this connection instance


      _this._checkingVersion = true;
    }

    _this.log = utils$p.log;
    _this.protocolVersion = protocolVersion;
    _this._operations = new Map();
    _this._pendingWrites = [];
    _this._preparing = new Map();
    /**
     * The timeout state for the idle request (heartbeat)
     */

    _this._idleTimeout = null;
    _this.timedOutOperations = 0;
    _this._streamIds = new StreamIdStack(_this.protocolVersion);
    _this._metrics = options.metrics;
    _this.encoder = new Encoder$1(protocolVersion, options);
    _this.keyspace = null;
    _this.emitDrain = false;
    /**
     * Determines if the socket is open and startup succeeded, whether the connection can be used to send requests /
     * receive events
     */

    _this.connected = false;
    /**
     * Determines if the socket can be considered as open
     */

    _this.isSocketOpen = false;
    _this.send = util$g.promisify(_this.sendStream);
    _this.closeAsync = util$g.promisify(_this.close);
    _this.openAsync = util$g.promisify(_this.open);
    _this.prepareOnceAsync = util$g.promisify(_this.prepareOnce);
    return _this;
  }
  /**
   * Binds the necessary event listeners for the socket
   */


  _createClass(Connection, [{
    key: "bindSocketListeners",
    value: function bindSocketListeners() {
      var _this2 = this;

      //Remove listeners that were used for connecting
      this.netClient.removeAllListeners('connect');
      this.netClient.removeAllListeners('timeout'); // The socket is expected to be open at this point

      this.isSocketOpen = true;
      this.netClient.on('close', function () {
        _this2.log('info', "Connection to ".concat(_this2.endpointFriendlyName, " closed"));

        _this2.isSocketOpen = false;
        var wasConnected = _this2.connected;

        _this2.close();

        if (wasConnected) {
          // Emit only when it was closed unexpectedly
          _this2.emit('socketClose');
        }
      });
      this.protocol = new streams.Protocol({
        objectMode: true
      });
      this.parser = new streams.Parser({
        objectMode: true
      }, this.encoder);
      var resultEmitter = new streams.ResultEmitter({
        objectMode: true
      });
      resultEmitter.on('result', this.handleResult.bind(this));
      resultEmitter.on('row', this.handleRow.bind(this));
      resultEmitter.on('frameEnded', this.freeStreamId.bind(this));
      resultEmitter.on('nodeEvent', this.handleNodeEvent.bind(this));
      this.netClient.pipe(this.protocol).pipe(this.parser).pipe(resultEmitter);
      this.writeQueue = new WriteQueue(this.netClient, this.encoder, this.options);
    }
    /**
     * Connects a socket and sends the startup protocol messages.
     * Note that when open() callbacks in error, the caller should immediately call {@link Connection#close}.
     */

  }, {
    key: "open",
    value: function open(callback) {
      var self = this;
      this.log('info', "Connecting to ".concat(this.endpointFriendlyName));

      if (!this.options.sslOptions) {
        this.netClient = new net$1.Socket({
          highWaterMark: this.options.socketOptions.coalescingThreshold
        });
        this.netClient.connect(this.port, this.address, function connectCallback() {
          self.log('verbose', "Socket connected to ".concat(self.endpointFriendlyName));
          self.bindSocketListeners();
          self.startup(callback);
        });
      } else {
        // Use TLS
        var sslOptions = utils$p.extend({
          rejectUnauthorized: false
        }, this.options.sslOptions);

        if (this.options.sni) {
          sslOptions.servername = this._serverName;
        }

        this.netClient = tls.connect(this.port, this.address, sslOptions, function tlsConnectCallback() {
          self.log('verbose', "Secure socket connected to ".concat(self.endpointFriendlyName));
          self.bindSocketListeners();
          self.startup(callback);
        }); // TLSSocket will validate for values from 512 to 16K (depending on the SSL protocol version)

        this.netClient.setMaxSendFragment(this.options.socketOptions.coalescingThreshold);
      }

      this.netClient.once('error', function socketError(err) {
        self.errorConnecting(err, false, callback);
      });
      this.netClient.once('timeout', function connectTimedOut() {
        var err = new types$h.DriverError('Connection timeout');
        self.errorConnecting(err, true, callback);
      });
      this.netClient.setTimeout(this.options.socketOptions.connectTimeout); // Improve failure detection with TCP keep-alives

      if (this.options.socketOptions.keepAlive) {
        this.netClient.setKeepAlive(true, this.options.socketOptions.keepAliveDelay);
      }

      this.netClient.setNoDelay(!!this.options.socketOptions.tcpNoDelay);
    }
    /**
     * Determines the protocol version to use and sends the STARTUP request
     * @param {Function} callback
     */

  }, {
    key: "startup",
    value: function startup(callback) {
      if (this._checkingVersion) {
        this.log('info', 'Trying to use protocol version 0x' + this.protocolVersion.toString(16));
      }

      var self = this;
      var request = new requests$5.StartupRequest({
        noCompact: this.options.protocolOptions.noCompact,
        clientId: this.options.id,
        applicationName: this.options.applicationName,
        applicationVersion: this.options.applicationVersion
      });
      this.sendStream(request, null, function responseCallback(err, response) {
        if (err && self._checkingVersion) {
          var invalidProtocol = err instanceof errors$d.ResponseError && err.code === types$h.responseErrorCodes.protocolError && err.message.indexOf('Invalid or unsupported protocol version') >= 0;

          if (!invalidProtocol && types$h.protocolVersion.canStartupResponseErrorBeWrapped(self.protocolVersion)) {
            //For some versions of Cassandra, the error is wrapped into a server error
            //See CASSANDRA-9451
            invalidProtocol = err instanceof errors$d.ResponseError && err.code === types$h.responseErrorCodes.serverError && err.message.indexOf('ProtocolException: Invalid or unsupported protocol version') > 0;
          }

          if (invalidProtocol) {
            // The server can respond with a message using the lower protocol version supported
            // or using the same version as the one provided
            var lowerVersion = self.protocol.version;

            if (lowerVersion === self.protocolVersion) {
              lowerVersion = types$h.protocolVersion.getLowerSupported(self.protocolVersion);
            } else if (!types$h.protocolVersion.isSupported(self.protocol.version)) {
              // If we have an unsupported protocol version or a beta version we need to switch
              // to something we can support.  Note that dseV1 and dseV2 are excluded from this
              // logic as they are supported.  Also note that any v5 and greater beta protocols
              // are included here since the beta flag was introduced in v5.
              self.log('info', "Protocol version ".concat(self.protocol.version, " not supported by this driver, downgrading"));
              lowerVersion = types$h.protocolVersion.getLowerSupported(self.protocol.version);
            }

            if (!lowerVersion) {
              return startupCallback(new Error('Connection was unable to STARTUP using protocol version ' + self.protocolVersion));
            }

            self.log('info', 'Protocol 0x' + self.protocolVersion.toString(16) + ' not supported, using 0x' + lowerVersion.toString(16));
            self.decreaseVersion(lowerVersion); // The host closed the connection, close the socket and start the connection flow again

            setImmediate(function decreasingVersionClosing() {
              self.close(function decreasingVersionOpening() {
                // Attempt to open with the correct protocol version
                self.open(callback);
              });
            });
            return;
          }
        }

        if (response && response.mustAuthenticate) {
          return self.startAuthenticating(response.authenticatorName, startupCallback);
        }

        startupCallback(err);
      });

      function startupCallback(err) {
        if (err) {
          return self.errorConnecting(err, false, callback);
        } //The socket is connected and the connection is authenticated


        return self.connectionReady(callback);
      }
    }
  }, {
    key: "errorConnecting",
    value: function errorConnecting(err, destroy, callback) {
      this.log('warning', "There was an error when trying to connect to the host ".concat(this.endpointFriendlyName), err);

      if (destroy) {
        //there is a TCP connection that should be killed.
        this.netClient.destroy();
      }

      this._metrics.onConnectionError(err);

      callback(err);
    }
    /**
     * Sets the connection to ready/connected status
     */

  }, {
    key: "connectionReady",
    value: function connectionReady(callback) {
      this.emit('connected');
      this.connected = true; // Remove existing error handlers as the connection is now ready.

      this.netClient.removeAllListeners('error');
      this.netClient.on('error', this.handleSocketError.bind(this));
      callback();
    }
    /** @param {Number} lowerVersion */

  }, {
    key: "decreaseVersion",
    value: function decreaseVersion(lowerVersion) {
      // The response already has the max protocol version supported by the Cassandra host.
      this.protocolVersion = lowerVersion;
      this.encoder.setProtocolVersion(lowerVersion);

      this._streamIds.setVersion(lowerVersion);
    }
    /**
     * Handle socket errors, if the socket is not readable invoke all pending callbacks
     */

  }, {
    key: "handleSocketError",
    value: function handleSocketError(err) {
      this._metrics.onConnectionError(err);

      this.clearAndInvokePending(err);
    }
    /**
     * Cleans all internal state and invokes all pending callbacks of sent streams
     */

  }, {
    key: "clearAndInvokePending",
    value: function clearAndInvokePending(innerError) {
      if (this._idleTimeout) {
        //Remove the idle request
        clearTimeout(this._idleTimeout);
        this._idleTimeout = null;
      }

      this._streamIds.clear();

      if (this.emitDrain) {
        this.emit('drain');
      }

      var err = new types$h.DriverError('Socket was closed');
      err.isSocketError = true;

      if (innerError) {
        err.innerError = innerError;
      } // Get all handlers


      var operations = Array.from(this._operations.values()); // Clear pending operation map

      this._operations = new Map();

      if (operations.length > 0) {
        this.log('info', 'Invoking ' + operations.length + ' pending callbacks');
      } // Invoke all handlers


      utils$p.each(operations, function (operation, next) {
        operation.setResult(err);
        next();
      });
      var pendingWritesCopy = this._pendingWrites;
      this._pendingWrites = [];
      utils$p.each(pendingWritesCopy, function (operation, next) {
        operation.setResult(err);
        next();
      });
    }
    /**
     * Starts the SASL flow
     * @param {String} authenticatorName
     * @param {Function} callback
     */

  }, {
    key: "startAuthenticating",
    value: function startAuthenticating(authenticatorName, callback) {
      if (!this.options.authProvider) {
        return callback(new errors$d.AuthenticationError('Authentication provider not set'));
      }

      var authenticator = this.options.authProvider.newAuthenticator(this.endpoint, authenticatorName);
      var self = this;
      authenticator.initialResponse(function initialResponseCallback(err, token) {
        // Start the flow with the initial token
        if (err) {
          return self.onAuthenticationError(callback, err);
        }

        self.authenticate(authenticator, token, callback);
      });
    }
    /**
     * Handles authentication requests and responses.
     * @param {Authenticator} authenticator
     * @param {Buffer} token
     * @param {Function} callback
     */

  }, {
    key: "authenticate",
    value: function authenticate(authenticator, token, callback) {
      var self = this;
      var request = new requests$5.AuthResponseRequest(token);

      if (this.protocolVersion === 1) {
        //No Sasl support, use CREDENTIALS
        if (!authenticator.username) {
          return self.onAuthenticationError(callback, new errors$d.AuthenticationError('Only plain text authenticator providers allowed under protocol v1'));
        }

        request = new requests$5.CredentialsRequest(authenticator.username, authenticator.password);
      }

      this.sendStream(request, null, function authResponseCallback(err, result) {
        if (err) {
          if (err instanceof errors$d.ResponseError && err.code === types$h.responseErrorCodes.badCredentials) {
            var authError = new errors$d.AuthenticationError(err.message);
            authError.additionalInfo = err;
            err = authError;
          }

          return self.onAuthenticationError(callback, err);
        }

        if (result.ready) {
          authenticator.onAuthenticationSuccess();
          return callback();
        }

        if (result.authChallenge) {
          return authenticator.evaluateChallenge(result.token, function evaluateCallback(err, t) {
            if (err) {
              return self.onAuthenticationError(callback, err);
            } //here we go again


            self.authenticate(authenticator, t, callback);
          });
        }

        callback(new errors$d.DriverInternalError('Unexpected response from Cassandra: ' + util$g.inspect(result)));
      });
    }
  }, {
    key: "onAuthenticationError",
    value: function onAuthenticationError(callback, err) {
      this._metrics.onAuthenticationError(err);

      callback(err);
    }
    /**
     * Executes a 'USE ' query, if keyspace is provided and it is different from the current keyspace
     * @param {?String} keyspace
     */

  }, {
    key: "changeKeyspace",
    value: function () {
      var _changeKeyspace = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(keyspace) {
        var query;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(!keyspace || this.keyspace === keyspace)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                if (!(this.toBeKeyspace === keyspace)) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", promiseUtils$b.fromEvent(this, 'keyspaceChanged'));

              case 4:
                this.toBeKeyspace = keyspace;
                query = "USE \"".concat(keyspace, "\"");
                _context.prev = 6;
                _context.next = 9;
                return this.send(new requests$5.QueryRequest(query, null, null), null);

              case 9:
                this.keyspace = keyspace;
                this.emit('keyspaceChanged', null, keyspace);
                _context.next = 18;
                break;

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](6);
                this.log('error', "Connection to ".concat(this.endpointFriendlyName, " could not switch active keyspace: ").concat(_context.t0), _context.t0);
                this.emit('keyspaceChanged', _context.t0);
                throw _context.t0;

              case 18:
                _context.prev = 18;
                this.toBeKeyspace = null;
                return _context.finish(18);

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[6, 13, 18, 21]]);
      }));

      function changeKeyspace(_x) {
        return _changeKeyspace.apply(this, arguments);
      }

      return changeKeyspace;
    }()
    /**
     * Prepares a query on a given connection. If its already being prepared, it queues the callback.
     * @param {String} query
     * @param {String} keyspace
     * @param {function} callback
     */

  }, {
    key: "prepareOnce",
    value: function prepareOnce(query, keyspace, callback) {
      var _this3 = this;

      var name = (keyspace || '') + query;

      var info = this._preparing.get(name);

      if (info) {
        // Its being already prepared
        return info.once('prepared', callback);
      }

      info = new events$7.EventEmitter();
      info.setMaxListeners(0);
      info.once('prepared', callback);

      this._preparing.set(name, info);

      this.sendStream(new requests$5.PrepareRequest(query, keyspace), null, function (err, response) {
        info.emit('prepared', err, response);

        _this3._preparing["delete"](name);
      });
    }
    /**
     * Queues the operation to be written to the wire and invokes the callback once the response was obtained or with an
     * error (socket error or OperationTimedOutError or serialization-related error).
     * @param {Request} request
     * @param {ExecutionOptions|null} execOptions
     * @param {function} callback Function to be called once the response has been received
     * @return {OperationState}
     */

  }, {
    key: "sendStream",
    value: function sendStream(request, execOptions, callback) {
      var _this4 = this;

      execOptions = execOptions || ExecutionOptions$2.empty(); // Create a new operation that will contain the request, callback and timeouts

      var operation = new OperationState(request, execOptions.getRowCallback(), function (err, response, length) {
        if (!err || !err.isSocketError) {
          // Emit that a response was obtained when there is a valid response
          // or when the error is not a socket error
          _this4.emit('responseDequeued');
        }

        callback(err, response, length);
      });

      var streamId = this._getStreamId(); // Start the request timeout without waiting for the request to be written


      operation.setRequestTimeout(execOptions, this.options.socketOptions.readTimeout, this.endpoint, function () {
        return _this4.timedOutOperations++;
      }, function () {
        return _this4.timedOutOperations--;
      });

      if (streamId === null) {
        this.log('info', 'Enqueuing ' + this._pendingWrites.length + ', if this message is recurrent consider configuring more connections per host or lowering the pressure');

        this._pendingWrites.push(operation);

        return operation;
      }

      this._write(operation, streamId);

      return operation;
    }
    /**
     * Pushes the item into the queue.
     * @param {OperationState} operation
     * @param {Number} streamId
     * @private
     */

  }, {
    key: "_write",
    value: function _write(operation, streamId) {
      operation.streamId = streamId;
      var self = this;
      this.writeQueue.push(operation, function writeCallback(err) {
        if (err) {
          // The request was not written.
          // There was a serialization error or the operation has already timed out or was cancelled
          self._streamIds.push(streamId);

          return operation.setResult(err);
        }

        self.log('verbose', 'Sent stream #' + streamId + ' to ' + self.endpointFriendlyName);

        if (operation.isByRow()) {
          self.parser.setOptions(streamId, {
            byRow: true
          });
        }

        self._setIdleTimeout();

        self._operations.set(streamId, operation);
      });
    }
  }, {
    key: "_setIdleTimeout",
    value: function _setIdleTimeout() {
      if (!this.options.pooling.heartBeatInterval) {
        return;
      }

      var self = this; // Scheduling the new timeout before de-scheduling the previous performs significantly better
      // than de-scheduling first, see nodejs implementation: https://github.com/nodejs/node/blob/master/lib/timers.js

      var previousTimeout = this._idleTimeout;
      self._idleTimeout = setTimeout(function () {
        return self._idleTimeoutHandler();
      }, self.options.pooling.heartBeatInterval);

      if (previousTimeout) {
        //remove the previous timeout for the idle request
        clearTimeout(previousTimeout);
      }
    }
    /**
     * Function that gets executed once the idle timeout has passed to issue a request to keep the connection alive
     */

  }, {
    key: "_idleTimeoutHandler",
    value: function _idleTimeoutHandler() {
      var _this5 = this;

      if (this.sendingIdleQuery) {
        //don't issue another
        //schedule for next time
        this._idleTimeout = setTimeout(function () {
          return _this5._idleTimeoutHandler();
        }, this.options.pooling.heartBeatInterval);
        return;
      }

      this.log('verbose', "Connection to ".concat(this.endpointFriendlyName, " idling, issuing a request to prevent disconnects"));
      this.sendingIdleQuery = true;
      this.sendStream(requests$5.options, null, function (err) {
        _this5.sendingIdleQuery = false;

        if (!err) {
          //The sending succeeded
          //There is a valid response but we don't care about the response
          return;
        }

        _this5.log('warning', 'Received heartbeat request error', err);

        _this5.emit('idleRequestError', err, _this5);
      });
    }
    /**
     * Returns an available streamId or null if there isn't any available
     * @returns {Number}
     */

  }, {
    key: "_getStreamId",
    value: function _getStreamId() {
      return this._streamIds.pop();
    }
  }, {
    key: "freeStreamId",
    value: function freeStreamId(header) {
      var streamId = header.streamId;

      if (streamId < 0) {
        // Event ids don't have a matching request operation
        return;
      }

      this._operations["delete"](streamId);

      this._streamIds.push(streamId);

      if (this.emitDrain && this._streamIds.inUse === 0 && this._pendingWrites.length === 0) {
        this.emit('drain');
      }

      this._writeNext();
    }
  }, {
    key: "_writeNext",
    value: function _writeNext() {
      if (this._pendingWrites.length === 0) {
        return;
      }

      var streamId = this._getStreamId();

      if (streamId === null) {
        // No streamId available
        return;
      }

      var self = this;
      var operation;

      while ((operation = this._pendingWrites.shift()) && !operation.canBeWritten()) {// Trying to obtain an pending operation that can be written
      }

      if (!operation) {
        // There isn't a pending operation that can be written
        this._streamIds.push(streamId);

        return;
      } // Schedule after current I/O callbacks have been executed


      setImmediate(function writeNextPending() {
        self._write(operation, streamId);
      });
    }
    /**
     * Returns the number of requests waiting for response
     * @returns {Number}
     */

  }, {
    key: "getInFlight",
    value: function getInFlight() {
      return this._streamIds.inUse;
    }
    /**
     * Handles a result and error response
     */

  }, {
    key: "handleResult",
    value: function handleResult(header, err, result) {
      var streamId = header.streamId;

      if (streamId < 0) {
        return this.log('verbose', 'event received', header);
      }

      var operation = this._operations.get(streamId);

      if (!operation) {
        return this.log('error', 'The server replied with a wrong streamId #' + streamId);
      }

      this.log('verbose', 'Received frame #' + streamId + ' from ' + this.endpointFriendlyName);
      operation.setResult(err, result, header.bodyLength);
    }
  }, {
    key: "handleNodeEvent",
    value: function handleNodeEvent(header, event) {
      switch (event.eventType) {
        case types$h.protocolEvents.schemaChange:
          this.emit('nodeSchemaChange', event);
          break;

        case types$h.protocolEvents.topologyChange:
          this.emit('nodeTopologyChange', event);
          break;

        case types$h.protocolEvents.statusChange:
          this.emit('nodeStatusChange', event);
          break;
      }
    }
    /**
     * Handles a row response
     */

  }, {
    key: "handleRow",
    value: function handleRow(header, row, meta, rowLength, flags) {
      var streamId = header.streamId;

      if (streamId < 0) {
        return this.log('verbose', 'Event received', header);
      }

      var operation = this._operations.get(streamId);

      if (!operation) {
        return this.log('error', 'The server replied with a wrong streamId #' + streamId);
      }

      operation.setResultRow(row, meta, rowLength, flags, header);
    }
    /**
     * Closes the socket (if not already closed) and cancels all in-flight requests.
     * Multiple calls to this method have no additional side-effects.
     * @param {Function} [callback]
     */

  }, {
    key: "close",
    value: function close(callback) {
      var _this6 = this;

      callback = callback || utils$p.noop;

      if (!this.connected && !this.isSocketOpen) {
        return callback();
      }

      this.connected = false; // Drain is never going to be emitted, once it is set to closed

      this.removeAllListeners('drain');
      this.clearAndInvokePending();

      if (!this.isSocketOpen) {
        return callback();
      } // Set the socket as closed now (before socket.end() is called) to avoid being invoked more than once


      this.isSocketOpen = false;
      this.log('verbose', "Closing connection to ".concat(this.endpointFriendlyName));
      var self = this; // If server doesn't acknowledge the half-close within connection timeout, destroy the socket.

      var endTimeout = setTimeout(function () {
        _this6.log('info', "".concat(_this6.endpointFriendlyName, " did not respond to connection close within ") + "".concat(_this6.options.socketOptions.connectTimeout, "ms, destroying connection"));

        _this6.netClient.destroy();
      }, this.options.socketOptions.connectTimeout);
      this.netClient.once('close', function (hadError) {
        clearTimeout(endTimeout);

        if (hadError) {
          self.log('info', 'The socket closed with a transmission error');
        }

        setImmediate(callback);
      }); // At this point, the error event can be triggered because:
      // - It's connected and writes haven't completed yet
      // - The server abruptly closed its end of the connection (ECONNRESET) as a result of protocol error / auth error
      // We need to remove any listeners and make sure we callback are pending writes

      this.netClient.removeAllListeners('error');
      this.netClient.on('error', function (err) {
        return _this6.clearAndInvokePending(err);
      }); // Half-close the socket, it will result in 'close' event being fired

      this.netClient.end();
    }
    /**
     * Gets the local IP address to which this connection socket is bound to.
     * @returns {String|undefined}
     */

  }, {
    key: "getLocalAddress",
    value: function getLocalAddress() {
      if (!this.netClient) {
        return undefined;
      }

      return this.netClient.localAddress;
    }
  }]);

  return Connection;
}(events$7.EventEmitter);

var connection = Connection$2;

var util$f = require$$0__default$1["default"];
var events$6 = require$$0__default$2["default"];
var Connection$1 = connection;
var utils$o = utils$V;
var promiseUtils$a = promiseUtils$e;
var errors$c = errors$s;
var clientOptions$1 = clientOptions$3; // Used to get the index of the connection with less in-flight requests

var connectionIndex = 0;
var connectionIndexOverflow = Math.pow(2, 15);
var defaultOptions$1;
/**
 * Represents the possible states of the pool.
 * Possible state transitions:
 *  - From initial to closing: The pool must be closed because the host is ignored.
 *  - From initial to shuttingDown: The pool is being shutdown as a result of a client shutdown.
 *  - From closing to initial state: The pool finished closing connections (is now ignored) and it resets to
 *    initial state in case the host is marked as local/remote in the future.
 *  - From closing to shuttingDown (rare): It was marked as ignored, now the client is being shutdown.
 *  - From shuttingDown to shutdown: Finished shutting down, the pool should not be reused.
 * @private
 */

var state = {
  // Initial state: open / opening / ready to be opened
  initial: 0,
  // When the pool is being closed as part of a distance change
  closing: 1,
  // When the pool is being shutdown for good
  shuttingDown: 2,
  // When the pool has being shutdown
  shutDown: 4
};
/**
 * Represents a pool of connections to a host
 */

var HostConnectionPool$1 = /*#__PURE__*/function (_events$EventEmitter) {
  _inherits(HostConnectionPool, _events$EventEmitter);

  var _super = _createSuper(HostConnectionPool);

  /**
   * Creates a new instance of HostConnectionPool.
   * @param {Host} host
   * @param {Number} protocolVersion Initial protocol version
   * @extends EventEmitter
   */
  function HostConnectionPool(host, protocolVersion) {
    var _this;

    _classCallCheck(this, HostConnectionPool);

    _this = _super.call(this);
    _this._address = host.address;
    _this._newConnectionTimeout = null;
    _this._state = state.initial;
    _this._opening = false;
    _this._host = host;
    _this.responseCounter = 0;
    _this.options = host.options;
    _this.protocolVersion = protocolVersion;
    _this.coreConnectionsLength = 1;
    /**
     * An immutable array of connections
     * @type {Array.<Connection>}
     */

    _this.connections = utils$o.emptyArray;

    _this.setMaxListeners(0);

    _this.log = utils$o.log;
    return _this;
  }

  _createClass(HostConnectionPool, [{
    key: "getInFlight",
    value: function getInFlight() {
      var length = this.connections.length;

      if (length === 1) {
        return this.connections[0].getInFlight();
      }

      var sum = 0;

      for (var i = 0; i < length; i++) {
        sum += this.connections[i].getInFlight();
      }

      return sum;
    }
    /**
     * Gets the least busy connection from the pool.
     * @param {Connection} [previousConnection] When provided, the pool should attempt to obtain a different connection.
     * @returns {Connection!}
     * @throws {Error}
     * @throws {BusyConnectionError}
     */

  }, {
    key: "borrowConnection",
    value: function borrowConnection(previousConnection) {
      if (this.connections.length === 0) {
        throw new Error('No connection available');
      }

      var maxRequests = this.options.pooling.maxRequestsPerConnection;
      var c = HostConnectionPool.minInFlight(this.connections, maxRequests, previousConnection);

      if (c.getInFlight() >= maxRequests) {
        throw new errors$c.BusyConnectionError(this._address, maxRequests, this.connections.length);
      }

      return c;
    }
    /**
     * Gets the connection with the minimum number of in-flight requests.
     * Only checks for 2 connections (round-robin) and gets the one with minimum in-flight requests, as long as
     * the amount of in-flight requests is lower than maxRequests.
     * @param {Array.<Connection>} connections
     * @param {Number} maxRequests
     * @param {Connection} previousConnection When provided, it will attempt to obtain a different connection.
     * @returns {Connection!}
     */

  }, {
    key: "warmup",
    value:
    /**
     * Creates all the connections in the pool and switches the keyspace of each connection if needed.
     * @param {string} keyspace
     */
    function () {
      var _warmup = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(keyspace) {
        var _iterator, _step, connection;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this.connections.length < this.coreConnectionsLength)) {
                  _context.next = 9;
                  break;
                }

              case 1:
                if (!(this.connections.length < this.coreConnectionsLength)) {
                  _context.next = 6;
                  break;
                }

                _context.next = 4;
                return this._attemptNewConnection();

              case 4:
                _context.next = 1;
                break;

              case 6:
                this.log('info', "Connection pool to host ".concat(this._address, " created with ").concat(this.connections.length, " connection(s)"));
                _context.next = 10;
                break;

              case 9:
                this.log('info', "Connection pool to host ".concat(this._address, " contains ").concat(this.connections.length, " connection(s)"));

              case 10:
                if (!keyspace) {
                  _context.next = 34;
                  break;
                }

                _context.prev = 11;
                _iterator = _createForOfIteratorHelper(this.connections);
                _context.prev = 13;

                _iterator.s();

              case 15:
                if ((_step = _iterator.n()).done) {
                  _context.next = 21;
                  break;
                }

                connection = _step.value;
                _context.next = 19;
                return connection.changeKeyspace(keyspace);

              case 19:
                _context.next = 15;
                break;

              case 21:
                _context.next = 26;
                break;

              case 23:
                _context.prev = 23;
                _context.t0 = _context["catch"](13);

                _iterator.e(_context.t0);

              case 26:
                _context.prev = 26;

                _iterator.f();

                return _context.finish(26);

              case 29:
                _context.next = 34;
                break;

              case 31:
                _context.prev = 31;
                _context.t1 = _context["catch"](11);
                // Log it and move on, it could be a momentary schema mismatch failure
                this.log('warning', "Connection(s) to host ".concat(this._address, " could not be switched to keyspace ").concat(keyspace));

              case 34:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[11, 31], [13, 23, 26, 29]]);
      }));

      function warmup(_x) {
        return _warmup.apply(this, arguments);
      }

      return warmup;
    }()
    /** @returns {Connection} */

  }, {
    key: "_createConnection",
    value: function _createConnection() {
      var endpointOrServerName = !this.options.sni ? this._address : this._host.hostId.toString();
      var c = new Connection$1(endpointOrServerName, this.protocolVersion, this.options);

      this._addListeners(c);

      return c;
    }
    /** @param {Connection} c */

  }, {
    key: "_addListeners",
    value: function _addListeners(c) {
      var _this2 = this;

      c.on('responseDequeued', function () {
        return _this2.responseCounter++;
      });
      var self = this;

      function connectionErrorCallback() {
        // The socket is not fully open / can not send heartbeat
        self.remove(c);
      }

      c.on('idleRequestError', connectionErrorCallback);
      c.on('socketClose', connectionErrorCallback);
    }
  }, {
    key: "addExistingConnection",
    value: function addExistingConnection(c) {
      this._addListeners(c); // Use a copy of the connections array


      this.connections = this.connections.slice(0);
      this.connections.push(c);
    }
    /**
     * Prevents reconnection timeout from triggering
     */

  }, {
    key: "clearNewConnectionAttempt",
    value: function clearNewConnectionAttempt() {
      if (!this._newConnectionTimeout) {
        return;
      }

      clearTimeout(this._newConnectionTimeout);
      this._newConnectionTimeout = null;
    }
    /**
     * Tries to open a new connection.
     * If a connection is being opened, it will resolve when the existing open task completes.
     * @returns {Promise<void>}
     */

  }, {
    key: "_attemptNewConnection",
    value: function () {
      var _attemptNewConnection2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var c, err, newConnections;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this._opening) {
                  _context2.next = 4;
                  break;
                }

                _context2.next = 3;
                return promiseUtils$a.fromEvent(this, 'open');

              case 3:
                return _context2.abrupt("return", _context2.sent);

              case 4:
                this._opening = true;
                c = this._createConnection();
                _context2.prev = 6;
                _context2.next = 9;
                return c.openAsync();

              case 9:
                _context2.next = 15;
                break;

              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2["catch"](6);
                err = _context2.t0;
                this.log('warning', "Connection to ".concat(this._address, " could not be created: ").concat(err), err);

              case 15:
                if (this.isClosing()) {
                  this.log('info', "Connection to ".concat(this._address, " opened successfully but pool was being closed"));
                  err = new Error('Connection closed');
                }

                if (!err) {
                  // Append the connection to the pool.
                  // Use a copy of the connections array.
                  newConnections = this.connections.slice(0);
                  newConnections.push(c);
                  this.connections = newConnections;
                  this.log('info', "Connection to ".concat(this._address, " opened successfully"));
                } else {
                  promiseUtils$a.toBackground(c.closeAsync());
                } // Notify that creation finished by setting the flag and emitting the event


                this._opening = false;
                this.emit('open', err, c);

                if (!err) {
                  _context2.next = 21;
                  break;
                }

                throw err;

              case 21:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 11]]);
      }));

      function _attemptNewConnection() {
        return _attemptNewConnection2.apply(this, arguments);
      }

      return _attemptNewConnection;
    }()
  }, {
    key: "attemptNewConnectionImmediate",
    value: function attemptNewConnectionImmediate() {
      var self = this;

      function openConnection() {
        self.clearNewConnectionAttempt();
        self.scheduleNewConnectionAttempt(0);
      }

      if (this._state === state.initial) {
        return openConnection();
      }

      if (this._state === state.closing) {
        return this.once('close', openConnection);
      } // In the case the pool its being / has been shutdown for good
      // Do not attempt to create a new connection.

    }
    /**
     * Closes the connection and removes a connection from the pool.
     * @param {Connection} connection
     */

  }, {
    key: "remove",
    value: function remove(connection) {
      // locating an object by position in the array is O(n), but normally there should be between 1 to 8 connections.
      var index = this.connections.indexOf(connection);

      if (index < 0) {
        // it was already removed from the connections and it's closing
        return;
      } // remove the connection from the pool, using an pool copy


      var newConnections = this.connections.slice(0);
      newConnections.splice(index, 1);
      this.connections = newConnections; // close the connection

      setImmediate(function removeClose() {
        connection.close();
      });
      this.emit('remove');
    }
    /**
     * @param {Number} delay
     */

  }, {
    key: "scheduleNewConnectionAttempt",
    value: function scheduleNewConnectionAttempt(delay) {
      if (this.isClosing()) {
        return;
      }

      var self = this;
      this._newConnectionTimeout = setTimeout(function newConnectionTimeoutExpired() {
        self._newConnectionTimeout = null;

        if (self.connections.length >= self.coreConnectionsLength) {
          // new connection can be scheduled while a new connection is being opened
          // the pool has the appropriate size
          return;
        }

        if (delay > 0 && self.options.sni) {
          // We use delay > 0 as an indication that it's a reconnection.
          // A reconnection schedule can use delay = 0 as well, but it's a good enough signal.
          promiseUtils$a.toBackground(self.options.sni.addressResolver.refresh().then(function () {
            return self._attemptNewConnection();
          }));
          return;
        }

        promiseUtils$a.toBackground(self._attemptNewConnection());
      }, delay);
    }
  }, {
    key: "hasScheduledNewConnection",
    value: function hasScheduledNewConnection() {
      return !!this._newConnectionTimeout || this._opening;
    }
    /**
     * Increases the size of the connection pool in the background, if needed.
     */

  }, {
    key: "increaseSize",
    value: function increaseSize() {
      if (this.connections.length < this.coreConnectionsLength && !this.hasScheduledNewConnection()) {
        // schedule the next connection in the background
        this.scheduleNewConnectionAttempt(0);
      }
    }
    /**
     * Gets the amount of responses and resets the internal counter.
     * @returns {number}
     */

  }, {
    key: "getAndResetResponseCounter",
    value: function getAndResetResponseCounter() {
      var temp = this.responseCounter;
      this.responseCounter = 0;
      return temp;
    }
    /**
     * Gets a boolean indicating if the pool is being closed / shutting down or has been shutdown.
     */

  }, {
    key: "isClosing",
    value: function isClosing() {
      return this._state !== state.initial;
    }
    /**
     * Gracefully waits for all in-flight requests to finish and closes the pool.
     */

  }, {
    key: "drainAndShutdown",
    value: function drainAndShutdown() {
      if (this.isClosing()) {
        // Its already closing / shutting down
        return;
      }

      this._state = state.closing;
      this.clearNewConnectionAttempt();

      if (this.connections.length === 0) {
        return this._afterClosing();
      }

      var self = this;
      var connections = this.connections;
      this.connections = utils$o.emptyArray;
      var closedConnections = 0;
      this.log('info', util$f.format('Draining and closing %d connections to %s', connections.length, this._address));
      var wasClosed = false; // eslint-disable-next-line prefer-const

      var checkShutdownTimeout;

      for (var i = 0; i < connections.length; i++) {
        var c = connections[i];

        if (c.getInFlight() === 0) {
          getDelayedClose(c)();
          continue;
        }

        c.emitDrain = true;
        c.once('drain', getDelayedClose(c));
      }

      function getDelayedClose(connection) {
        return function delayedClose() {
          connection.close();

          if (++closedConnections < connections.length) {
            return;
          }

          if (wasClosed) {
            return;
          }

          wasClosed = true;

          if (checkShutdownTimeout) {
            clearTimeout(checkShutdownTimeout);
          }

          self._afterClosing();
        };
      } // Check that after sometime (readTimeout + 100ms) the connections have been drained


      var delay = (this.options.socketOptions.readTimeout || getDefaultOptions().socketOptions.readTimeout) + 100;
      checkShutdownTimeout = setTimeout(function checkShutdown() {
        wasClosed = true;
        connections.forEach(function connectionEach(c) {
          c.close();
        });

        self._afterClosing();
      }, delay);
    }
  }, {
    key: "_afterClosing",
    value: function _afterClosing() {
      var self = this;

      function resetState() {
        if (self._state === state.shuttingDown) {
          self._state = state.shutDown;
        } else {
          self._state = state.initial;
        }

        self.emit('close');

        if (self._state === state.shutDown) {
          self.emit('shutdown');
        }
      }

      if (this._opening) {
        // The pool is growing, reset the state back to init once the open finished (without any new connection)
        return this.once('open', resetState);
      }

      resetState();
    }
    /**
     * @returns {Promise<void>}
     */

  }, {
    key: "shutdown",
    value: function () {
      var _shutdown = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var previousState;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.clearNewConnectionAttempt();

                if (this.connections.length) {
                  _context3.next = 4;
                  break;
                }

                this._state = state.shutDown;
                return _context3.abrupt("return");

              case 4:
                previousState = this._state;
                this._state = state.shuttingDown;

                if (!(previousState === state.closing || previousState === state.shuttingDown)) {
                  _context3.next = 8;
                  break;
                }

                return _context3.abrupt("return", promiseUtils$a.fromEvent(this, 'shutdown'));

              case 8:
                _context3.next = 10;
                return this._closeAllConnections();

              case 10:
                this._state = state.shutDown;
                this.emit('shutdown');

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function shutdown() {
        return _shutdown.apply(this, arguments);
      }

      return shutdown;
    }()
  }, {
    key: "_closeAllConnections",
    value: function () {
      var _closeAllConnections2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var connections;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                connections = this.connections; // point to an empty array

                this.connections = utils$o.emptyArray;

                if (!(connections.length === 0)) {
                  _context4.next = 4;
                  break;
                }

                return _context4.abrupt("return");

              case 4:
                this.log('info', util$f.format('Closing %d connections to %s', connections.length, this._address));
                _context4.next = 7;
                return Promise.all(connections.map(function (c) {
                  return c.closeAsync();
                }));

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _closeAllConnections() {
        return _closeAllConnections2.apply(this, arguments);
      }

      return _closeAllConnections;
    }()
  }], [{
    key: "minInFlight",
    value: function minInFlight(connections, maxRequests, previousConnection) {
      var length = connections.length;

      if (length === 1) {
        return connections[0];
      } // Use a single index for all hosts as a simplified way to balance the load between connections


      connectionIndex++;

      if (connectionIndex >= connectionIndexOverflow) {
        connectionIndex = 0;
      }

      var current;

      for (var index = connectionIndex; index < connectionIndex + length; index++) {
        current = connections[index % length];

        if (current === previousConnection) {
          // Increment the index and skip
          current = connections[++index % length];
        }

        var next = connections[(index + 1) % length];

        if (next === previousConnection) {
          // Skip
          next = connections[(index + 2) % length];
        }

        if (next.getInFlight() < current.getInFlight()) {
          current = next;
        }

        if (current.getInFlight() < maxRequests) {
          // Check as few connections as possible, as long as the amount of in-flight
          // requests is lower than maxRequests
          break;
        }
      }

      return current;
    }
  }]);

  return HostConnectionPool;
}(events$6.EventEmitter);
/** Lazily loads the default options */


function getDefaultOptions() {
  if (defaultOptions$1 === undefined) {
    defaultOptions$1 = clientOptions$1.defaultOptions();
  }

  return defaultOptions$1;
}

var hostConnectionPool = HostConnectionPool$1;

var errors$b = errors$s;
var utils$n = utils$V;
var types$g = types$u;
var promiseUtils$9 = promiseUtils$e;
/**
 * Encapsulates the logic for dealing with the different prepare request and response flows, including failover when
 * trying to prepare a query.
 */

var PrepareHandler$2 = /*#__PURE__*/function () {
  /**
   * Creates a new instance of PrepareHandler
   * @param {Client} client
   * @param {LoadBalancingPolicy} loadBalancing
   */
  function PrepareHandler(client, loadBalancing) {
    _classCallCheck(this, PrepareHandler);

    this._client = client;
    this._loadBalancing = loadBalancing;
    this.logEmitter = client.options.logEmitter;
    this.log = utils$n.log;
  }
  /**
   * Gets the query id and metadata for a prepared statement, preparing it on
   * single host or on all hosts depending on the options.
   * @param {Client} client
   * @param {LoadBalancingPolicy} loadBalancing
   * @param {String} query
   * @param {String} keyspace
   * @returns {Promise<{queryId, meta}>}
   * @static
   */


  _createClass(PrepareHandler, [{
    key: "_prepare",
    value:
    /**
     * Prepares the query on a single host or on all hosts depending on the options.
     * Uses the info 'prepared' event to emit the result.
     * @param {Object} info
     * @param {String} query
     * @param {String} keyspace
     * @returns {Promise<{queryId, meta}>}
     */
    function () {
      var _prepare2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(info, query, keyspace) {
        var iterator;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                info.preparing = true;
                _context.prev = 1;
                _context.next = 4;
                return promiseUtils$9.newQueryPlan(this._loadBalancing, keyspace, null);

              case 4:
                iterator = _context.sent;
                _context.next = 7;
                return this._prepareWithQueryPlan(info, iterator, query, keyspace);

              case 7:
                return _context.abrupt("return", _context.sent);

              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](1);
                info.preparing = false;
                _context.t0.query = query;
                info.emit('prepared', _context.t0);
                throw _context.t0;

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 10]]);
      }));

      function _prepare(_x, _x2, _x3) {
        return _prepare2.apply(this, arguments);
      }

      return _prepare;
    }()
    /**
     * Uses the query plan to prepare the query on the first host and optionally on the rest of the hosts.
     * @param {Object} info
     * @param {Iterator} iterator
     * @param {String} query
     * @param {String} keyspace
     * @returns {Promise<{queryId, meta}>}
     * @private
     */

  }, {
    key: "_prepareWithQueryPlan",
    value: function () {
      var _prepareWithQueryPlan2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(info, iterator, query, keyspace) {
        var triedHosts, host, connection, response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                triedHosts = {};

              case 1:

                host = PrepareHandler.getNextHost(iterator, this._client.profileManager, triedHosts);

                if (!(host === null)) {
                  _context2.next = 5;
                  break;
                }

                throw new errors$b.NoHostAvailableError(triedHosts);

              case 5:
                _context2.prev = 5;
                _context2.next = 8;
                return PrepareHandler._borrowWithKeyspace(host, keyspace);

              case 8:
                connection = _context2.sent;
                _context2.next = 11;
                return connection.prepareOnceAsync(query, keyspace);

              case 11:
                response = _context2.sent;

                if (!this._client.options.prepareOnAllHosts) {
                  _context2.next = 15;
                  break;
                }

                _context2.next = 15;
                return this._prepareOnAllHosts(iterator, query, keyspace);

              case 15:
                // Set the prepared metadata
                info.preparing = false;
                info.queryId = response.id;
                info.meta = response.meta;

                this._client.metadata.setPreparedById(info);

                info.emit('prepared', null, info);
                return _context2.abrupt("return", info);

              case 23:
                _context2.prev = 23;
                _context2.t0 = _context2["catch"](5);
                triedHosts[host.address] = _context2.t0;

                if (!(!_context2.t0.isSocketError && !(_context2.t0 instanceof errors$b.OperationTimedOutError))) {
                  _context2.next = 28;
                  break;
                }

                throw _context2.t0;

              case 28:
                _context2.next = 1;
                break;

              case 30:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[5, 23]]);
      }));

      function _prepareWithQueryPlan(_x4, _x5, _x6, _x7) {
        return _prepareWithQueryPlan2.apply(this, arguments);
      }

      return _prepareWithQueryPlan;
    }()
    /**
     * Gets the next host from the query plan.
     * @param {Iterator} iterator
     * @param {ProfileManager} profileManager
     * @param {Object} [triedHosts]
     * @return {Host|null}
     */

  }, {
    key: "_prepareOnAllHosts",
    value:
    /**
     * Prepares the provided query on all hosts, except the host provided.
     * @param {Iterator} iterator
     * @param {String} query
     * @param {String} keyspace
     * @private
     */
    function _prepareOnAllHosts(iterator, query, keyspace) {
      var _this = this;

      var queries = [query];
      var h;
      var hosts = [];

      while ((h = PrepareHandler.getNextHost(iterator, this._client.profileManager)) !== null) {
        hosts.push(h);
      }

      return Promise.all(hosts.map(function (h) {
        return PrepareHandler._borrowAndPrepare(h, keyspace, queries)["catch"](function (err) {
          return _this.log('verbose', "Unexpected error while preparing query (".concat(query, ") on ").concat(h.address), err);
        });
      }));
    }
  }], [{
    key: "getPrepared",
    value: function () {
      var _getPrepared = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(client, loadBalancing, query, keyspace) {
        var info, instance;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                info = client.metadata.getPreparedInfo(keyspace, query);

                if (!info.queryId) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return", info);

              case 3:
                if (!info.preparing) {
                  _context3.next = 7;
                  break;
                }

                _context3.next = 6;
                return promiseUtils$9.fromEvent(info, 'prepared');

              case 6:
                return _context3.abrupt("return", _context3.sent);

              case 7:
                instance = new PrepareHandler(client, loadBalancing);
                _context3.next = 10;
                return instance._prepare(info, query, keyspace);

              case 10:
                return _context3.abrupt("return", _context3.sent);

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function getPrepared(_x8, _x9, _x10, _x11) {
        return _getPrepared.apply(this, arguments);
      }

      return getPrepared;
    }()
    /**
     * @param {Client} client
     * @param {LoadBalancingPolicy} loadBalancing
     * @param {Array} queries
     * @param {String} keyspace
     * @static
     */

  }, {
    key: "getPreparedMultiple",
    value: function () {
      var _getPreparedMultiple = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(client, loadBalancing, queries, keyspace) {
        var result, _iterator, _step, item, query, _yield$PrepareHandler, queryId, meta;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                result = [];
                _iterator = _createForOfIteratorHelper(queries);
                _context4.prev = 2;

                _iterator.s();

              case 4:
                if ((_step = _iterator.n()).done) {
                  _context4.next = 18;
                  break;
                }

                item = _step.value;
                query = void 0;

                if (item) {
                  query = typeof item === 'string' ? item : item.query;
                }

                if (!(typeof query !== 'string')) {
                  _context4.next = 10;
                  break;
                }

                throw new errors$b.ArgumentError('Query item should be a string');

              case 10:
                _context4.next = 12;
                return PrepareHandler.getPrepared(client, loadBalancing, query, keyspace);

              case 12:
                _yield$PrepareHandler = _context4.sent;
                queryId = _yield$PrepareHandler.queryId;
                meta = _yield$PrepareHandler.meta;
                result.push({
                  query: query,
                  params: utils$n.adaptNamedParamsPrepared(item.params, meta.columns),
                  queryId: queryId,
                  meta: meta
                });

              case 16:
                _context4.next = 4;
                break;

              case 18:
                _context4.next = 23;
                break;

              case 20:
                _context4.prev = 20;
                _context4.t0 = _context4["catch"](2);

                _iterator.e(_context4.t0);

              case 23:
                _context4.prev = 23;

                _iterator.f();

                return _context4.finish(23);

              case 26:
                return _context4.abrupt("return", result);

              case 27:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[2, 20, 23, 26]]);
      }));

      function getPreparedMultiple(_x12, _x13, _x14, _x15) {
        return _getPreparedMultiple.apply(this, arguments);
      }

      return getPreparedMultiple;
    }()
  }, {
    key: "getNextHost",
    value: function getNextHost(iterator, profileManager, triedHosts) {
      var host; // Get a host that is UP in a sync loop

      while (true) {
        var item = iterator.next();

        if (item.done) {
          return null;
        }

        host = item.value; // set the distance relative to the client first

        var distance = profileManager.getDistance(host);

        if (distance === types$g.distance.ignored) {
          //If its marked as ignore by the load balancing policy, move on.
          continue;
        }

        if (host.isUp()) {
          break;
        }

        if (triedHosts) {
          triedHosts[host.address] = 'Host considered as DOWN';
        }
      }

      return host;
    }
    /**
     * Prepares all queries on a single host.
     * @param {Host} host
     * @param {Array} allPrepared
     */

  }, {
    key: "prepareAllQueries",
    value: function () {
      var _prepareAllQueries = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(host, allPrepared) {
        var anyKeyspaceQueries, queriesByKeyspace, _iterator2, _step2, _step2$value, keyspace, queries;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                anyKeyspaceQueries = [];
                queriesByKeyspace = new Map();
                allPrepared.forEach(function (info) {
                  var arr;

                  if (info.keyspace) {
                    arr = queriesByKeyspace.get(info.keyspace);

                    if (!arr) {
                      arr = [];
                      queriesByKeyspace.set(info.keyspace, arr);
                    }
                  } else {
                    arr = anyKeyspaceQueries;
                  }

                  arr.push(info.query);
                });
                _iterator2 = _createForOfIteratorHelper(queriesByKeyspace);
                _context5.prev = 4;

                _iterator2.s();

              case 6:
                if ((_step2 = _iterator2.n()).done) {
                  _context5.next = 12;
                  break;
                }

                _step2$value = _slicedToArray(_step2.value, 2), keyspace = _step2$value[0], queries = _step2$value[1];
                _context5.next = 10;
                return PrepareHandler._borrowAndPrepare(host, keyspace, queries);

              case 10:
                _context5.next = 6;
                break;

              case 12:
                _context5.next = 17;
                break;

              case 14:
                _context5.prev = 14;
                _context5.t0 = _context5["catch"](4);

                _iterator2.e(_context5.t0);

              case 17:
                _context5.prev = 17;

                _iterator2.f();

                return _context5.finish(17);

              case 20:
                _context5.next = 22;
                return PrepareHandler._borrowAndPrepare(host, null, anyKeyspaceQueries);

              case 22:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[4, 14, 17, 20]]);
      }));

      function prepareAllQueries(_x16, _x17) {
        return _prepareAllQueries.apply(this, arguments);
      }

      return prepareAllQueries;
    }()
    /**
     * Borrows a connection from the host and prepares the queries provided.
     * @param {Host} host
     * @param {String} keyspace
     * @param {Array} queries
     * @returns {Promise<void>}
     * @private
     */

  }, {
    key: "_borrowAndPrepare",
    value: function () {
      var _borrowAndPrepare2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(host, keyspace, queries) {
        var connection, _iterator3, _step3, query;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(queries.length === 0)) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return");

              case 2:
                _context6.next = 4;
                return PrepareHandler._borrowWithKeyspace(host, keyspace);

              case 4:
                connection = _context6.sent;
                _iterator3 = _createForOfIteratorHelper(queries);
                _context6.prev = 6;

                _iterator3.s();

              case 8:
                if ((_step3 = _iterator3.n()).done) {
                  _context6.next = 14;
                  break;
                }

                query = _step3.value;
                _context6.next = 12;
                return connection.prepareOnceAsync(query, keyspace);

              case 12:
                _context6.next = 8;
                break;

              case 14:
                _context6.next = 19;
                break;

              case 16:
                _context6.prev = 16;
                _context6.t0 = _context6["catch"](6);

                _iterator3.e(_context6.t0);

              case 19:
                _context6.prev = 19;

                _iterator3.f();

                return _context6.finish(19);

              case 22:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, null, [[6, 16, 19, 22]]);
      }));

      function _borrowAndPrepare(_x18, _x19, _x20) {
        return _borrowAndPrepare2.apply(this, arguments);
      }

      return _borrowAndPrepare;
    }()
    /**
     * Borrows a connection and changes the active keyspace on the connection, if needed.
     * It does not perform any retry or error handling.
     * @param {Host!} host
     * @param {string} keyspace
     * @returns {Promise<Connection>}
     * @throws {errors.BusyConnectionError} When the connection is busy.
     * @throws {errors.ResponseError} For invalid keyspaces.
     * @throws {Error} For socket errors.
     * @private
     */

  }, {
    key: "_borrowWithKeyspace",
    value: function () {
      var _borrowWithKeyspace2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(host, keyspace) {
        var connection;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                connection = host.borrowConnection();

                if (!(keyspace && connection.keyspace !== keyspace)) {
                  _context7.next = 4;
                  break;
                }

                _context7.next = 4;
                return connection.changeKeyspace(keyspace);

              case 4:
                return _context7.abrupt("return", connection);

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function _borrowWithKeyspace(_x21, _x22) {
        return _borrowWithKeyspace2.apply(this, arguments);
      }

      return _borrowWithKeyspace;
    }()
  }]);

  return PrepareHandler;
}();

var prepareHandler = PrepareHandler$2;

var events$5 = require$$0__default$2["default"];
var utils$m = utils$V;
var types$f = types$u;
var HostConnectionPool = hostConnectionPool;
var PrepareHandler$1 = prepareHandler;
var promiseUtils$8 = promiseUtils$e;
var healthResponseCountInterval = 200;
/**
 * Represents a Cassandra node.
 * @extends EventEmitter
 */

var Host$1 = /*#__PURE__*/function (_events$EventEmitter) {
  _inherits(Host, _events$EventEmitter);

  var _super = _createSuper(Host);

  /**
   * Creates a new Host instance.
   */
  function Host(address, protocolVersion, options, metadata) {
    var _this;

    _classCallCheck(this, Host);

    _this = _super.call(this);
    /**
     * Gets ip address and port number of the node separated by `:`.
     * @type {String}
     */

    _this.address = address;
    _this.setDownAt = 0;
    _this.log = utils$m.log;
    /**
     * Gets the timestamp of the moment when the Host was marked as UP.
     * @type {Number|null}
     * @ignore
     * @internal
     */

    _this.isUpSince = null;
    Object.defineProperty(_assertThisInitialized(_this), 'options', {
      value: options,
      enumerable: false,
      writable: false
    });
    /**
     * The host pool.
     * @internal
     * @ignore
     * @type {HostConnectionPool}
     */

    Object.defineProperty(_assertThisInitialized(_this), 'pool', {
      value: new HostConnectionPool(_assertThisInitialized(_this), protocolVersion),
      enumerable: false
    });

    _this.pool.on('open', function (err) {
      return promiseUtils$8.toBackground(_this._onNewConnectionOpen(err));
    });

    _this.pool.on('remove', function () {
      return _this._checkPoolState();
    });
    /**
     * Gets string containing the Cassandra version.
     * @type {String}
     */


    _this.cassandraVersion = null;
    /**
     * Gets data center name of the node.
     * @type {String}
     */

    _this.datacenter = null;
    /**
     * Gets rack name of the node.
     * @type {String}
     */

    _this.rack = null;
    /**
     * Gets the tokens assigned to the node.
     * @type {Array}
     */

    _this.tokens = null;
    /**
     * Gets the id of the host.
     * <p>This identifier is used by the server for internal communication / gossip.</p>
     * @type {Uuid}
     */

    _this.hostId = null;
    /**
     * Gets string containing the DSE version or null if not set.
     * @type {String}
     */

    _this.dseVersion = null;
    /**
     * Gets the DSE Workloads the host is running.
     * <p>
     *   This is based on the "workload" or "workloads" columns in {@code system.local} and {@code system.peers}.
     * <p/>
     * <p>
     *   Workload labels may vary depending on the DSE version in use;e.g. DSE 5.1 may report two distinct workloads:
     *   <code>Search</code> and <code>Analytics</code>, while DSE 5.0 would report a single
     *   <code>SearchAnalytics</code> workload instead. The driver simply returns the workload labels as reported by
     *   DSE, without any form of pre-processing.
     * <p/>
     * <p>When the information is unavailable, this property returns an empty array.</p>
     * @type {Array<string>}
     */

    _this.workloads = utils$m.emptyArray; // the distance as last set using the load balancing policy

    _this._distance = types$f.distance.ignored;
    _this._healthResponseCounter = 0; // Make some of the private instance variables not enumerable to prevent from showing when inspecting

    Object.defineProperty(_assertThisInitialized(_this), '_metadata', {
      value: metadata,
      enumerable: false
    });
    Object.defineProperty(_assertThisInitialized(_this), '_healthResponseCountTimer', {
      value: null,
      enumerable: false,
      writable: true
    });
    _this.reconnectionSchedule = _this.options.policies.reconnection.newSchedule();
    _this.reconnectionDelay = 0;
    return _this;
  }
  /**
   * Marks this host as not available for query coordination, when the host was previously marked as UP, otherwise its
   * a no-op.
   * @internal
   * @ignore
   */


  _createClass(Host, [{
    key: "setDown",
    value: function setDown() {
      // Multiple events signaling that a host is failing could cause multiple calls to this method
      if (this.setDownAt !== 0) {
        // the host is already marked as Down
        return;
      }

      if (this.pool.isClosing()) {
        // the pool is being closed/shutdown, don't mind
        return;
      }

      this.setDownAt = Date.now();

      if (this.pool.coreConnectionsLength > 0) {
        // According to the distance, there should be connections open to it => issue a warning
        this.log('warning', "Host ".concat(this.address, " considered as DOWN. Reconnection delay ").concat(this.reconnectionDelay, "ms."));
      } else {
        this.log('info', "Host ".concat(this.address, " considered as DOWN."));
      }

      this.emit('down');

      this._checkPoolState();
    }
    /**
     * Marks this host as available for querying.
     * @param {Boolean} [clearReconnection]
     * @internal
     * @ignore
     */

  }, {
    key: "setUp",
    value: function setUp(clearReconnection) {
      if (!this.setDownAt) {
        //The host is already marked as UP
        return;
      }

      this.log('info', "Setting host ".concat(this.address, " as UP"));
      this.setDownAt = 0;
      this.isUpSince = Date.now(); //if it was unhealthy and now it is not, lets reset the reconnection schedule.

      this.reconnectionSchedule = this.options.policies.reconnection.newSchedule();

      if (clearReconnection) {
        this.pool.clearNewConnectionAttempt();
      }

      this.emit('up');
    }
    /**
     * Resets the reconnectionSchedule and tries to issue a reconnection immediately.
     * @internal
     * @ignore
     */

  }, {
    key: "checkIsUp",
    value: function checkIsUp() {
      if (this.isUp()) {
        return;
      }

      this.reconnectionSchedule = this.options.policies.reconnection.newSchedule();
      this.reconnectionDelay = 0;
      this.pool.attemptNewConnectionImmediate();
    }
    /**
     * @param {Boolean} [waitForPending] When true, it waits for in-flight operations to be finish before closing the
     * connections.
     * @returns {Promise<void>}
     * @internal
     * @ignore
     */

  }, {
    key: "shutdown",
    value: function shutdown(waitForPending) {
      if (this._healthResponseCountTimer) {
        clearInterval(this._healthResponseCountTimer);
      }

      if (waitForPending) {
        this.pool.drainAndShutdown(); // Gracefully draining and shutting down the pool is being done in the background

        return Promise.resolve();
      }

      return this.pool.shutdown();
    }
    /**
     * Determines if the node is UP now (seen as UP by the driver).
     * @returns {boolean}
     */

  }, {
    key: "isUp",
    value: function isUp() {
      return !this.setDownAt;
    }
    /**
     * Determines if the host can be considered as UP.
     * Deprecated: Use {@link Host#isUp()} instead.
     * @returns {boolean}
     */

  }, {
    key: "canBeConsideredAsUp",
    value: function canBeConsideredAsUp() {
      var self = this;

      function hasTimePassed() {
        return new Date().getTime() - self.setDownAt >= self.reconnectionDelay;
      }

      return !this.setDownAt || hasTimePassed();
    }
    /**
     * Sets the distance of the host relative to the client using the load balancing policy.
     * @param {Number} distance
     * @internal
     * @ignore
     */

  }, {
    key: "setDistance",
    value: function setDistance(distance) {
      var _this2 = this;

      var previousDistance = this._distance;
      this._distance = distance || types$f.distance.local;

      if (this.options.pooling.coreConnectionsPerHost) {
        this.pool.coreConnectionsLength = this.options.pooling.coreConnectionsPerHost[this._distance] || 0;
      } else {
        this.pool.coreConnectionsLength = 1;
      }

      if (this._distance === previousDistance) {
        return this._distance;
      }

      if (this._healthResponseCountTimer) {
        clearInterval(this._healthResponseCountTimer);
      }

      if (this._distance === types$f.distance.ignored) {
        // this host was local/remote and now must be ignored
        this.emit('ignore');
        this.pool.drainAndShutdown();
      } else {
        if (!this.isUp()) {
          this.checkIsUp();
        } // Reset the health check timer


        this._healthResponseCountTimer = setInterval(function () {
          _this2._healthResponseCounter = _this2.pool.getAndResetResponseCounter();
        }, healthResponseCountInterval);
      }

      return this._distance;
    }
    /**
     * Changes the protocol version of a given host
     * @param {Number} value
     * @internal
     * @ignore
     */

  }, {
    key: "setProtocolVersion",
    value: function setProtocolVersion(value) {
      this.pool.protocolVersion = value;
    }
    /**
     * Gets the least busy connection from the pool.
     * @param {Connection} [previousConnection] When provided, the pool should attempt to obtain a different connection.
     * @returns {Connection!}
     * @throws {Error}
     * @throws {BusyConnectionError}
     * @internal
     * @ignore
     */

  }, {
    key: "borrowConnection",
    value: function borrowConnection(previousConnection) {
      return this.pool.borrowConnection(previousConnection);
    }
    /**
     * Creates all the connection in the pool.
     * @param {string} keyspace
     * @internal
     * @ignore
     */

  }, {
    key: "warmupPool",
    value: function warmupPool(keyspace) {
      return this.pool.warmup(keyspace);
    }
    /**
     * Starts creating the pool in the background.
     * @internal
     * @ignore
     */

  }, {
    key: "initializePool",
    value: function initializePool() {
      this.pool.increaseSize();
    }
    /**
     * Gets any connection that is already opened or null if not found.
     * @returns {Connection}
     * @internal
     * @ignore
     */

  }, {
    key: "getActiveConnection",
    value: function getActiveConnection() {
      if (!this.isUp() || !this.pool.connections.length) {
        return null;
      }

      return this.pool.connections[0];
    }
    /**
     * Internal method to get the amount of responses dequeued in the last interval (between 200ms and 400ms) on all
     * connections to the host.
     * @returns {Number}
     * @internal
     * @ignore
     */

  }, {
    key: "getResponseCount",
    value: function getResponseCount() {
      // Last interval plus the current count
      return this._healthResponseCounter + this.pool.responseCounter;
    }
    /**
     * Checks the health of a connection in the pool
     * @param {Connection} connection
     * @internal
     * @ignore
     */

  }, {
    key: "checkHealth",
    value: function checkHealth(connection) {
      if (connection.timedOutOperations <= this.options.socketOptions.defunctReadTimeoutThreshold) {
        return;
      }

      this.removeFromPool(connection);
    }
    /**
     * @param {Connection} connection
     * @internal
     * @ignore
     */

  }, {
    key: "removeFromPool",
    value: function removeFromPool(connection) {
      this.pool.remove(connection);

      this._checkPoolState();
    }
    /**
     * Internal method that gets the amount of in-flight requests on all connections to the host.
     * @internal
     * @ignore
     */

  }, {
    key: "getInFlight",
    value: function getInFlight() {
      return this.pool.getInFlight();
    }
    /**
     * Validates that the internal state of the connection pool.
     * If the pool size is smaller than expected, schedule a new connection attempt.
     * If the amount of connections is 0 for not ignored hosts, the host must be down.
     * @private
     */

  }, {
    key: "_checkPoolState",
    value: function _checkPoolState() {
      if (this.pool.isClosing()) {
        return;
      }

      if (this.pool.connections.length < this.pool.coreConnectionsLength) {
        // the pool needs to grow / reconnect
        if (!this.pool.hasScheduledNewConnection()) {
          this.reconnectionDelay = this.reconnectionSchedule.next().value;
          this.pool.scheduleNewConnectionAttempt(this.reconnectionDelay);
        }
      }

      var shouldHaveConnections = this._distance !== types$f.distance.ignored && this.pool.coreConnectionsLength > 0;

      if (shouldHaveConnections && this.pool.connections.length === 0) {
        // Mark as DOWN, if its UP
        this.setDown();
      }
    }
    /**
     * Executed after an scheduled new connection attempt finished
     * @private
     */

  }, {
    key: "_onNewConnectionOpen",
    value: function () {
      var _onNewConnectionOpen2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(err) {
        var allPrepared;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!err) {
                  _context.next = 3;
                  break;
                }

                this._checkPoolState();

                return _context.abrupt("return");

              case 3:
                if (!(!this.isUp() && this.options.rePrepareOnUp)) {
                  _context.next = 14;
                  break;
                }

                this.log('info', "Re-preparing all queries on host ".concat(this.address, " before setting it as UP"));
                allPrepared = this._metadata.getAllPrepared();
                _context.prev = 6;
                _context.next = 9;
                return PrepareHandler$1.prepareAllQueries(this, allPrepared);

              case 9:
                _context.next = 14;
                break;

              case 11:
                _context.prev = 11;
                _context.t0 = _context["catch"](6);
                this.log('warning', "Failed re-preparing on host ".concat(this.address, ": ").concat(_context.t0), _context.t0);

              case 14:
                this.setUp();
                this.pool.increaseSize();

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[6, 11]]);
      }));

      function _onNewConnectionOpen(_x) {
        return _onNewConnectionOpen2.apply(this, arguments);
      }

      return _onNewConnectionOpen;
    }()
    /**
     * Returns an array containing the Cassandra Version as an Array of Numbers having the major version in the first
     * position.
     * @returns {Array.<Number>}
     */

  }, {
    key: "getCassandraVersion",
    value: function getCassandraVersion() {
      if (!this.cassandraVersion) {
        return utils$m.emptyArray;
      }

      return this.cassandraVersion.split('-')[0].split('.').map(function (x) {
        return parseInt(x, 10);
      });
    }
    /**
     * Gets the DSE version of the host as an Array, containing the major version in the first position.
     * In case the cluster is not a DSE cluster, it returns an empty Array.
     * @returns {Array}
     */

  }, {
    key: "getDseVersion",
    value: function getDseVersion() {
      if (!this.dseVersion) {
        return utils$m.emptyArray;
      }

      return this.dseVersion.split('-')[0].split('.').map(function (x) {
        return parseInt(x, 10);
      });
    }
  }]);

  return Host;
}(events$5.EventEmitter);
/**
 * Represents an associative-array of {@link Host hosts} that can be iterated.
 * It creates an internal copy when adding or removing, making it safe to iterate using the values()
 * method within async operations.
 * @extends events.EventEmitter
 * @constructor
 */


var HostMap$1 = /*#__PURE__*/function (_events$EventEmitter2) {
  _inherits(HostMap, _events$EventEmitter2);

  var _super2 = _createSuper(HostMap);

  function HostMap() {
    var _this3;

    _classCallCheck(this, HostMap);

    _this3 = _super2.call(this);
    _this3._items = new Map();
    _this3._values = null;
    Object.defineProperty(_assertThisInitialized(_this3), 'length', {
      get: function get() {
        return _this3.values().length;
      },
      enumerable: true
    });
    /**
     * Emitted when a host is added to the map
     * @event HostMap#add
     */

    /**
     * Emitted when a host is removed from the map
     * @event HostMap#remove
     */

    return _this3;
  }
  /**
   * Executes a provided function once per map element.
   * @param callback
   */


  _createClass(HostMap, [{
    key: "forEach",
    value: function forEach(callback) {
      var items = this._items;

      var _iterator = _createForOfIteratorHelper(items),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          callback(value, key);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Gets a {@link Host host} by key or undefined if not found.
     * @param {String} key
     * @returns {Host}
     */

  }, {
    key: "get",
    value: function get(key) {
      return this._items.get(key);
    }
    /**
     * Returns an array of host addresses.
     * @returns {Array.<String>}
     */

  }, {
    key: "keys",
    value: function keys() {
      return Array.from(this._items.keys());
    }
    /**
     * Removes an item from the map.
     * @param {String} key The key of the host
     * @fires HostMap#remove
     */

  }, {
    key: "remove",
    value: function remove(key) {
      var value = this._items.get(key);

      if (value === undefined) {
        return;
      } // Clear cache


      this._values = null; // Copy the values

      var copy = new Map(this._items);
      copy["delete"](key);
      this._items = copy;
      this.emit('remove', value);
    }
    /**
     * Removes multiple hosts from the map.
     * @param {Array.<String>} keys
     * @fires HostMap#remove
     */

  }, {
    key: "removeMultiple",
    value: function removeMultiple(keys) {
      var _this4 = this;

      // Clear value cache
      this._values = null; // Copy the values

      var copy = new Map(this._items);
      var removedHosts = [];

      var _iterator2 = _createForOfIteratorHelper(keys),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var key = _step2.value;
          var h = copy.get(key);

          if (!h) {
            continue;
          }

          removedHosts.push(h);
          copy["delete"](key);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this._items = copy;
      removedHosts.forEach(function (h) {
        return _this4.emit('remove', h);
      });
    }
    /**
     * Adds a new item to the map.
     * @param {String} key The key of the host
     * @param {Host} value The host to be added
     * @fires HostMap#remove
     * @fires HostMap#add
     */

  }, {
    key: "set",
    value: function set(key, value) {
      // Clear values cache
      this._values = null;

      var originalValue = this._items.get(key);

      if (originalValue) {
        //The internal structure does not change
        this._items.set(key, value); //emit a remove followed by a add


        this.emit('remove', originalValue);
        this.emit('add', value);
        return;
      } // Copy the values


      var copy = new Map(this._items);
      copy.set(key, value);
      this._items = copy;
      this.emit('add', value);
      return value;
    }
    /**
     * Returns a shallow copy of a portion of the items into a new array object.
     * Backward-compatibility.
     * @param {Number} [begin]
     * @param {Number} [end]
     * @returns {Array}
     * @ignore
     */

  }, {
    key: "slice",
    value: function slice(begin, end) {
      if (!begin && !end) {
        // Avoid making a copy of the copy
        return this.values();
      }

      return this.values().slice(begin || 0, end);
    }
    /**
     * Deprecated: Use set() instead.
     * @ignore
     * @deprecated
     */

  }, {
    key: "push",
    value: function push(k, v) {
      this.set(k, v);
    }
    /**
     * Returns a shallow copy of the values of the map.
     * @returns {Array.<Host>}
     */

  }, {
    key: "values",
    value: function values() {
      if (!this._values) {
        // Cache the values
        this._values = Object.freeze(Array.from(this._items.values()));
      }

      return this._values;
    }
    /**
     * Removes all items from the map.
     * @returns {Array.<Host>} The previous items
     */

  }, {
    key: "clear",
    value: function clear() {
      var _this5 = this;

      var previousItems = this.values(); // Clear cache

      this._values = null; // Clear items

      this._items = new Map(); // Emit events

      previousItems.forEach(function (h) {
        return _this5.emit('remove', h);
      });
      return previousItems;
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return this._items;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      // Node.js 10 and below don't support Object.fromEntries()
      if (Object.fromEntries) {
        return Object.fromEntries(this._items);
      }

      var obj = {};

      var _iterator3 = _createForOfIteratorHelper(this._items),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = _slicedToArray(_step3.value, 2),
              key = _step3$value[0],
              value = _step3$value[1];

          obj[key] = value;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return obj;
    }
  }]);

  return HostMap;
}(events$5.EventEmitter);

var host = {
  Host: Host$1,
  HostMap: HostMap$1
};

var tokenizer = {};

var types$e = types$u;
var token = token$2;
var utils$l = utils$V;
var MutableLong = mutableLong;
var Integer = types$e.Integer; // Murmur3 constants
//-0x783C846EEEBDAC2B

var mconst1 = new MutableLong(0x53d5, 0x1142, 0x7b91, 0x87c3); //0x4cf5ad432745937f

var mconst2 = new MutableLong(0x937f, 0x2745, 0xad43, 0x4cf5);
var mlongFive = MutableLong.fromNumber(5); //0xff51afd7ed558ccd

var mconst3 = new MutableLong(0x8ccd, 0xed55, 0xafd7, 0xff51); //0xc4ceb9fe1a85ec53

var mconst4 = new MutableLong(0xec53, 0x1a85, 0xb9fe, 0xc4ce);
var mconst5 = MutableLong.fromNumber(0x52dce729);
var mconst6 = MutableLong.fromNumber(0x38495ab5);
/**
 * Represents a set of methods that are able to generate and parse tokens for the C* partitioner.
 * @abstract
 */

var Tokenizer = /*#__PURE__*/function () {
  function Tokenizer() {
    _classCallCheck(this, Tokenizer);
  }
  /**
   * Creates a token based on the Buffer value provided
   * @abstract
   * @param {Buffer|Array} value
   * @returns {Token} Computed token
   */


  _createClass(Tokenizer, [{
    key: "hash",
    value: function hash(value) {
      throw new Error('You must implement a hash function for the tokenizer');
    }
    /**
     * Parses a token string and returns a representation of the token
     * @abstract
     * @param {String} value
     */

  }, {
    key: "parse",
    value: function parse(value) {
      throw new Error('You must implement a parse function for the tokenizer');
    }
  }, {
    key: "minToken",
    value: function minToken() {
      throw new Error('You must implement a minToken function for the tokenizer');
    }
    /**
     * Splits the range specified by start and end into numberOfSplits equal parts.
     * @param {Token} start Starting token
     * @param {Token} end  End token
     * @param {Number} numberOfSplits Number of splits to make.
     */

  }, {
    key: "split",
    value: function split(start, end, numberOfSplits) {
      throw new Error('You must implement a split function for the tokenizer');
    }
    /**
     * Common implementation for splitting token ranges when start is in
     * a shared Integer format.
     *
     * @param {Integer} start Starting token
     * @param {Integer} range How large the range of the split is
     * @param {Integer} ringEnd The end point of the ring so we know where to wrap
     * @param {Integer} ringLength The total size of the ring
     * @param {Number} numberOfSplits The number of splits to make
     * @returns {Array<Integer>} The evenly-split points on the range
     */

  }, {
    key: "splitBase",
    value: function splitBase(start, range, ringEnd, ringLength, numberOfSplits) {
      var numberOfSplitsInt = Integer.fromInt(numberOfSplits);
      var divider = range.divide(numberOfSplitsInt);
      var remainder = range.modulo(numberOfSplitsInt);
      var results = [];
      var current = start;
      var dividerPlusOne = divider.add(Integer.ONE);

      for (var i = 1; i < numberOfSplits; i++) {
        if (remainder.greaterThan(Integer.ZERO)) {
          current = current.add(dividerPlusOne);
        } else {
          current = current.add(divider);
        }

        if (ringLength && current.greaterThan(ringEnd)) {
          current = current.subtract(ringLength);
        }

        results.push(current);
        remainder = remainder.subtract(Integer.ONE);
      }

      return results;
    }
    /**
     * Return internal string based representation of a Token.
     * @param {Token} token 
     */

  }, {
    key: "stringify",
    value: function stringify(token) {
      return token.getValue().toString();
    }
  }]);

  return Tokenizer;
}();
/**
 * Uniformly distributes data across the cluster based on Cassandra flavored Murmur3 hashed values.
 */


var Murmur3Tokenizer = /*#__PURE__*/function (_Tokenizer) {
  _inherits(Murmur3Tokenizer, _Tokenizer);

  var _super = _createSuper(Murmur3Tokenizer);

  function Murmur3Tokenizer() {
    _classCallCheck(this, Murmur3Tokenizer);

    return _super.call(this);
  }
  /**
   * @param {Buffer} value
   * @return {Murmur3Token}
   */


  _createClass(Murmur3Tokenizer, [{
    key: "hash",
    value: function hash(value) {
      // This is an adapted version of the MurmurHash.hash3_x64_128 from Cassandra used
      // for M3P. Compared to that methods, there's a few inlining of arguments and we
      // only return the first 64-bits of the result since that's all M3 partitioner uses.
      var data = value;
      var offset = 0;
      var length = data.length;
      var nblocks = length >> 4; // Process as 128-bit blocks.

      var h1 = new MutableLong();
      var h2 = new MutableLong();
      var k1 = new MutableLong();
      var k2 = new MutableLong();

      for (var i = 0; i < nblocks; i++) {
        k1 = this.getBlock(data, offset, i * 2);
        k2 = this.getBlock(data, offset, i * 2 + 1);
        k1.multiply(mconst1);
        this.rotl64(k1, 31);
        k1.multiply(mconst2);
        h1.xor(k1);
        this.rotl64(h1, 27);
        h1.add(h2);
        h1.multiply(mlongFive).add(mconst5);
        k2.multiply(mconst2);
        this.rotl64(k2, 33);
        k2.multiply(mconst1);
        h2.xor(k2);
        this.rotl64(h2, 31);
        h2.add(h1);
        h2.multiply(mlongFive).add(mconst6);
      } //----------
      // tail
      // Advance offset to the unprocessed tail of the data.


      offset += nblocks * 16;
      k1 = new MutableLong();
      k2 = new MutableLong();
      /* eslint-disable no-fallthrough */

      switch (length & 15) {
        case 15:
          k2.xor(fromSignedByte(data[offset + 14]).shiftLeft(48));

        case 14:
          k2.xor(fromSignedByte(data[offset + 13]).shiftLeft(40));

        case 13:
          k2.xor(fromSignedByte(data[offset + 12]).shiftLeft(32));

        case 12:
          k2.xor(fromSignedByte(data[offset + 11]).shiftLeft(24));

        case 11:
          k2.xor(fromSignedByte(data[offset + 10]).shiftLeft(16));

        case 10:
          k2.xor(fromSignedByte(data[offset + 9]).shiftLeft(8));

        case 9:
          k2.xor(fromSignedByte(data[offset + 8]));
          k2.multiply(mconst2);
          this.rotl64(k2, 33);
          k2.multiply(mconst1);
          h2.xor(k2);

        case 8:
          k1.xor(fromSignedByte(data[offset + 7]).shiftLeft(56));

        case 7:
          k1.xor(fromSignedByte(data[offset + 6]).shiftLeft(48));

        case 6:
          k1.xor(fromSignedByte(data[offset + 5]).shiftLeft(40));

        case 5:
          k1.xor(fromSignedByte(data[offset + 4]).shiftLeft(32));

        case 4:
          k1.xor(fromSignedByte(data[offset + 3]).shiftLeft(24));

        case 3:
          k1.xor(fromSignedByte(data[offset + 2]).shiftLeft(16));

        case 2:
          k1.xor(fromSignedByte(data[offset + 1]).shiftLeft(8));

        case 1:
          k1.xor(fromSignedByte(data[offset]));
          k1.multiply(mconst1);
          this.rotl64(k1, 31);
          k1.multiply(mconst2);
          h1.xor(k1);
      }
      /* eslint-enable no-fallthrough */


      h1.xor(MutableLong.fromNumber(length));
      h2.xor(MutableLong.fromNumber(length));
      h1.add(h2);
      h2.add(h1);
      this.fmix(h1);
      this.fmix(h2);
      h1.add(h2);
      return new token.Murmur3Token(h1);
    }
    /**
     *
     * @param {Array<Number>} key
     * @param {Number} offset
     * @param {Number} index
     * @return {MutableLong}
     */

  }, {
    key: "getBlock",
    value: function getBlock(key, offset, index) {
      var i8 = index << 3;
      var blockOffset = offset + i8;
      return new MutableLong(key[blockOffset] | key[blockOffset + 1] << 8, key[blockOffset + 2] | key[blockOffset + 3] << 8, key[blockOffset + 4] | key[blockOffset + 5] << 8, key[blockOffset + 6] | key[blockOffset + 7] << 8);
    }
    /**
     * @param {MutableLong} v
     * @param {Number} n
     */

  }, {
    key: "rotl64",
    value: function rotl64(v, n) {
      var left = v.clone().shiftLeft(n);
      v.shiftRightUnsigned(64 - n).or(left);
    }
    /** @param {MutableLong} k */

  }, {
    key: "fmix",
    value: function fmix(k) {
      k.xor(new MutableLong(k.getUint16(2) >>> 1 | k.getUint16(3) << 15 & 0xffff, k.getUint16(3) >>> 1, 0, 0));
      k.multiply(mconst3);
      var other = new MutableLong(k.getUint16(2) >>> 1 | k.getUint16(3) << 15 & 0xffff, k.getUint16(3) >>> 1, 0, 0);
      k.xor(other);
      k.multiply(mconst4);
      k.xor(new MutableLong(k.getUint16(2) >>> 1 | k.getUint16(3) << 15 & 0xffff, k.getUint16(3) >>> 1, 0, 0));
    }
    /**
     * Parses a int64 decimal string representation into a MutableLong.
     * @param {String} value
     * @returns {Murmur3Token}
     */

  }, {
    key: "parse",
    value: function parse(value) {
      return new token.Murmur3Token(MutableLong.fromString(value));
    }
  }, {
    key: "minToken",
    value: function minToken() {
      if (!this._minToken) {
        // minimum long value.
        this._minToken = this.parse('-9223372036854775808');
      }

      return this._minToken;
    }
  }, {
    key: "maxToken",
    value: function maxToken() {
      if (!this._maxToken) {
        this._maxToken = this.parse('9223372036854775807');
      }

      return this._maxToken;
    }
  }, {
    key: "maxValue",
    value: function maxValue() {
      if (!this._maxValue) {
        this._maxValue = Integer.fromString('9223372036854775807');
      }

      return this._maxValue;
    }
  }, {
    key: "minValue",
    value: function minValue() {
      if (!this._minValue) {
        this._minValue = Integer.fromString('-9223372036854775808');
      }

      return this._minValue;
    }
  }, {
    key: "ringLength",
    value: function ringLength() {
      if (!this._ringLength) {
        this._ringLength = this.maxValue().subtract(this.minValue());
      }

      return this._ringLength;
    }
  }, {
    key: "split",
    value: function split(start, end, numberOfSplits) {
      var _this = this;

      // ]min, min] means the whole ring.
      if (start.equals(end) && start.equals(this.minToken())) {
        end = this.maxToken();
      }

      var startVal = Integer.fromString(start.getValue().toString());
      var endVal = Integer.fromString(end.getValue().toString());
      var range = endVal.subtract(startVal);

      if (range.isNegative()) {
        range = range.add(this.ringLength());
      }

      var values = this.splitBase(startVal, range, this.maxValue(), this.ringLength(), numberOfSplits);
      return values.map(function (v) {
        return _this.parse(v.toString());
      });
    }
  }, {
    key: "stringify",
    value: function stringify(token) {
      // Get the underlying MutableLong
      var value = token.getValue(); // We need a way to uniquely represent a token, it doesn't have to be the decimal string representation
      // Using the uint16 avoids divisions and other expensive operations on the longs

      return value.getUint16(0) + ',' + value.getUint16(1) + ',' + value.getUint16(2) + ',' + value.getUint16(3);
    }
  }]);

  return Murmur3Tokenizer;
}(Tokenizer);
/**
 * Uniformly distributes data across the cluster based on MD5 hash values.
 */


var RandomTokenizer = /*#__PURE__*/function (_Tokenizer2) {
  _inherits(RandomTokenizer, _Tokenizer2);

  var _super2 = _createSuper(RandomTokenizer);

  function RandomTokenizer() {
    var _this2;

    _classCallCheck(this, RandomTokenizer);

    _this2 = _super2.call(this); // eslint-disable-next-line

    _this2._crypto = require$$0__default$4["default"];
    return _this2;
  }
  /**
   * @param {Buffer|Array} value
   * @returns {RandomToken}
   */


  _createClass(RandomTokenizer, [{
    key: "hash",
    value: function hash(value) {
      if (Array.isArray(value)) {
        value = utils$l.allocBufferFromArray(value);
      }

      var hashedValue = this._crypto.createHash('md5').update(value).digest();

      return new token.RandomToken(Integer.fromBuffer(hashedValue).abs());
    }
    /**
     * @returns {Token}
     */

  }, {
    key: "parse",
    value: function parse(value) {
      return new token.RandomToken(Integer.fromString(value));
    }
  }, {
    key: "minToken",
    value: function minToken() {
      if (!this._minToken) {
        this._minToken = this.parse('-1');
      }

      return this._minToken;
    }
  }, {
    key: "maxValue",
    value: function maxValue() {
      if (!this._maxValue) {
        this._maxValue = Integer.fromNumber(Math.pow(2, 127));
      }

      return this._maxValue;
    }
  }, {
    key: "maxToken",
    value: function maxToken() {
      if (!this._maxToken) {
        this._maxToken = new token.RandomToken(this.maxValue());
      }

      return this._maxToken;
    }
  }, {
    key: "ringLength",
    value: function ringLength() {
      if (!this._ringLength) {
        this._ringLength = this.maxValue().add(Integer.ONE);
      }

      return this._ringLength;
    }
  }, {
    key: "split",
    value: function split(start, end, numberOfSplits) {
      // ]min, min] means the whole ring.
      if (start.equals(end) && start.equals(this.minToken())) {
        end = this.maxToken();
      }

      var startVal = start.getValue();
      var endVal = end.getValue();
      var range = endVal.subtract(startVal);

      if (range.lessThan(Integer.ZERO)) {
        range = range.add(this.ringLength());
      }

      var values = this.splitBase(startVal, range, this.maxValue(), this.ringLength(), numberOfSplits);
      return values.map(function (v) {
        return new token.RandomToken(v);
      });
    }
  }]);

  return RandomTokenizer;
}(Tokenizer);

var ByteOrderedTokenizer = /*#__PURE__*/function (_Tokenizer3) {
  _inherits(ByteOrderedTokenizer, _Tokenizer3);

  var _super3 = _createSuper(ByteOrderedTokenizer);

  function ByteOrderedTokenizer() {
    _classCallCheck(this, ByteOrderedTokenizer);

    return _super3.call(this);
  }
  /**
   * @param {Buffer} value
   * @returns {ByteOrderedToken}
   */


  _createClass(ByteOrderedTokenizer, [{
    key: "hash",
    value: function hash(value) {
      // strip any trailing zeros as tokens with trailing zeros are equivalent
      // to those who don't have them.
      if (Array.isArray(value)) {
        value = utils$l.allocBufferFromArray(value);
      }

      var zeroIndex = value.length;

      for (var i = value.length - 1; i > 0; i--) {
        if (value[i] === 0) {
          zeroIndex = i;
        } else {
          break;
        }
      }

      return new token.ByteOrderedToken(value.slice(0, zeroIndex));
    }
  }, {
    key: "stringify",
    value: function stringify(token) {
      return token.getValue().toString('hex');
    }
  }, {
    key: "parse",
    value: function parse(value) {
      return this.hash(utils$l.allocBufferFromString(value, 'hex'));
    }
  }, {
    key: "minToken",
    value: function minToken() {
      if (!this._minToken) {
        this._minToken = this.hash([]);
      }

      return this._minToken;
    }
  }, {
    key: "_toNumber",
    value: function _toNumber(buffer, significantBytes) {
      // Convert a token's byte array to a number in order to perform computations.
      // This depends on the number of significant bytes that is used to normalize all tokens
      // to the same size.  For example if the token is 0x01 but significant bytes is 2, the
      // result is 0x0100.
      var target = buffer;

      if (buffer.length !== significantBytes) {
        target = Buffer.alloc(significantBytes);
        buffer.copy(target);
      } // similar to Integer.fromBuffer except we force the sign to 0.


      var bits = new Array(Math.ceil(target.length / 4));

      for (var i = 0; i < bits.length; i++) {
        var offset = target.length - (i + 1) * 4;
        var value = void 0;

        if (offset < 0) {
          //The buffer length is not multiple of 4
          offset = offset + 4;
          value = 0;

          for (var j = 0; j < offset; j++) {
            var _byte = target[j];
            value = value | _byte << (offset - j - 1) * 8;
          }
        } else {
          value = target.readInt32BE(offset);
        }

        bits[i] = value;
      }

      return new Integer(bits, 0);
    }
  }, {
    key: "_toBuffer",
    value: function _toBuffer(number, significantBytes) {
      // Convert numeric representation back to a buffer.
      var buffer = Integer.toBuffer(number);

      if (buffer.length === significantBytes) {
        return buffer;
      } // if first byte is a sign byte, skip it.


      var start, length;

      if (buffer[0] === 0) {
        start = 1;
        length = buffer.length - 1;
      } else {
        start = 0;
        length = buffer.length;
      }

      var target = Buffer.alloc(significantBytes);
      buffer.copy(target, significantBytes - length, start, length + start);
      return target;
    }
  }, {
    key: "split",
    value: function split(start, end, numberOfSplits) {
      var _this3 = this;

      var tokenOrder = start.compare(end);

      if (tokenOrder === 0 && start.equals(this.minToken())) {
        throw new Error("Cannot split whole ring with ordered partitioner");
      }

      var startVal, endVal, range, ringLength, ringEnd;
      var intNumberOfSplits = Integer.fromNumber(numberOfSplits); // Since tokens are compared lexicographically, convert to numbers using the
      // largest length (i.e. given 0x0A and 0x0BCD, switch to 0x0A00 and 0x0BCD)

      var significantBytes = Math.max(start.getValue().length, end.getValue().length);

      if (tokenOrder < 0) {
        var addedBytes = 0;

        while (true) {
          startVal = this._toNumber(start.getValue(), significantBytes);
          endVal = this._toNumber(end.getValue(), significantBytes);
          range = endVal.subtract(startVal);

          if (addedBytes === 4 || range.compare(intNumberOfSplits) >= 0) {
            break;
          }

          significantBytes += 1;
          addedBytes += 1;
        }
      } else {
        var _addedBytes = 0;

        while (true) {
          startVal = this._toNumber(start.getValue(), significantBytes);
          endVal = this._toNumber(end.getValue(), significantBytes);
          ringLength = Integer.fromNumber(Math.pow(2, significantBytes * 8));
          ringEnd = ringLength.subtract(Integer.ONE);
          range = endVal.subtract(startVal).add(ringLength);

          if (_addedBytes === 4 || range.compare(intNumberOfSplits) >= 0) {
            break;
          }

          significantBytes += 1;
          _addedBytes += 1;
        }
      }

      var values = this.splitBase(startVal, range, ringEnd, ringLength, numberOfSplits);
      return values.map(function (v) {
        return new token.ByteOrderedToken(_this3._toBuffer(v, significantBytes));
      });
    }
  }]);

  return ByteOrderedTokenizer;
}(Tokenizer);
/**
 * @param {Number} value
 * @return {MutableLong}
 */


function fromSignedByte(value) {
  if (value < 128) {
    return new MutableLong(value, 0, 0, 0);
  }

  return new MutableLong(value - 256 & 0xffff, 0xffff, 0xffff, 0xffff);
}

tokenizer.Murmur3Tokenizer = Murmur3Tokenizer;
tokenizer.RandomTokenizer = RandomTokenizer;
tokenizer.ByteOrderedTokenizer = ByteOrderedTokenizer;

var schemaParser = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$e = require$$0__default$1["default"];
var events$4 = require$$0__default$2["default"];
/**
 * Creates a new instance of DataCollection
 * @param {String} name Name of the data object.
 * @classdesc Describes a table or a view
 * @alias module:metadata~DataCollection
 * @constructor
 * @abstract
 */

function DataCollection$2(name) {
  events$4.EventEmitter.call(this);
  this.setMaxListeners(0); //private

  Object.defineProperty(this, 'loading', {
    value: false,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(this, 'loaded', {
    value: false,
    enumerable: false,
    writable: true
  });
  /**
   * Name of the object
   * @type {String}
   */

  this.name = name;
  /**
   * False-positive probability for SSTable Bloom filters.
   * @type {number}
   */

  this.bloomFilterFalsePositiveChance = 0;
  /**
   * Level of caching: all, keys_only, rows_only, none
   * @type {String}
   */

  this.caching = null;
  /**
   * A human readable comment describing the table.
   * @type {String}
   */

  this.comment = null;
  /**
   * Specifies the time to wait before garbage collecting tombstones (deletion markers)
   * @type {number}
   */

  this.gcGraceSeconds = 0;
  /**
   * Compaction strategy class used for the table.
   * @type {String}
   */

  this.compactionClass = null;
  /**
   * Associative-array containing the compaction options keys and values.
   * @type {Object}
   */

  this.compactionOptions = null;
  /**
   * Associative-array containing the compression options.
   * @type {Object}
   */

  this.compression = null;
  /**
   * Specifies the probability of read repairs being invoked over all replicas in the current data center.
   * @type {number}
   */

  this.localReadRepairChance = 0;
  /**
   * Specifies the probability with which read repairs should be invoked on non-quorum reads. The value must be
   * between 0 and 1.
   * @type {number}
   */

  this.readRepairChance = 0;
  /**
   * An associative Array containing extra metadata for the table.
   * <p>
   * For Apache Cassandra versions prior to 3.0.0, this method always returns <code>null</code>.
   * </p>
   * @type {Object}
   */

  this.extensions = null;
  /**
   * When compression is enabled, this option defines the probability
   * with which checksums for compressed blocks are checked during reads.
   * The default value for this options is 1.0 (always check).
   * <p>
   *   For Apache Cassandra versions prior to 3.0.0, this method always returns <code>null</code>.
   * </p>
   * @type {Number|null}
   */

  this.crcCheckChance = null;
  /**
   * Whether the populate I/O cache on flush is set on this table.
   * @type {Boolean}
   */

  this.populateCacheOnFlush = false;
  /**
   * Returns the default TTL for this table.
   * @type {Number}
   */

  this.defaultTtl = 0;
  /**
   * * Returns the speculative retry option for this table.
   * @type {String}
   */

  this.speculativeRetry = 'NONE';
  /**
   * Returns the minimum index interval option for this table.
   * <p>
   *   Note: this option is available in Apache Cassandra 2.1 and above, and will return <code>null</code> for
   *   earlier versions.
   * </p>
   * @type {Number|null}
   */

  this.minIndexInterval = 128;
  /**
   * Returns the maximum index interval option for this table.
   * <p>
   * Note: this option is available in Apache Cassandra 2.1 and above, and will return <code>null</code> for
   * earlier versions.
   * </p>
   * @type {Number|null}
   */

  this.maxIndexInterval = 2048;
  /**
   * Array describing the table columns.
   * @type {Array}
   */

  this.columns = null;
  /**
   * An associative Array of columns by name.
   * @type {Object}
   */

  this.columnsByName = null;
  /**
   * Array describing the columns that are part of the partition key.
   * @type {Array}
   */

  this.partitionKeys = [];
  /**
   * Array describing the columns that form the clustering key.
   * @type {Array}
   */

  this.clusteringKeys = [];
  /**
   * Array describing the clustering order of the columns in the same order as the clusteringKeys.
   * @type {Array}
   */

  this.clusteringOrder = [];
  /**
   * An associative Array containing nodesync options for this table.
   * <p>
   * For DSE versions prior to 6.0.0, this method always returns {@code null}.  If nodesync
   * was not explicitly configured for this table this method will also return {@code null}.
   * </p>
   * @type {Object}
   */

  this.nodesync = null;
}

util$e.inherits(DataCollection$2, events$4.EventEmitter);
var dataCollection = DataCollection$2;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$d = require$$0__default$1["default"];
var DataCollection$1 = dataCollection;
/**
 * Creates a new instance of TableMetadata
 * @classdesc Describes a table
 * @param {String} name Name of the Table
 * @augments {module:metadata~DataCollection}
 * @alias module:metadata~TableMetadata
 * @constructor
 */

function TableMetadata$1(name) {
  DataCollection$1.call(this, name);
  /**
   * Applies only to counter tables.
   * When set to true, replicates writes to all affected replicas regardless of the consistency level specified by
   * the client for a write request. For counter tables, this should always be set to true.
   * @type {Boolean}
   */

  this.replicateOnWrite = true;
  /**
   * Returns the memtable flush period (in milliseconds) option for this table.
   * @type {Number}
   */

  this.memtableFlushPeriod = 0;
  /**
   * Returns the index interval option for this table.
   * <p>
   * Note: this option is only available in Apache Cassandra 2.0. It is deprecated in Apache Cassandra 2.1 and
   * above, and will therefore return <code>null</code> for 2.1 nodes.
   * </p>
   * @type {Number|null}
   */

  this.indexInterval = null;
  /**
   * Determines  whether the table uses the COMPACT STORAGE option.
   * @type {Boolean}
   */

  this.isCompact = false;
  /**
   *
   * @type {Array.<Index>}
   */

  this.indexes = null;
  /**
   * Determines whether the Change Data Capture (CDC) flag is set for the table.
   * @type {Boolean|null}
   */

  this.cdc = null;
  /**
   * Determines whether the table is a virtual table or not.
   * @type {Boolean}
   */

  this.virtual = false;
}

util$d.inherits(TableMetadata$1, DataCollection$1);
var tableMetadata = TableMetadata$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Creates a new Aggregate.
 * @classdesc Describes a CQL aggregate.
 * @alias module:metadata~Aggregate
 * @constructor
 */


function Aggregate$1() {
  /**
   * Name of the aggregate.
   * @type {String}
   */
  this.name = null;
  /**
   * Name of the keyspace where the aggregate is declared.
   */

  this.keyspaceName = null;
  /**
   * Signature of the aggregate.
   * @type {Array.<String>}
   */

  this.signature = null;
  /**
   * List of the CQL aggregate argument types.
   * @type {Array.<{code, info}>}
   */

  this.argumentTypes = null;
  /**
   * State Function.
   * @type {String}
   */

  this.stateFunction = null;
  /**
   * State Type.
   * @type {{code, info}}
   */

  this.stateType = null;
  /**
   * Final Function.
   * @type {String}
   */

  this.finalFunction = null;
  this.initConditionRaw = null;
  /**
   * Initial state value of this aggregate.
   * @type {String}
   */

  this.initCondition = null;
  /**
   * Type of the return value.
   * @type {{code: number, info: (Object|Array|null)}}
   */

  this.returnType = null;
  /**
   * Indicates whether or not this aggregate is deterministic.  This means that
   * given a particular input, the aggregate will always produce the same output.
   * @type {Boolean}
   */

  this.deterministic = null;
}

var aggregate = Aggregate$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Creates a new SchemaFunction.
 * @classdesc Describes a CQL function.
 * @alias module:metadata~SchemaFunction
 * @constructor
 */


function SchemaFunction$1() {
  /**
   * Name of the cql function.
   * @type {String}
   */
  this.name = null;
  /**
   * Name of the keyspace where the cql function is declared.
   */

  this.keyspaceName = null;
  /**
   * Signature of the function.
   * @type {Array.<String>}
   */

  this.signature = null;
  /**
   * List of the function argument names.
   * @type {Array.<String>}
   */

  this.argumentNames = null;
  /**
   * List of the function argument types.
   * @type {Array.<{code, info}>}
   */

  this.argumentTypes = null;
  /**
   * Body of the function.
   * @type {String}
   */

  this.body = null;
  /**
   * Determines if the function is called when the input is null.
   * @type {Boolean}
   */

  this.calledOnNullInput = null;
  /**
   * Name of the programming language, for example: java, javascript, ...
   * @type {String}
   */

  this.language = null;
  /**
   * Type of the return value.
   * @type {{code: number, info: (Object|Array|null)}}
   */

  this.returnType = null;
  /**
   * Indicates whether or not this function is deterministic.  This means that
   * given a particular input, the function will always produce the same output.
   * @type {Boolean}
   */

  this.deterministic = null;
  /**
   * Indicates whether or not this function is monotonic on all of its
   * arguments.  This means that it is either entirely non-increasing or
   * non-decreasing.  Even if the function is not monotonic on all of its
   * arguments, it's possible to specify that it is monotonic on one of
   * its arguments, meaning that partial applications of the function over
   * that argument will be monotonic.
   * 
   * Monotonicity is required to use the function in a GROUP BY clause.
   * @type {Boolean}
   */

  this.monotonic = null;
  /**
   * The argument names that the function is monotonic on.
   * 
   * If {@link monotonic} is true, this will return all argument names.
   * Otherwise, this will return either one argument or an empty array.
   * @type {Array.<String>}
   */

  this.monotonicOn = null;
}

var schemaFunction = SchemaFunction$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$c = require$$0__default$1["default"];
var utils$k = utils$V;
var types$d = types$u;
/** @private */

var kind = {
  custom: 0,
  keys: 1,
  composites: 2
};
/**
 * Creates a new Index instance.
 * @classdesc Describes a CQL index.
 * @param {String} name
 * @param {String} target
 * @param {Number|String} kind
 * @param {Object} options
 * @alias module:metadata~Index
 * @constructor
 */

function Index$1(name, target, kind, options) {
  /**
   * Name of the index.
   * @type {String}
   */
  this.name = name;
  /**
   * Target of the index.
   * @type {String}
   */

  this.target = target;
  /**
   * A numeric value representing index kind (0: custom, 1: keys, 2: composite);
   * @type {Number}
   */

  this.kind = typeof kind === 'string' ? getKindByName(kind) : kind;
  /**
   * An associative array containing the index options
   * @type {Object}
   */

  this.options = options;
}
/**
 * Determines if the index is of composites kind
 * @returns {Boolean}
 */


Index$1.prototype.isCompositesKind = function () {
  return this.kind === kind.composites;
};
/**
 * Determines if the index is of keys kind
 * @returns {Boolean}
 */


Index$1.prototype.isKeysKind = function () {
  return this.kind === kind.keys;
};
/**
 * Determines if the index is of custom kind
 * @returns {Boolean}
 */


Index$1.prototype.isCustomKind = function () {
  return this.kind === kind.custom;
};
/**
 * Parses Index information from rows in the 'system_schema.indexes' table
 * @deprecated It will be removed in the next major version.
 * @param {Array.<Row>} indexRows
 * @returns {Array.<Index>}
 */


Index$1.fromRows = function (indexRows) {
  if (!indexRows || indexRows.length === 0) {
    return utils$k.emptyArray;
  }

  return indexRows.map(function (row) {
    var options = row['options'];
    return new Index$1(row['index_name'], options['target'], getKindByName(row['kind']), options);
  });
};
/**
 * Parses Index information from rows in the legacy 'system.schema_columns' table.
 * @deprecated It will be removed in the next major version.
 * @param {Array.<Row>} columnRows
 * @param {Object.<String, {name, type}>} columnsByName
 * @returns {Array.<Index>}
 */


Index$1.fromColumnRows = function (columnRows, columnsByName) {
  var result = [];

  for (var i = 0; i < columnRows.length; i++) {
    var row = columnRows[i];
    var indexName = row['index_name'];

    if (!indexName) {
      continue;
    }

    var c = columnsByName[row['column_name']];
    var target = void 0;
    var options = JSON.parse(row['index_options']);

    if (options !== null && options['index_keys'] !== undefined) {
      target = util$c.format("keys(%s)", c.name);
    } else if (options !== null && options['index_keys_and_values'] !== undefined) {
      target = util$c.format("entries(%s)", c.name);
    } else if (c.type.options.frozen && (c.type.code === types$d.dataTypes.map || c.type.code === types$d.dataTypes.list || c.type.code === types$d.dataTypes.set)) {
      target = util$c.format("full(%s)", c.name);
    } else {
      target = c.name;
    }

    result.push(new Index$1(indexName, target, getKindByName(row['index_type']), options));
  }

  return result;
};
/**
 * Gets the number representing the kind based on the name
 * @param {String} name
 * @returns {Number}
 * @private
 */


function getKindByName(name) {
  if (!name) {
    return kind.custom;
  }

  return kind[name.toLowerCase()];
}

var schemaIndex = Index$1;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$b = require$$0__default$1["default"];
var DataCollection = dataCollection;
/**
 * Creates a new MaterializedView.
 * @param {String} name Name of the View.
 * @classdesc Describes a CQL materialized view.
 * @alias module:metadata~MaterializedView
 * @augments {module:metadata~DataCollection}
 * @constructor
 */

function MaterializedView$1(name) {
  DataCollection.call(this, name);
  /**
   * Name of the table.
   * @type {String}
   */

  this.tableName = null;
  /**
   * View where clause.
   * @type {String}
   */

  this.whereClause = null;
  /**
   * Determines if all the table columns where are included in the view.
   * @type {boolean}
   */

  this.includeAllColumns = false;
}

util$b.inherits(MaterializedView$1, DataCollection);
var materializedView = MaterializedView$1;

var util$a = require$$0__default$1["default"];
var events$3 = require$$0__default$2["default"];
var types$c = types$u;
var utils$j = utils$V;
var errors$a = errors$s;
var promiseUtils$7 = promiseUtils$e;
var TableMetadata = tableMetadata;
var Aggregate = aggregate;
var SchemaFunction = schemaFunction;
var Index = schemaIndex;
var MaterializedView = materializedView;
var format = util$a.format;
/**
 * @module metadata/schemaParser
 * @ignore
 */

var _selectAllKeyspacesV1 = "SELECT * FROM system.schema_keyspaces";
var _selectSingleKeyspaceV1 = "SELECT * FROM system.schema_keyspaces where keyspace_name = '%s'";
var _selectAllKeyspacesV2 = "SELECT * FROM system_schema.keyspaces";
var _selectSingleKeyspaceV2 = "SELECT * FROM system_schema.keyspaces where keyspace_name = '%s'";
var _selectTableV1 = "SELECT * FROM system.schema_columnfamilies WHERE keyspace_name='%s' AND columnfamily_name='%s'";
var _selectTableV2 = "SELECT * FROM system_schema.tables WHERE keyspace_name='%s' AND table_name='%s'";
var _selectColumnsV1 = "SELECT * FROM system.schema_columns WHERE keyspace_name='%s' AND columnfamily_name='%s'";
var _selectColumnsV2 = "SELECT * FROM system_schema.columns WHERE keyspace_name='%s' AND table_name='%s'";
var _selectIndexesV2 = "SELECT * FROM system_schema.indexes WHERE keyspace_name='%s' AND table_name='%s'";
var _selectUdtV1 = "SELECT * FROM system.schema_usertypes WHERE keyspace_name='%s' AND type_name='%s'";
var _selectUdtV2 = "SELECT * FROM system_schema.types WHERE keyspace_name='%s' AND type_name='%s'";
var _selectFunctionsV1 = "SELECT * FROM system.schema_functions WHERE keyspace_name = '%s' AND function_name = '%s'";
var _selectFunctionsV2 = "SELECT * FROM system_schema.functions WHERE keyspace_name = '%s' AND function_name = '%s'";
var _selectAggregatesV1 = "SELECT * FROM system.schema_aggregates WHERE keyspace_name = '%s' AND aggregate_name = '%s'";
var _selectAggregatesV2 = "SELECT * FROM system_schema.aggregates WHERE keyspace_name = '%s' AND aggregate_name = '%s'";
var _selectMaterializedViewV2 = "SELECT * FROM system_schema.views WHERE keyspace_name = '%s' AND view_name = '%s'";
var _selectAllVirtualKeyspaces = "SELECT * FROM system_virtual_schema.keyspaces";
var _selectSingleVirtualKeyspace = "SELECT * FROM system_virtual_schema.keyspaces where keyspace_name = '%s'";
var _selectVirtualTable = "SELECT * FROM system_virtual_schema.tables where keyspace_name = '%s' and table_name='%s'";
var _selectVirtualColumns = "SELECT * FROM system_virtual_schema.columns where keyspace_name = '%s' and table_name='%s'";
/**
 * @abstract
 * @param {ClientOptions} options The client options
 * @param {ControlConnection} cc
 * @constructor
 * @ignore
 */

var SchemaParser = /*#__PURE__*/function () {
  function SchemaParser(options, cc) {
    _classCallCheck(this, SchemaParser);

    this.cc = cc;
    this.encodingOptions = options.encoding;
    this.selectTable = null;
    this.selectColumns = null;
    this.selectIndexes = null;
    this.selectUdt = null;
    this.selectAggregates = null;
    this.selectFunctions = null;
    this.supportsVirtual = false;
  }
  /**
   * @param name
   * @param durableWrites
   * @param strategy
   * @param strategyOptions
   * @param virtual
   * @returns {{name, durableWrites, strategy, strategyOptions, tokenToReplica, udts, tables, functions, aggregates}}
   * @protected
   */


  _createClass(SchemaParser, [{
    key: "_createKeyspace",
    value: function _createKeyspace(name, durableWrites, strategy, strategyOptions, virtual) {
      return {
        name: name,
        durableWrites: durableWrites,
        strategy: strategy,
        strategyOptions: strategyOptions,
        virtual: virtual === true,
        udts: {},
        tables: {},
        functions: {},
        aggregates: {},
        views: {},
        tokenToReplica: getTokenToReplicaMapper(strategy, strategyOptions),
        graphEngine: undefined
      };
    }
    /**
     * @abstract
     * @param {String} name
     * @returns {Promise<Object>}
     */

  }, {
    key: "getKeyspace",
    value: function getKeyspace(name) {}
    /**
     * @abstract
     * @param {Boolean} waitReconnect
     * @returns {Promise<Object<string, Object>>}
     */

  }, {
    key: "getKeyspaces",
    value: function getKeyspaces(waitReconnect) {}
    /**
     * @param {String} keyspaceName
     * @param {String} name
     * @param {Object} cache
     * @param {Boolean} virtual
     * @returns {Promise<TableMetadata|null>}
     */

  }, {
    key: "getTable",
    value: function () {
      var _getTable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(keyspaceName, name, cache, virtual) {
        var tableInfo, indexRows, virtualTable, selectTable, query, tableRow, _query, selectColumns, columnRows;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                tableInfo = cache && cache[name];

                if (!tableInfo) {
                  tableInfo = new TableMetadata(name);

                  if (cache) {
                    cache[name] = tableInfo;
                  }
                }

                if (!tableInfo.loaded) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", tableInfo);

              case 4:
                if (!tableInfo.loading) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", promiseUtils$7.fromEvent(tableInfo, 'load'));

              case 6:
                _context.prev = 6;
                // its not cached and not being retrieved
                tableInfo.loading = true;
                virtualTable = virtual;
                selectTable = virtualTable ? _selectVirtualTable : this.selectTable;
                query = util$a.format(selectTable, keyspaceName, name);
                _context.next = 13;
                return this._getFirstRow(query);

              case 13:
                tableRow = _context.sent;

                if (!(!tableRow && this.supportsVirtual && virtualTable === undefined)) {
                  _context.next = 25;
                  break;
                }

                _query = util$a.format(_selectVirtualTable, keyspaceName, name);
                _context.prev = 16;
                _context.next = 19;
                return this._getFirstRow(_query);

              case 19:
                tableRow = _context.sent;
                _context.next = 24;
                break;

              case 22:
                _context.prev = 22;
                _context.t0 = _context["catch"](16);

              case 24:
                if (tableRow) {
                  // We are fetching a virtual table
                  virtualTable = true;
                }

              case 25:
                if (tableRow) {
                  _context.next = 29;
                  break;
                }

                tableInfo.loading = false;
                tableInfo.emit('load', null, null);
                return _context.abrupt("return", null);

              case 29:
                selectColumns = virtualTable ? _selectVirtualColumns : this.selectColumns;
                _context.next = 32;
                return this._getRows(util$a.format(selectColumns, keyspaceName, name));

              case 32:
                columnRows = _context.sent;

                if (!(this.selectIndexes && !virtualTable)) {
                  _context.next = 37;
                  break;
                }

                _context.next = 36;
                return this._getRows(util$a.format(this.selectIndexes, keyspaceName, name));

              case 36:
                indexRows = _context.sent;

              case 37:
                _context.next = 39;
                return this._parseTableOrView(tableInfo, tableRow, columnRows, indexRows, virtualTable);

              case 39:
                tableInfo.loaded = true;
                tableInfo.emit('load', null, tableInfo);
                return _context.abrupt("return", tableInfo);

              case 44:
                _context.prev = 44;
                _context.t1 = _context["catch"](6);
                tableInfo.emit('load', _context.t1, null);
                throw _context.t1;

              case 48:
                _context.prev = 48;
                tableInfo.loading = false;
                return _context.finish(48);

              case 51:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[6, 44, 48, 51], [16, 22]]);
      }));

      function getTable(_x, _x2, _x3, _x4) {
        return _getTable.apply(this, arguments);
      }

      return getTable;
    }()
  }, {
    key: "_getFirstRow",
    value: function () {
      var _getFirstRow2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(query) {
        var rows;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._getRows(query);

              case 2:
                rows = _context2.sent;
                return _context2.abrupt("return", rows[0]);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getFirstRow(_x5) {
        return _getFirstRow2.apply(this, arguments);
      }

      return _getFirstRow;
    }()
  }, {
    key: "_getRows",
    value: function () {
      var _getRows2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(query) {
        var response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.cc.query(query);

              case 2:
                response = _context3.sent;
                return _context3.abrupt("return", response.rows);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _getRows(_x6) {
        return _getRows2.apply(this, arguments);
      }

      return _getRows;
    }()
    /**
     * @param {String} keyspaceName
     * @param {String} name
     * @param {Object} cache
     * @returns {Promise<Object|null>}
     */

  }, {
    key: "getUdt",
    value: function () {
      var _getUdt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(keyspaceName, name, cache) {
        var udtInfo, query, row;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                udtInfo = cache && cache[name];

                if (!udtInfo) {
                  udtInfo = new events$3.EventEmitter();

                  if (cache) {
                    cache[name] = udtInfo;
                  }

                  udtInfo.setMaxListeners(0);
                  udtInfo.loading = false;
                  udtInfo.name = name;
                  udtInfo.keyspace = keyspaceName;
                  udtInfo.fields = null;
                }

                if (!udtInfo.fields) {
                  _context4.next = 4;
                  break;
                }

                return _context4.abrupt("return", udtInfo);

              case 4:
                if (!udtInfo.loading) {
                  _context4.next = 6;
                  break;
                }

                return _context4.abrupt("return", promiseUtils$7.fromEvent(udtInfo, 'load'));

              case 6:
                udtInfo.loading = true;
                query = format(this.selectUdt, keyspaceName, name);
                _context4.prev = 8;
                _context4.next = 11;
                return this._getFirstRow(query);

              case 11:
                row = _context4.sent;

                if (row) {
                  _context4.next = 16;
                  break;
                }

                udtInfo.loading = false;
                udtInfo.emit('load', null, null);
                return _context4.abrupt("return", null);

              case 16:
                _context4.next = 18;
                return this._parseUdt(udtInfo, row);

              case 18:
                udtInfo.emit('load', null, udtInfo);
                return _context4.abrupt("return", udtInfo);

              case 22:
                _context4.prev = 22;
                _context4.t0 = _context4["catch"](8);
                udtInfo.emit('load', _context4.t0);
                throw _context4.t0;

              case 26:
                _context4.prev = 26;
                udtInfo.loading = false;
                return _context4.finish(26);

              case 29:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[8, 22, 26, 29]]);
      }));

      function getUdt(_x7, _x8, _x9) {
        return _getUdt.apply(this, arguments);
      }

      return getUdt;
    }()
    /**
     * Parses the udt information from the row
     * @param udtInfo
     * @param {Row} row
     * @returns {Promise<void>}
     * @abstract
     */

  }, {
    key: "_parseUdt",
    value: function _parseUdt(udtInfo, row) {}
    /**
     * Builds the metadata based on the table and column rows
     * @abstract
     * @param {module:metadata~TableMetadata} tableInfo
     * @param {Row} tableRow
     * @param {Array.<Row>} columnRows
     * @param {Array.<Row>} indexRows
     * @param {Boolean} virtual
     * @returns {Promise<void>}
     * @throws {Error}
     */

  }, {
    key: "_parseTableOrView",
    value: function () {
      var _parseTableOrView2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(tableInfo, tableRow, columnRows, indexRows, virtual) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function _parseTableOrView(_x10, _x11, _x12, _x13, _x14) {
        return _parseTableOrView2.apply(this, arguments);
      }

      return _parseTableOrView;
    }()
    /**
     * @abstract
     * @param {String} keyspaceName
     * @param {String} name
     * @param {Object} cache
     * @returns {Promise<MaterializedView|null>}
     */

  }, {
    key: "getMaterializedView",
    value: function getMaterializedView(keyspaceName, name, cache) {}
    /**
     * @param {String} keyspaceName
     * @param {String} name
     * @param {Boolean} aggregate
     * @param {Object} cache
     * @returns {Promise<Map>}
     */

  }, {
    key: "getFunctions",
    value: function () {
      var _getFunctions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(keyspaceName, name, aggregate, cache) {
        var _this = this;

        var query, parser, functionsInfo, rows, funcs, result;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                /** @type {String} */
                query = this.selectFunctions;

                parser = function parser(row) {
                  return _this._parseFunction(row);
                };

                if (aggregate) {
                  query = this.selectAggregates;

                  parser = function parser(row) {
                    return _this._parseAggregate(row);
                  };
                } // if it's not already loaded, get all functions with that name
                // cache it by name and, within name, by signature


                functionsInfo = cache && cache[name];

                if (!functionsInfo) {
                  functionsInfo = new events$3.EventEmitter();

                  if (cache) {
                    cache[name] = functionsInfo;
                  }

                  functionsInfo.setMaxListeners(0);
                }

                if (!functionsInfo.values) {
                  _context6.next = 7;
                  break;
                }

                return _context6.abrupt("return", functionsInfo.values);

              case 7:
                if (!functionsInfo.loading) {
                  _context6.next = 9;
                  break;
                }

                return _context6.abrupt("return", promiseUtils$7.fromEvent(functionsInfo, 'load'));

              case 9:
                functionsInfo.loading = true;
                _context6.prev = 10;
                _context6.next = 13;
                return this._getRows(format(query, keyspaceName, name));

              case 13:
                rows = _context6.sent;
                _context6.next = 16;
                return Promise.all(rows.map(parser));

              case 16:
                funcs = _context6.sent;
                result = new Map();

                if (rows.length > 0) {
                  // Cache positive hits
                  functionsInfo.values = result;
                }

                funcs.forEach(function (f) {
                  return functionsInfo.values.set(f.signature.join(','), f);
                });
                functionsInfo.emit('load', null, result);
                return _context6.abrupt("return", result);

              case 24:
                _context6.prev = 24;
                _context6.t0 = _context6["catch"](10);
                functionsInfo.emit('load', _context6.t0);
                throw _context6.t0;

              case 28:
                _context6.prev = 28;
                functionsInfo.loading = false;
                return _context6.finish(28);

              case 31:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[10, 24, 28, 31]]);
      }));

      function getFunctions(_x15, _x16, _x17, _x18) {
        return _getFunctions.apply(this, arguments);
      }

      return getFunctions;
    }()
    /**
     * @abstract
     * @param {Row} row
     * @returns {Promise}
     */

  }, {
    key: "_parseAggregate",
    value: function _parseAggregate(row) {}
    /**
     * @abstract
     * @param {Row} row
     * @returns {Promise}
     */

  }, {
    key: "_parseFunction",
    value: function _parseFunction(row) {}
    /** @returns {Map} */

  }, {
    key: "_asMap",
    value: function _asMap(obj) {
      if (!obj) {
        return new Map();
      }

      if (this.encodingOptions.map && obj instanceof this.encodingOptions.map) {
        // Its already a Map or a polyfill of a Map
        return obj;
      }

      return new Map(Object.keys(obj).map(function (k) {
        return [k, obj[k]];
      }));
    }
  }, {
    key: "_mapAsObject",
    value: function _mapAsObject(map) {
      if (!map) {
        return map;
      }

      if (this.encodingOptions.map && map instanceof this.encodingOptions.map) {
        var result = {};
        map.forEach(function (value, key) {
          return result[key] = value;
        });
        return result;
      }

      return map;
    }
  }]);

  return SchemaParser;
}();
/**
 * Used to parse schema information for Cassandra versions 1.2.x, and 2.x
 * @ignore
 */


var SchemaParserV1 = /*#__PURE__*/function (_SchemaParser) {
  _inherits(SchemaParserV1, _SchemaParser);

  var _super = _createSuper(SchemaParserV1);

  /**
   * @param {ClientOptions} options
   * @param {ControlConnection} cc
   */
  function SchemaParserV1(options, cc) {
    var _this2;

    _classCallCheck(this, SchemaParserV1);

    _this2 = _super.call(this, options, cc);
    _this2.selectTable = _selectTableV1;
    _this2.selectColumns = _selectColumnsV1;
    _this2.selectUdt = _selectUdtV1;
    _this2.selectAggregates = _selectAggregatesV1;
    _this2.selectFunctions = _selectFunctionsV1;
    return _this2;
  }

  _createClass(SchemaParserV1, [{
    key: "getKeyspaces",
    value: function () {
      var _getKeyspaces = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(waitReconnect) {
        var keyspaces, result, i, row, ksInfo;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                keyspaces = {};
                _context7.next = 3;
                return this.cc.query(_selectAllKeyspacesV1, waitReconnect);

              case 3:
                result = _context7.sent;

                for (i = 0; i < result.rows.length; i++) {
                  row = result.rows[i];
                  ksInfo = this._createKeyspace(row['keyspace_name'], row['durable_writes'], row['strategy_class'], JSON.parse(row['strategy_options'] || null));
                  keyspaces[ksInfo.name] = ksInfo;
                }

                return _context7.abrupt("return", keyspaces);

              case 6:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getKeyspaces(_x19) {
        return _getKeyspaces.apply(this, arguments);
      }

      return getKeyspaces;
    }()
  }, {
    key: "getKeyspace",
    value: function () {
      var _getKeyspace = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(name) {
        var row;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._getFirstRow(format(_selectSingleKeyspaceV1, name));

              case 2:
                row = _context8.sent;

                if (row) {
                  _context8.next = 5;
                  break;
                }

                return _context8.abrupt("return", null);

              case 5:
                return _context8.abrupt("return", this._createKeyspace(row['keyspace_name'], row['durable_writes'], row['strategy_class'], JSON.parse(row['strategy_options'])));

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getKeyspace(_x20) {
        return _getKeyspace.apply(this, arguments);
      }

      return getKeyspace;
    }() // eslint-disable-next-line require-await

  }, {
    key: "_parseTableOrView",
    value: function () {
      var _parseTableOrView3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(tableInfo, tableRow, columnRows, indexRows, virtual) {
        var c, name, types, encoder, columnsKeyed, partitionKeys, clusteringKeys, i, row, type, keysStoredInTableRow, _i, comparator, _i2;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                // All the tableInfo parsing in V1 is sync, it uses a async function because the super class defines one
                // to support other versions.
                encoder = this.cc.getEncoder();
                columnsKeyed = {};
                partitionKeys = [];
                clusteringKeys = [];
                tableInfo.bloomFilterFalsePositiveChance = tableRow['bloom_filter_fp_chance'];
                tableInfo.caching = tableRow['caching'];
                tableInfo.comment = tableRow['comment'];
                tableInfo.compactionClass = tableRow['compaction_strategy_class'];
                tableInfo.compactionOptions = JSON.parse(tableRow['compaction_strategy_options']);
                tableInfo.compression = JSON.parse(tableRow['compression_parameters']);
                tableInfo.gcGraceSeconds = tableRow['gc_grace_seconds'];
                tableInfo.localReadRepairChance = tableRow['local_read_repair_chance'];
                tableInfo.readRepairChance = tableRow['read_repair_chance'];
                tableInfo.populateCacheOnFlush = tableRow['populate_io_cache_on_flush'] || tableInfo.populateCacheOnFlush;
                tableInfo.memtableFlushPeriod = tableRow['memtable_flush_period_in_ms'] || tableInfo.memtableFlushPeriod;
                tableInfo.defaultTtl = tableRow['default_time_to_live'] || tableInfo.defaultTtl;
                tableInfo.speculativeRetry = tableRow['speculative_retry'] || tableInfo.speculativeRetry;
                tableInfo.indexInterval = tableRow['index_interval'] || tableInfo.indexInterval;

                if (typeof tableRow['min_index_interval'] !== 'undefined') {
                  //Cassandra 2.1+
                  tableInfo.minIndexInterval = tableRow['min_index_interval'] || tableInfo.minIndexInterval;
                  tableInfo.maxIndexInterval = tableRow['max_index_interval'] || tableInfo.maxIndexInterval;
                } else {
                  //set to null
                  tableInfo.minIndexInterval = null;
                  tableInfo.maxIndexInterval = null;
                }

                if (typeof tableRow['replicate_on_write'] !== 'undefined') {
                  //leave the default otherwise
                  tableInfo.replicateOnWrite = tableRow['replicate_on_write'];
                }

                tableInfo.columns = [];
                i = 0;

              case 22:
                if (!(i < columnRows.length)) {
                  _context9.next = 40;
                  break;
                }

                row = columnRows[i];
                type = encoder.parseFqTypeName(row['validator']);
                c = {
                  name: row['column_name'],
                  type: type,
                  isStatic: false
                };
                tableInfo.columns.push(c);
                columnsKeyed[c.name] = c;
                _context9.t0 = row['type'];
                _context9.next = _context9.t0 === 'partition_key' ? 31 : _context9.t0 === 'clustering_key' ? 33 : _context9.t0 === 'static' ? 35 : 37;
                break;

              case 31:
                partitionKeys.push({
                  c: c,
                  index: row['component_index'] || 0
                });
                return _context9.abrupt("break", 37);

              case 33:
                clusteringKeys.push({
                  c: c,
                  index: row['component_index'] || 0,
                  order: c.type.options.reversed ? 'DESC' : 'ASC'
                });
                return _context9.abrupt("break", 37);

              case 35:
                // C* 2.0.6+ supports static columns
                c.isStatic = true;
                return _context9.abrupt("break", 37);

              case 37:
                i++;
                _context9.next = 22;
                break;

              case 40:
                if (partitionKeys.length > 0) {
                  tableInfo.partitionKeys = partitionKeys.sort(utils$j.propCompare('index')).map(function (item) {
                    return item.c;
                  });
                  clusteringKeys.sort(utils$j.propCompare('index'));
                  tableInfo.clusteringKeys = clusteringKeys.map(function (item) {
                    return item.c;
                  });
                  tableInfo.clusteringOrder = clusteringKeys.map(function (item) {
                    return item.order;
                  });
                } // In C* 1.2, keys are not stored on the schema_columns table


                keysStoredInTableRow = tableInfo.partitionKeys.length === 0;

                if (keysStoredInTableRow && tableRow['key_aliases']) {
                  //In C* 1.2, keys are not stored on the schema_columns table
                  partitionKeys = JSON.parse(tableRow['key_aliases']);
                  types = encoder.parseKeyTypes(tableRow['key_validator']).types;

                  for (_i = 0; _i < partitionKeys.length; _i++) {
                    name = partitionKeys[_i];
                    c = columnsKeyed[name];

                    if (!c) {
                      c = {
                        name: name,
                        type: types[_i]
                      };
                      tableInfo.columns.push(c);
                    }

                    tableInfo.partitionKeys.push(c);
                  }
                }

                comparator = encoder.parseKeyTypes(tableRow['comparator']);

                if (keysStoredInTableRow && tableRow['column_aliases']) {
                  clusteringKeys = JSON.parse(tableRow['column_aliases']);

                  for (_i2 = 0; _i2 < clusteringKeys.length; _i2++) {
                    name = clusteringKeys[_i2];
                    c = columnsKeyed[name];

                    if (!c) {
                      c = {
                        name: name,
                        type: comparator.types[_i2]
                      };
                      tableInfo.columns.push(c);
                    }

                    tableInfo.clusteringKeys.push(c);
                    tableInfo.clusteringOrder.push(c.type.options.reversed ? 'DESC' : 'ASC');
                  }
                }

                tableInfo.isCompact = !!tableRow['is_dense'];

                if (!tableInfo.isCompact) {
                  //is_dense column does not exist in previous versions of Cassandra
                  //also, compact pk, ck and val appear as is_dense false
                  // clusteringKeys != comparator types - 1
                  // or not composite (comparator)
                  tableInfo.isCompact = //clustering keys are not marked as composite
                  !comparator.isComposite || //only 1 column not part of the partition or clustering keys
                  !comparator.hasCollections && tableInfo.clusteringKeys.length !== comparator.types.length - 1;
                }

                name = tableRow['value_alias'];

                if (tableInfo.isCompact && name && !columnsKeyed[name]) {
                  //additional column in C* 1.2 as value_alias
                  c = {
                    name: name,
                    type: encoder.parseFqTypeName(tableRow['default_validator'])
                  };
                  tableInfo.columns.push(c);
                  columnsKeyed[name] = c;
                }

                tableInfo.columnsByName = columnsKeyed;
                tableInfo.indexes = Index.fromColumnRows(columnRows, tableInfo.columnsByName);

              case 51:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _parseTableOrView(_x21, _x22, _x23, _x24, _x25) {
        return _parseTableOrView3.apply(this, arguments);
      }

      return _parseTableOrView;
    }()
  }, {
    key: "getMaterializedView",
    value: function getMaterializedView(keyspaceName, name, cache) {
      return Promise.reject(new errors$a.NotSupportedError('Materialized views are not supported on Cassandra versions below 3.0'));
    } // eslint-disable-next-line require-await

  }, {
    key: "_parseAggregate",
    value: function () {
      var _parseAggregate2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(row) {
        var encoder, aggregate, initConditionValue;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                encoder = this.cc.getEncoder();
                aggregate = new Aggregate();
                aggregate.name = row['aggregate_name'];
                aggregate.keyspaceName = row['keyspace_name'];
                aggregate.signature = row['signature'] || utils$j.emptyArray;
                aggregate.stateFunction = row['state_func'];
                aggregate.finalFunction = row['final_func'];
                aggregate.initConditionRaw = row['initcond'];
                aggregate.argumentTypes = (row['argument_types'] || utils$j.emptyArray).map(function (name) {
                  return encoder.parseFqTypeName(name);
                });
                aggregate.stateType = encoder.parseFqTypeName(row['state_type']);
                initConditionValue = encoder.decode(aggregate.initConditionRaw, aggregate.stateType);

                if (initConditionValue !== null && typeof initConditionValue !== 'undefined') {
                  aggregate.initCondition = initConditionValue.toString();
                }

                aggregate.returnType = encoder.parseFqTypeName(row['return_type']);
                return _context10.abrupt("return", aggregate);

              case 14:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function _parseAggregate(_x26) {
        return _parseAggregate2.apply(this, arguments);
      }

      return _parseAggregate;
    }() // eslint-disable-next-line require-await

  }, {
    key: "_parseFunction",
    value: function () {
      var _parseFunction2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(row) {
        var encoder, func;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                encoder = this.cc.getEncoder();
                func = new SchemaFunction();
                func.name = row['function_name'];
                func.keyspaceName = row['keyspace_name'];
                func.signature = row['signature'] || utils$j.emptyArray;
                func.argumentNames = row['argument_names'] || utils$j.emptyArray;
                func.body = row['body'];
                func.calledOnNullInput = row['called_on_null_input'];
                func.language = row['language'];
                func.argumentTypes = (row['argument_types'] || utils$j.emptyArray).map(function (name) {
                  return encoder.parseFqTypeName(name);
                });
                func.returnType = encoder.parseFqTypeName(row['return_type']);
                return _context11.abrupt("return", func);

              case 12:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function _parseFunction(_x27) {
        return _parseFunction2.apply(this, arguments);
      }

      return _parseFunction;
    }() // eslint-disable-next-line require-await

  }, {
    key: "_parseUdt",
    value: function () {
      var _parseUdt2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(udtInfo, row) {
        var encoder, fieldNames, fieldTypes, fields, i;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                encoder = this.cc.getEncoder();
                fieldNames = row['field_names'];
                fieldTypes = row['field_types'];
                fields = new Array(fieldNames.length);

                for (i = 0; i < fieldNames.length; i++) {
                  fields[i] = {
                    name: fieldNames[i],
                    type: encoder.parseFqTypeName(fieldTypes[i])
                  };
                }

                udtInfo.fields = fields;
                return _context12.abrupt("return", udtInfo);

              case 7:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function _parseUdt(_x28, _x29) {
        return _parseUdt2.apply(this, arguments);
      }

      return _parseUdt;
    }()
  }]);

  return SchemaParserV1;
}(SchemaParser);
/**
 * Used to parse schema information for Cassandra versions 3.x and above
 * @param {ClientOptions} options The client options
 * @param {ControlConnection} cc The control connection to be used
 * @param {Function} udtResolver The function to be used to retrieve the udts.
 * @ignore
 */


var SchemaParserV2 = /*#__PURE__*/function (_SchemaParser2) {
  _inherits(SchemaParserV2, _SchemaParser2);

  var _super2 = _createSuper(SchemaParserV2);

  /**
   * @param {ClientOptions} options The client options
   * @param {ControlConnection} cc The control connection to be used
   * @param {Function} udtResolver The function to be used to retrieve the udts.
   */
  function SchemaParserV2(options, cc, udtResolver) {
    var _this3;

    _classCallCheck(this, SchemaParserV2);

    _this3 = _super2.call(this, options, cc);
    _this3.udtResolver = udtResolver;
    _this3.selectTable = _selectTableV2;
    _this3.selectColumns = _selectColumnsV2;
    _this3.selectUdt = _selectUdtV2;
    _this3.selectAggregates = _selectAggregatesV2;
    _this3.selectFunctions = _selectFunctionsV2;
    _this3.selectIndexes = _selectIndexesV2;
    return _this3;
  }

  _createClass(SchemaParserV2, [{
    key: "getKeyspaces",
    value: function () {
      var _getKeyspaces2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(waitReconnect) {
        var keyspaces, result, i, ksInfo;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                keyspaces = {};
                _context13.next = 3;
                return this.cc.query(_selectAllKeyspacesV2, waitReconnect);

              case 3:
                result = _context13.sent;

                for (i = 0; i < result.rows.length; i++) {
                  ksInfo = this._parseKeyspace(result.rows[i]);
                  keyspaces[ksInfo.name] = ksInfo;
                }

                return _context13.abrupt("return", keyspaces);

              case 6:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getKeyspaces(_x30) {
        return _getKeyspaces2.apply(this, arguments);
      }

      return getKeyspaces;
    }()
  }, {
    key: "getKeyspace",
    value: function () {
      var _getKeyspace2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(name) {
        var row;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this._getFirstRow(format(_selectSingleKeyspaceV2, name));

              case 2:
                row = _context14.sent;

                if (row) {
                  _context14.next = 5;
                  break;
                }

                return _context14.abrupt("return", null);

              case 5:
                return _context14.abrupt("return", this._parseKeyspace(row));

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getKeyspace(_x31) {
        return _getKeyspace2.apply(this, arguments);
      }

      return getKeyspace;
    }()
  }, {
    key: "getMaterializedView",
    value: function () {
      var _getMaterializedView = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(keyspaceName, name, cache) {
        var viewInfo, tableRow, columnRows;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                viewInfo = cache && cache[name];

                if (!viewInfo) {
                  viewInfo = new MaterializedView(name);

                  if (cache) {
                    cache[name] = viewInfo;
                  }
                }

                if (!viewInfo.loaded) {
                  _context15.next = 4;
                  break;
                }

                return _context15.abrupt("return", viewInfo);

              case 4:
                if (!viewInfo.loading) {
                  _context15.next = 6;
                  break;
                }

                return _context15.abrupt("return", promiseUtils$7.fromEvent(viewInfo, 'load'));

              case 6:
                viewInfo.loading = true;
                _context15.prev = 7;
                _context15.next = 10;
                return this._getFirstRow(format(_selectMaterializedViewV2, keyspaceName, name));

              case 10:
                tableRow = _context15.sent;

                if (tableRow) {
                  _context15.next = 15;
                  break;
                }

                viewInfo.emit('load', null, null);
                viewInfo.loading = false;
                return _context15.abrupt("return", null);

              case 15:
                _context15.next = 17;
                return this._getRows(format(this.selectColumns, keyspaceName, name));

              case 17:
                columnRows = _context15.sent;
                _context15.next = 20;
                return this._parseTableOrView(viewInfo, tableRow, columnRows, null, false);

              case 20:
                viewInfo.loaded = true;
                viewInfo.emit('load', null, viewInfo);
                return _context15.abrupt("return", viewInfo);

              case 25:
                _context15.prev = 25;
                _context15.t0 = _context15["catch"](7);
                viewInfo.emit('load', _context15.t0);
                throw _context15.t0;

              case 29:
                _context15.prev = 29;
                viewInfo.loading = false;
                return _context15.finish(29);

              case 32:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this, [[7, 25, 29, 32]]);
      }));

      function getMaterializedView(_x32, _x33, _x34) {
        return _getMaterializedView.apply(this, arguments);
      }

      return getMaterializedView;
    }()
  }, {
    key: "_parseKeyspace",
    value: function _parseKeyspace(row, virtual) {
      var replication = row['replication'];
      var strategy;
      var strategyOptions;

      if (replication) {
        strategy = replication['class'];
        strategyOptions = {};

        for (var key in replication) {
          if (!replication.hasOwnProperty(key) || key === 'class') {
            continue;
          }

          strategyOptions[key] = replication[key];
        }
      }

      var ks = this._createKeyspace(row['keyspace_name'], row['durable_writes'], strategy, strategyOptions, virtual);

      ks.graphEngine = row['graph_engine'];
      return ks;
    }
  }, {
    key: "_parseTableOrView",
    value: function () {
      var _parseTableOrView4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(tableInfo, tableRow, columnRows, indexRows, virtual) {
        var _this4 = this;

        var encoder, columnsKeyed, partitionKeys, clusteringKeys, isView, compaction, cdc, flags, isDense, isSuper, isCompound, isStaticCompact;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                encoder = this.cc.getEncoder();
                columnsKeyed = {};
                partitionKeys = [];
                clusteringKeys = [];
                _context17.next = 6;
                return Promise.all(columnRows.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(row) {
                    var type, c;
                    return regeneratorRuntime.wrap(function _callee16$(_context16) {
                      while (1) {
                        switch (_context16.prev = _context16.next) {
                          case 0:
                            _context16.next = 2;
                            return encoder.parseTypeName(tableRow['keyspace_name'], row['type'], 0, null, _this4.udtResolver);

                          case 2:
                            type = _context16.sent;
                            c = {
                              name: row['column_name'],
                              type: type,
                              isStatic: false
                            };
                            columnsKeyed[c.name] = c;
                            _context16.t0 = row['kind'];
                            _context16.next = _context16.t0 === 'partition_key' ? 8 : _context16.t0 === 'clustering' ? 10 : _context16.t0 === 'static' ? 12 : 14;
                            break;

                          case 8:
                            partitionKeys.push({
                              c: c,
                              index: row['position'] || 0
                            });
                            return _context16.abrupt("break", 14);

                          case 10:
                            clusteringKeys.push({
                              c: c,
                              index: row['position'] || 0,
                              order: row['clustering_order'] === 'desc' ? 'DESC' : 'ASC'
                            });
                            return _context16.abrupt("break", 14);

                          case 12:
                            c.isStatic = true;
                            return _context16.abrupt("break", 14);

                          case 14:
                            return _context16.abrupt("return", c);

                          case 15:
                          case "end":
                            return _context16.stop();
                        }
                      }
                    }, _callee16);
                  }));

                  return function (_x40) {
                    return _ref.apply(this, arguments);
                  };
                }()));

              case 6:
                tableInfo.columns = _context17.sent;
                tableInfo.columnsByName = columnsKeyed;
                tableInfo.partitionKeys = partitionKeys.sort(utils$j.propCompare('index')).map(function (item) {
                  return item.c;
                });
                clusteringKeys.sort(utils$j.propCompare('index'));
                tableInfo.clusteringKeys = clusteringKeys.map(function (item) {
                  return item.c;
                });
                tableInfo.clusteringOrder = clusteringKeys.map(function (item) {
                  return item.order;
                });

                if (!virtual) {
                  _context17.next = 15;
                  break;
                }

                // When table is virtual, the only relevant information to parse are the columns
                // as the table itself has no configuration
                tableInfo.virtual = true;
                return _context17.abrupt("return");

              case 15:
                isView = tableInfo instanceof MaterializedView;
                tableInfo.bloomFilterFalsePositiveChance = tableRow['bloom_filter_fp_chance'];
                tableInfo.caching = JSON.stringify(tableRow['caching']);
                tableInfo.comment = tableRow['comment']; // Regardless of the encoding options, use always an Object to represent an associative Array

                compaction = this._asMap(tableRow['compaction']);

                if (compaction) {
                  // compactionOptions as an Object<String, String>
                  tableInfo.compactionOptions = {};
                  tableInfo.compactionClass = compaction.get('class');
                  compaction.forEach(function (value, key) {
                    if (key === 'class') {
                      return;
                    }

                    tableInfo.compactionOptions[key] = compaction.get(key);
                  });
                } // Convert compression to an Object<String, String>


                tableInfo.compression = this._mapAsObject(tableRow['compression']);
                tableInfo.gcGraceSeconds = tableRow['gc_grace_seconds'];
                tableInfo.localReadRepairChance = tableRow['dclocal_read_repair_chance'];
                tableInfo.readRepairChance = tableRow['read_repair_chance'];
                tableInfo.extensions = this._mapAsObject(tableRow['extensions']);
                tableInfo.crcCheckChance = tableRow['crc_check_chance'];
                tableInfo.memtableFlushPeriod = tableRow['memtable_flush_period_in_ms'] || tableInfo.memtableFlushPeriod;
                tableInfo.defaultTtl = tableRow['default_time_to_live'] || tableInfo.defaultTtl;
                tableInfo.speculativeRetry = tableRow['speculative_retry'] || tableInfo.speculativeRetry;
                tableInfo.minIndexInterval = tableRow['min_index_interval'] || tableInfo.minIndexInterval;
                tableInfo.maxIndexInterval = tableRow['max_index_interval'] || tableInfo.maxIndexInterval;
                tableInfo.nodesync = tableRow['nodesync'] || tableInfo.nodesync;

                if (!isView) {
                  cdc = tableRow['cdc'];

                  if (cdc !== undefined) {
                    tableInfo.cdc = cdc;
                  }
                }

                if (!isView) {
                  _context17.next = 39;
                  break;
                }

                tableInfo.tableName = tableRow['base_table_name'];
                tableInfo.whereClause = tableRow['where_clause'];
                tableInfo.includeAllColumns = tableRow['include_all_columns'];
                return _context17.abrupt("return");

              case 39:
                tableInfo.indexes = this._getIndexes(indexRows); // flags can be an instance of Array or Set (real or polyfill)

                flags = tableRow['flags'];

                if (Array.isArray(flags)) {
                  flags = new Set(flags);
                }

                isDense = flags.has('dense');
                isSuper = flags.has('super');
                isCompound = flags.has('compound');
                tableInfo.isCompact = isSuper || isDense || !isCompound; // Remove the columns related to Thrift

                isStaticCompact = !isSuper && !isDense && !isCompound;

                if (isStaticCompact) {
                  pruneStaticCompactTableColumns(tableInfo);
                } else if (isDense) {
                  pruneDenseTableColumns(tableInfo);
                }

              case 48:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function _parseTableOrView(_x35, _x36, _x37, _x38, _x39) {
        return _parseTableOrView4.apply(this, arguments);
      }

      return _parseTableOrView;
    }()
  }, {
    key: "_getIndexes",
    value: function _getIndexes(indexRows) {
      var _this5 = this;

      if (!indexRows || indexRows.length === 0) {
        return utils$j.emptyArray;
      }

      return indexRows.map(function (row) {
        var options = _this5._mapAsObject(row['options']);

        return new Index(row['index_name'], options['target'], row['kind'], options);
      });
    }
  }, {
    key: "_parseAggregate",
    value: function () {
      var _parseAggregate3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(row) {
        var _this6 = this;

        var encoder, aggregate;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                encoder = this.cc.getEncoder();
                aggregate = new Aggregate();
                aggregate.name = row['aggregate_name'];
                aggregate.keyspaceName = row['keyspace_name'];
                aggregate.signature = row['argument_types'] || utils$j.emptyArray;
                aggregate.stateFunction = row['state_func'];
                aggregate.finalFunction = row['final_func'];
                aggregate.initConditionRaw = row['initcond'];
                aggregate.initCondition = aggregate.initConditionRaw;
                aggregate.deterministic = row['deterministic'] || false;
                _context18.next = 12;
                return Promise.all(aggregate.signature.map(function (name) {
                  return encoder.parseTypeName(row['keyspace_name'], name, 0, null, _this6.udtResolver);
                }));

              case 12:
                aggregate.argumentTypes = _context18.sent;
                _context18.next = 15;
                return encoder.parseTypeName(row['keyspace_name'], row['state_type'], 0, null, this.udtResolver);

              case 15:
                aggregate.stateType = _context18.sent;
                _context18.next = 18;
                return encoder.parseTypeName(row['keyspace_name'], row['return_type'], 0, null, this.udtResolver);

              case 18:
                aggregate.returnType = _context18.sent;
                return _context18.abrupt("return", aggregate);

              case 20:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function _parseAggregate(_x41) {
        return _parseAggregate3.apply(this, arguments);
      }

      return _parseAggregate;
    }()
  }, {
    key: "_parseFunction",
    value: function () {
      var _parseFunction3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(row) {
        var _this7 = this;

        var encoder, func;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                encoder = this.cc.getEncoder();
                func = new SchemaFunction();
                func.name = row['function_name'];
                func.keyspaceName = row['keyspace_name'];
                func.signature = row['argument_types'] || utils$j.emptyArray;
                func.argumentNames = row['argument_names'] || utils$j.emptyArray;
                func.body = row['body'];
                func.calledOnNullInput = row['called_on_null_input'];
                func.language = row['language'];
                func.deterministic = row['deterministic'] || false;
                func.monotonic = row['monotonic'] || false;
                func.monotonicOn = row['monotonic_on'] || utils$j.emptyArray;
                _context19.next = 14;
                return Promise.all(func.signature.map(function (name) {
                  return encoder.parseTypeName(row['keyspace_name'], name, 0, null, _this7.udtResolver);
                }));

              case 14:
                func.argumentTypes = _context19.sent;
                _context19.next = 17;
                return encoder.parseTypeName(row['keyspace_name'], row['return_type'], 0, null, this.udtResolver);

              case 17:
                func.returnType = _context19.sent;
                return _context19.abrupt("return", func);

              case 19:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _parseFunction(_x42) {
        return _parseFunction3.apply(this, arguments);
      }

      return _parseFunction;
    }()
  }, {
    key: "_parseUdt",
    value: function () {
      var _parseUdt3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(udtInfo, row) {
        var _this8 = this;

        var encoder, fieldTypes, keyspace;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                encoder = this.cc.getEncoder();
                fieldTypes = row['field_types'];
                keyspace = row['keyspace_name'];
                _context21.next = 5;
                return Promise.all(row['field_names'].map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(name, i) {
                    var type;
                    return regeneratorRuntime.wrap(function _callee20$(_context20) {
                      while (1) {
                        switch (_context20.prev = _context20.next) {
                          case 0:
                            _context20.next = 2;
                            return encoder.parseTypeName(keyspace, fieldTypes[i], 0, null, _this8.udtResolver);

                          case 2:
                            type = _context20.sent;
                            return _context20.abrupt("return", {
                              name: name,
                              type: type
                            });

                          case 4:
                          case "end":
                            return _context20.stop();
                        }
                      }
                    }, _callee20);
                  }));

                  return function (_x45, _x46) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 5:
                udtInfo.fields = _context21.sent;
                return _context21.abrupt("return", udtInfo);

              case 7:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function _parseUdt(_x43, _x44) {
        return _parseUdt3.apply(this, arguments);
      }

      return _parseUdt;
    }()
  }]);

  return SchemaParserV2;
}(SchemaParser);
/**
 * Used to parse schema information for Cassandra versions 4.x and above.
 *
 * This parser similar to [SchemaParserV2] expect it also parses virtual
 * keyspaces.
 * @ignore
 */


var SchemaParserV3 = /*#__PURE__*/function (_SchemaParserV) {
  _inherits(SchemaParserV3, _SchemaParserV);

  var _super3 = _createSuper(SchemaParserV3);

  /**
   * @param {ClientOptions} options The client options
   * @param {ControlConnection} cc The control connection to be used
   * @param {Function} udtResolver The function to be used to retrieve the udts.
   */
  function SchemaParserV3(options, cc, udtResolver) {
    var _this9;

    _classCallCheck(this, SchemaParserV3);

    _this9 = _super3.call(this, options, cc, udtResolver);
    _this9.supportsVirtual = true;
    return _this9;
  }

  _createClass(SchemaParserV3, [{
    key: "getKeyspaces",
    value: function () {
      var _getKeyspaces3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(waitReconnect) {
        var _this10 = this;

        var keyspaces, queries;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                keyspaces = {};
                queries = [{
                  query: _selectAllKeyspacesV2,
                  virtual: false
                }, {
                  query: _selectAllVirtualKeyspaces,
                  virtual: true
                }];
                _context23.next = 4;
                return Promise.all(queries.map( /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(q) {
                    var result, i, ksInfo;
                    return regeneratorRuntime.wrap(function _callee22$(_context22) {
                      while (1) {
                        switch (_context22.prev = _context22.next) {
                          case 0:
                            result = null;
                            _context22.prev = 1;
                            _context22.next = 4;
                            return _this10.cc.query(q.query, waitReconnect);

                          case 4:
                            result = _context22.sent;
                            _context22.next = 12;
                            break;

                          case 7:
                            _context22.prev = 7;
                            _context22.t0 = _context22["catch"](1);

                            if (!q.virtual) {
                              _context22.next = 11;
                              break;
                            }

                            return _context22.abrupt("return");

                          case 11:
                            throw _context22.t0;

                          case 12:
                            for (i = 0; i < result.rows.length; i++) {
                              ksInfo = _this10._parseKeyspace(result.rows[i], q.virtual);
                              keyspaces[ksInfo.name] = ksInfo;
                            }

                          case 13:
                          case "end":
                            return _context22.stop();
                        }
                      }
                    }, _callee22, null, [[1, 7]]);
                  }));

                  return function (_x48) {
                    return _ref3.apply(this, arguments);
                  };
                }()));

              case 4:
                return _context23.abrupt("return", keyspaces);

              case 5:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23);
      }));

      function getKeyspaces(_x47) {
        return _getKeyspaces3.apply(this, arguments);
      }

      return getKeyspaces;
    }()
  }, {
    key: "getKeyspace",
    value: function () {
      var _getKeyspace3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(name) {
        var ks;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this._getKeyspace(_selectSingleKeyspaceV2, name, false);

              case 2:
                ks = _context24.sent;

                if (ks) {
                  _context24.next = 5;
                  break;
                }

                return _context24.abrupt("return", this._getKeyspace(_selectSingleVirtualKeyspace, name, true));

              case 5:
                return _context24.abrupt("return", ks);

              case 6:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getKeyspace(_x49) {
        return _getKeyspace3.apply(this, arguments);
      }

      return getKeyspace;
    }()
  }, {
    key: "_getKeyspace",
    value: function () {
      var _getKeyspace4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(query, name, virtual) {
        var row;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.prev = 0;
                _context25.next = 3;
                return this._getFirstRow(format(query, name));

              case 3:
                row = _context25.sent;

                if (row) {
                  _context25.next = 6;
                  break;
                }

                return _context25.abrupt("return", null);

              case 6:
                return _context25.abrupt("return", this._parseKeyspace(row, virtual));

              case 9:
                _context25.prev = 9;
                _context25.t0 = _context25["catch"](0);

                if (!virtual) {
                  _context25.next = 13;
                  break;
                }

                return _context25.abrupt("return", null);

              case 13:
                throw _context25.t0;

              case 14:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this, [[0, 9]]);
      }));

      function _getKeyspace(_x50, _x51, _x52) {
        return _getKeyspace4.apply(this, arguments);
      }

      return _getKeyspace;
    }()
  }]);

  return SchemaParserV3;
}(SchemaParserV2);
/**
 * Upon migration from thrift to CQL, we internally create a pair of surrogate clustering/regular columns
 * for compact static tables. These columns shouldn't be exposed to the user but are currently returned by C*.
 * We also need to remove the static keyword for all other columns in the table.
 * @param {module:metadata~TableMetadata} tableInfo
*/


function pruneStaticCompactTableColumns(tableInfo) {
  var i;
  var c; //remove "column1 text" clustering column

  for (i = 0; i < tableInfo.clusteringKeys.length; i++) {
    c = tableInfo.clusteringKeys[i];
    var index = tableInfo.columns.indexOf(c);
    tableInfo.columns.splice(index, 1);
    delete tableInfo.columnsByName[c.name];
  }

  tableInfo.clusteringKeys = utils$j.emptyArray;
  tableInfo.clusteringOrder = utils$j.emptyArray; //remove regular columns and set the static columns to non-static

  i = tableInfo.columns.length;

  while (i--) {
    c = tableInfo.columns[i];

    if (!c.isStatic && tableInfo.partitionKeys.indexOf(c) === -1) {
      // remove "value blob" regular column
      tableInfo.columns.splice(i, 1);
      delete tableInfo.columnsByName[c.name];
      continue;
    }

    c.isStatic = false;
  }
}
/**
 * Upon migration from thrift to CQL, we internally create a surrogate column "value" of type custom.
 * This column shouldn't be exposed to the user but is currently returned by C*.
 * @param {module:metadata~TableMetadata} tableInfo
 */


function pruneDenseTableColumns(tableInfo) {
  var i = tableInfo.columns.length;

  while (i--) {
    var c = tableInfo.columns[i];

    if (!c.isStatic && c.type.code === types$c.dataTypes.custom && c.type.info === 'empty') {
      // remove "value blob" regular column
      tableInfo.columns.splice(i, 1);
      delete tableInfo.columnsByName[c.name];
      continue;
    }

    c.isStatic = false;
  }
}

function getTokenToReplicaMapper(strategy, strategyOptions) {
  if (/SimpleStrategy$/.test(strategy)) {
    var rf = parseInt(strategyOptions['replication_factor'], 10);

    if (rf > 1) {
      return getTokenToReplicaSimpleMapper(rf);
    }
  }

  if (/NetworkTopologyStrategy$/.test(strategy)) {
    return getTokenToReplicaNetworkMapper(strategyOptions);
  } //default, wrap in an Array


  return function noStrategy(tokenizer, ring, primaryReplicas) {
    var replicas = {};

    for (var key in primaryReplicas) {
      if (!primaryReplicas.hasOwnProperty(key)) {
        continue;
      }

      replicas[key] = [primaryReplicas[key]];
    }

    return replicas;
  };
}
/**
 * @param {Number} replicationFactor
 * @returns {function}
 */


function getTokenToReplicaSimpleMapper(replicationFactor) {
  return function tokenSimpleStrategy(tokenizer, ringTokensAsStrings, primaryReplicas) {
    var ringLength = ringTokensAsStrings.length;
    var rf = Math.min(replicationFactor, ringLength);
    var replicas = {};

    for (var i = 0; i < ringLength; i++) {
      var key = ringTokensAsStrings[i];
      var tokenReplicas = [primaryReplicas[key]];

      for (var j = 1; j < ringLength && tokenReplicas.length < rf; j++) {
        var nextReplicaIndex = i + j;

        if (nextReplicaIndex >= ringLength) {
          //circle back
          nextReplicaIndex = nextReplicaIndex % ringLength;
        }

        var nextReplica = primaryReplicas[ringTokensAsStrings[nextReplicaIndex]]; // In the case of vnodes, consecutive sections of the ring can be assigned to the same host.

        if (tokenReplicas.indexOf(nextReplica) === -1) {
          tokenReplicas.push(nextReplica);
        }
      }

      replicas[key] = tokenReplicas;
    }

    return replicas;
  };
}
/**
 * @param {Object} replicationFactors
 * @returns {Function}
 * @private
 */


function getTokenToReplicaNetworkMapper(replicationFactors) {
  //                A(DC1)
  //
  //           H         B(DC2)
  //                |
  //      G       --+--       C(DC1)
  //                |
  //           F         D(DC2)
  //
  //                E(DC1)
  return function tokenNetworkStrategy(tokenizer, ringTokensAsStrings, primaryReplicas, datacenters) {
    var replicas = {};
    var ringLength = ringTokensAsStrings.length;

    for (var i = 0; i < ringLength; i++) {
      var key = ringTokensAsStrings[i];
      var tokenReplicas = [];
      var replicasByDc = {};
      var racksPlaced = {};
      var skippedHosts = [];

      for (var j = 0; j < ringLength; j++) {
        var nextReplicaIndex = i + j;

        if (nextReplicaIndex >= ringLength) {
          //circle back
          nextReplicaIndex = nextReplicaIndex % ringLength;
        }

        var h = primaryReplicas[ringTokensAsStrings[nextReplicaIndex]]; // In the case of vnodes, consecutive sections of the ring can be assigned to the same host.

        if (tokenReplicas.indexOf(h) !== -1) {
          continue;
        }

        var dc = h.datacenter; //Check if the next replica belongs to one of the targeted dcs

        var dcRf = parseInt(replicationFactors[dc], 10);

        if (!dcRf) {
          continue;
        }

        dcRf = Math.min(dcRf, datacenters[dc].hostLength);
        var dcReplicas = replicasByDc[dc] || 0; //Amount of replicas per dc is greater than rf or the amount of host in the datacenter

        if (dcReplicas >= dcRf) {
          continue;
        }

        var racksPlacedInDc = racksPlaced[dc];

        if (!racksPlacedInDc) {
          racksPlacedInDc = racksPlaced[dc] = new utils$j.HashSet();
        }

        if (h.rack && racksPlacedInDc.contains(h.rack) && racksPlacedInDc.length < datacenters[dc].racks.length) {
          // We already selected a replica for this rack
          // Skip until replicas in other racks are added
          if (skippedHosts.length < dcRf - dcReplicas) {
            skippedHosts.push(h);
          }

          continue;
        }

        replicasByDc[h.datacenter] = ++dcReplicas;
        tokenReplicas.push(h);

        if (h.rack && racksPlacedInDc.add(h.rack) && racksPlacedInDc.length === datacenters[dc].racks.length) {
          // We finished placing all replicas for all racks in this dc
          // Add the skipped hosts
          replicasByDc[dc] += addSkippedHosts(dcRf, dcReplicas, tokenReplicas, skippedHosts);
        }

        if (isDoneForToken(replicationFactors, datacenters, replicasByDc)) {
          break;
        }
      }

      replicas[key] = tokenReplicas;
    }

    return replicas;
  };
}
/**
 * @returns {Number} The number of skipped hosts added.
 */


function addSkippedHosts(dcRf, dcReplicas, tokenReplicas, skippedHosts) {
  var i;

  for (i = 0; i < dcRf - dcReplicas && i < skippedHosts.length; i++) {
    tokenReplicas.push(skippedHosts[i]);
  }

  return i;
}

function isDoneForToken(replicationFactors, datacenters, replicasByDc) {
  var keys = Object.keys(replicationFactors);

  for (var i = 0; i < keys.length; i++) {
    var dcName = keys[i];
    var dc = datacenters[dcName];

    if (!dc) {
      // A DC is included in the RF but the DC does not exist in the topology
      continue;
    }

    var rf = Math.min(parseInt(replicationFactors[dcName], 10), dc.hostLength);

    if (rf > 0 && (!replicasByDc[dcName] || replicasByDc[dcName] < rf)) {
      return false;
    }
  }

  return true;
}
/**
 * Creates a new instance if the currentInstance is not valid for the
 * provided Cassandra version
 * @param {ClientOptions} options The client options
 * @param {ControlConnection} cc The control connection to be used
 * @param {Function} udtResolver The function to be used to retrieve the udts.
 * @param {Array.<Number>} [version] The cassandra version
 * @param {SchemaParser} [currentInstance] The current instance
 * @returns {SchemaParser}
 */


function getByVersion(options, cc, udtResolver, version, currentInstance) {
  var parserConstructor = SchemaParserV1;

  if (version && version[0] === 3) {
    parserConstructor = SchemaParserV2;
  } else if (version && version[0] >= 4) {
    parserConstructor = SchemaParserV3;
  }

  if (!currentInstance || !(currentInstance instanceof parserConstructor)) {
    return new parserConstructor(options, cc, udtResolver);
  }

  return currentInstance;
}

schemaParser.getByVersion = getByVersion;
schemaParser.isDoneForToken = isDoneForToken;

var events$2 = require$$0__default$2["default"];
var util$9 = require$$0__default$1["default"];
/**
 * Module containing classes and fields related to metadata.
 * @module metadata
 */

var t$2 = tokenizer;
var utils$i = utils$V;
var errors$9 = errors$s;
var types$b = types$u;
var requests$4 = requests$7;
var schemaParserFactory = schemaParser;
var promiseUtils$6 = promiseUtils$e;
var TokenRange = token$2.TokenRange;
var ExecutionOptions$1 = executionOptions.ExecutionOptions;
/**
 * @const
 * @private
 */

var _selectTraceSession = "SELECT * FROM system_traces.sessions WHERE session_id=%s";
/**
 * @const
 * @private
 */

var _selectTraceEvents = "SELECT * FROM system_traces.events WHERE session_id=%s";
/**
 * @const
 * @private
 */

var _selectSchemaVersionPeers = "SELECT schema_version FROM system.peers";
/**
 * @const
 * @private
 */

var _selectSchemaVersionLocal = "SELECT schema_version FROM system.local";
/**
 * @const
 * @private
 */

var _traceMaxAttemps = 5;
/**
 * @const
 * @private
 */

var _traceAttemptDelay = 400;
/**
 * Represents cluster and schema information.
 * The metadata class acts as a internal state of the driver.
 */

var Metadata$1 = /*#__PURE__*/function () {
  /**
   * Creates a new instance of {@link Metadata}.
   * @param {ClientOptions} options
   * @param {ControlConnection} controlConnection Control connection used to retrieve information.
   */
  function Metadata(options, controlConnection) {
    var _this = this;

    _classCallCheck(this, Metadata);

    if (!options) {
      throw new errors$9.ArgumentError('Options are not defined');
    }

    Object.defineProperty(this, 'options', {
      value: options,
      enumerable: false,
      writable: false
    });
    Object.defineProperty(this, 'controlConnection', {
      value: controlConnection,
      enumerable: false,
      writable: false
    });
    this.keyspaces = {};
    this.initialized = false;
    this._isDbaas = false;
    this._schemaParser = schemaParserFactory.getByVersion(options, controlConnection, this.getUdt.bind(this));
    this.log = utils$i.log;
    this._preparedQueries = new PreparedQueries(options.maxPrepared, function () {
      return _this.log.apply(_this, arguments);
    });
  }
  /**
   * Sets the cassandra version
   * @internal
   * @ignore
   * @param {Array.<Number>} version
   */


  _createClass(Metadata, [{
    key: "setCassandraVersion",
    value: function setCassandraVersion(version) {
      this._schemaParser = schemaParserFactory.getByVersion(this.options, this.controlConnection, this.getUdt.bind(this), version, this._schemaParser);
    }
    /**
     * Determines whether the cluster is provided as a service.
     * @returns {boolean} true when the cluster is provided as a service (DataStax Astra), <code>false<code> when it's a
     * different deployment (on-prem).
     */

  }, {
    key: "isDbaas",
    value: function isDbaas() {
      return this._isDbaas;
    }
    /**
     * Sets the product type as DBaaS.
     * @internal
     * @ignore
     */

  }, {
    key: "setProductTypeAsDbaas",
    value: function setProductTypeAsDbaas() {
      this._isDbaas = true;
    }
    /**
     * @ignore
     * @param {String} partitionerName
     */

  }, {
    key: "setPartitioner",
    value: function setPartitioner(partitionerName) {
      if (/RandomPartitioner$/.test(partitionerName)) {
        return this.tokenizer = new t$2.RandomTokenizer();
      }

      if (/ByteOrderedPartitioner$/.test(partitionerName)) {
        return this.tokenizer = new t$2.ByteOrderedTokenizer();
      }

      return this.tokenizer = new t$2.Murmur3Tokenizer();
    }
    /**
     * Populates the information regarding primary replica per token, datacenters (+ racks) and sorted token ring.
     * @ignore
     * @param {HostMap} hosts
     */

  }, {
    key: "buildTokens",
    value: function buildTokens(hosts) {
      var _this2 = this;

      if (!this.tokenizer) {
        return this.log('error', 'Tokenizer could not be determined');
      } //Get a sorted array of tokens


      var allSorted = []; //Get a map of <token, primaryHost>

      var primaryReplicas = {}; //Depending on the amount of tokens, this could be an expensive operation

      var hostArray = hosts.values();
      var stringify = this.tokenizer.stringify;
      var datacenters = {};
      hostArray.forEach(function (h) {
        if (!h.tokens) {
          return;
        }

        h.tokens.forEach(function (tokenString) {
          var token = _this2.tokenizer.parse(tokenString);

          utils$i.insertSorted(allSorted, token, function (t1, t2) {
            return t1.compare(t2);
          });
          primaryReplicas[stringify(token)] = h;
        });
        var dc = datacenters[h.datacenter];

        if (!dc) {
          dc = datacenters[h.datacenter] = {
            hostLength: 0,
            racks: new utils$i.HashSet()
          };
        }

        dc.hostLength++;
        dc.racks.add(h.rack);
      }); //Primary replica for given token

      this.primaryReplicas = primaryReplicas; //All the tokens in ring order

      this.ring = allSorted; // Build TokenRanges.

      var tokenRanges = new Set();

      if (this.ring.length === 1) {
        // If there is only one token, return the range ]minToken, minToken]
        var min = this.tokenizer.minToken();
        tokenRanges.add(new TokenRange(min, min, this.tokenizer));
      } else {
        for (var i = 0; i < this.ring.length; i++) {
          var start = this.ring[i];
          var end = this.ring[(i + 1) % this.ring.length];
          tokenRanges.add(new TokenRange(start, end, this.tokenizer));
        }
      }

      this.tokenRanges = tokenRanges; //Compute string versions as it's potentially expensive and frequently reused later

      this.ringTokensAsStrings = new Array(allSorted.length);

      for (var _i = 0; _i < allSorted.length; _i++) {
        this.ringTokensAsStrings[_i] = stringify(allSorted[_i]);
      } //Datacenter metadata (host length and racks)


      this.datacenters = datacenters;
    }
    /**
     * Gets the keyspace metadata information and updates the internal state of the driver.
     * <p>
     *   If a <code>callback</code> is provided, the callback is invoked when the keyspaces metadata refresh completes.
     *   Otherwise, it returns a <code>Promise</code>.
     * </p>
     * @param {String} name Name of the keyspace.
     * @param {Function} [callback] Optional callback.
     */

  }, {
    key: "refreshKeyspace",
    value: function refreshKeyspace(name, callback) {
      return promiseUtils$6.optionalCallback(this._refreshKeyspace(name), callback);
    }
    /**
     * @param {String} name
     * @private
     */

  }, {
    key: "_refreshKeyspace",
    value: function () {
      var _refreshKeyspace2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(name) {
        var ksInfo;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.initialized) {
                  _context.next = 2;
                  break;
                }

                throw this._uninitializedError();

              case 2:
                this.log('info', util$9.format('Retrieving keyspace %s metadata', name));
                _context.prev = 3;
                _context.next = 6;
                return this._schemaParser.getKeyspace(name);

              case 6:
                ksInfo = _context.sent;

                if (ksInfo) {
                  _context.next = 10;
                  break;
                }

                // the keyspace was dropped
                delete this.keyspaces[name];
                return _context.abrupt("return", null);

              case 10:
                // Tokens are lazily init on the keyspace, once a replica from that keyspace is retrieved.
                this.keyspaces[ksInfo.name] = ksInfo;
                return _context.abrupt("return", ksInfo);

              case 14:
                _context.prev = 14;
                _context.t0 = _context["catch"](3);
                this.log('error', 'There was an error while trying to retrieve keyspace information', _context.t0);
                throw _context.t0;

              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[3, 14]]);
      }));

      function _refreshKeyspace(_x) {
        return _refreshKeyspace2.apply(this, arguments);
      }

      return _refreshKeyspace;
    }()
    /**
     * Gets the metadata information of all the keyspaces and updates the internal state of the driver.
     * <p>
     *   If a <code>callback</code> is provided, the callback is invoked when the keyspace metadata refresh completes.
     *   Otherwise, it returns a <code>Promise</code>.
     * </p>
     * @param {Boolean|Function} [waitReconnect] Determines if it should wait for reconnection in case the control connection is not
     * connected at the moment. Default: true.
     * @param {Function} [callback] Optional callback.
     */

  }, {
    key: "refreshKeyspaces",
    value: function refreshKeyspaces(waitReconnect, callback) {
      if (typeof waitReconnect === 'function' || typeof waitReconnect === 'undefined') {
        callback = waitReconnect;
        waitReconnect = true;
      }

      if (!this.initialized) {
        var err = this._uninitializedError();

        if (callback) {
          return callback(err);
        }

        return Promise.reject(err);
      }

      return promiseUtils$6.optionalCallback(this.refreshKeyspacesInternal(waitReconnect), callback);
    }
    /**
     * @param {Boolean} waitReconnect
     * @returns {Promise<Object<string, Object>>}
     * @ignore
     * @internal
     */

  }, {
    key: "refreshKeyspacesInternal",
    value: function () {
      var _refreshKeyspacesInternal = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(waitReconnect) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.log('info', 'Retrieving keyspaces metadata');
                _context2.prev = 1;
                _context2.next = 4;
                return this._schemaParser.getKeyspaces(waitReconnect);

              case 4:
                this.keyspaces = _context2.sent;
                return _context2.abrupt("return", this.keyspaces);

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](1);
                this.log('error', 'There was an error while trying to retrieve keyspaces information', _context2.t0);
                throw _context2.t0;

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 8]]);
      }));

      function refreshKeyspacesInternal(_x2) {
        return _refreshKeyspacesInternal.apply(this, arguments);
      }

      return refreshKeyspacesInternal;
    }()
  }, {
    key: "_getKeyspaceReplicas",
    value: function _getKeyspaceReplicas(keyspace) {
      if (!keyspace.replicas) {
        //Calculate replicas the first time for the keyspace
        keyspace.replicas = keyspace.tokenToReplica(this.tokenizer, this.ringTokensAsStrings, this.primaryReplicas, this.datacenters);
      }

      return keyspace.replicas;
    }
    /**
     * Gets the host list representing the replicas that contain the given partition key, token or token range.
     * <p>
     *   It uses the pre-loaded keyspace metadata to retrieve the replicas for a token for a given keyspace.
     *   When the keyspace metadata has not been loaded, it returns null.
     * </p>
     * @param {String} keyspaceName
     * @param {Buffer|Token|TokenRange} token Can be Buffer (serialized partition key), Token or TokenRange
     * @returns {Array}
     */

  }, {
    key: "getReplicas",
    value: function getReplicas(keyspaceName, token) {
      if (!this.ring) {
        return null;
      }

      if (Buffer.isBuffer(token)) {
        token = this.tokenizer.hash(token);
      }

      if (token instanceof TokenRange) {
        token = token.end;
      }

      var keyspace;

      if (keyspaceName) {
        keyspace = this.keyspaces[keyspaceName];

        if (!keyspace) {
          // the keyspace was not found, the metadata should be loaded beforehand
          return null;
        }
      }

      var i = utils$i.binarySearch(this.ring, token, function (t1, t2) {
        return t1.compare(t2);
      });

      if (i < 0) {
        i = ~i;
      }

      if (i >= this.ring.length) {
        //it circled back
        i = i % this.ring.length;
      }

      var closestToken = this.ringTokensAsStrings[i];

      if (!keyspaceName) {
        return [this.primaryReplicas[closestToken]];
      }

      var replicas = this._getKeyspaceReplicas(keyspace);

      return replicas[closestToken];
    }
    /**
     * Gets the token ranges that define data distribution in the ring.
     *
     * @returns {Set<TokenRange>} The ranges of the ring or empty set if schema metadata is not enabled.
     */

  }, {
    key: "getTokenRanges",
    value: function getTokenRanges() {
      return this.tokenRanges;
    }
    /**
     * Gets the token ranges that are replicated on the given host, for
     * the given keyspace.
     *
     * @param {String} keyspaceName The name of the keyspace to get ranges for.
     * @param {Host} host The host.
     * @returns {Set<TokenRange>|null} Ranges for the keyspace on this host or null if keyspace isn't found or hasn't been loaded.
     */

  }, {
    key: "getTokenRangesForHost",
    value: function getTokenRangesForHost(keyspaceName, host) {
      var _this3 = this;

      if (!this.ring) {
        return null;
      }

      var keyspace;

      if (keyspaceName) {
        keyspace = this.keyspaces[keyspaceName];

        if (!keyspace) {
          // the keyspace was not found, the metadata should be loaded beforehand
          return null;
        }
      } // If the ring has only 1 token, just return the ranges as we should only have a single node cluster.


      if (this.ring.length === 1) {
        return this.getTokenRanges();
      }

      var replicas = this._getKeyspaceReplicas(keyspace);

      var ranges = new Set(); // for each range, find replicas for end token, if replicas include host, add range.

      this.tokenRanges.forEach(function (tokenRange) {
        var replicasForToken = replicas[_this3.tokenizer.stringify(tokenRange.end)];

        if (replicasForToken.indexOf(host) !== -1) {
          ranges.add(tokenRange);
        }
      });
      return ranges;
    }
    /**
     * Constructs a Token from the input buffer(s) or string input.  If a string is passed in
     * it is assumed this matches the token representation reported by cassandra.
     * @param {Array<Buffer>|Buffer|String} components
     * @returns {Token} constructed token from the input buffer.
     */

  }, {
    key: "newToken",
    value: function newToken(components) {
      if (!this.tokenizer) {
        throw new Error('Partitioner not established.  This should only happen if metadata was disabled or you have not connected yet.');
      }

      if (Array.isArray(components)) {
        return this.tokenizer.hash(Buffer.concat(components));
      } else if (util$9.isString(components)) {
        return this.tokenizer.parse(components);
      }

      return this.tokenizer.hash(components);
    }
    /**
     * Constructs a TokenRange from the given start and end tokens.
     * @param {Token} start
     * @param {Token} end
     * @returns TokenRange build range spanning from start (exclusive) to end (inclusive).
     */

  }, {
    key: "newTokenRange",
    value: function newTokenRange(start, end) {
      if (!this.tokenizer) {
        throw new Error('Partitioner not established.  This should only happen if metadata was disabled or you have not connected yet.');
      }

      return new TokenRange(start, end, this.tokenizer);
    }
    /**
     * Gets the metadata information already stored associated to a prepared statement
     * @param {String} keyspaceName
     * @param {String} query
     * @internal
     * @ignore
     */

  }, {
    key: "getPreparedInfo",
    value: function getPreparedInfo(keyspaceName, query) {
      return this._preparedQueries.getOrAdd(keyspaceName, query);
    }
    /**
     * Clears the internal state related to the prepared statements.
     * Following calls to the Client using the prepare flag will re-prepare the statements.
     */

  }, {
    key: "clearPrepared",
    value: function clearPrepared() {
      this._preparedQueries.clear();
    }
    /** @ignore */

  }, {
    key: "getPreparedById",
    value: function getPreparedById(id) {
      return this._preparedQueries.getById(id);
    }
    /** @ignore */

  }, {
    key: "setPreparedById",
    value: function setPreparedById(info) {
      return this._preparedQueries.setById(info);
    }
    /** @ignore */

  }, {
    key: "getAllPrepared",
    value: function getAllPrepared() {
      return this._preparedQueries.getAll();
    }
    /** @ignore */

  }, {
    key: "_uninitializedError",
    value: function _uninitializedError() {
      return new Error('Metadata has not been initialized.  This could only happen if you have not connected yet.');
    }
    /**
     * Gets the definition of an user-defined type.
     * <p>
     *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
     *   Otherwise, it returns a <code>Promise</code>.
     * </p>
     * <p>
     * When trying to retrieve the same UDT definition concurrently, it will query once and invoke all callbacks
     * with the retrieved information.
     * </p>
     * @param {String} keyspaceName Name of the keyspace.
     * @param {String} name Name of the UDT.
     * @param {Function} [callback] The callback to invoke when retrieval completes.
     */

  }, {
    key: "getUdt",
    value: function getUdt(keyspaceName, name, callback) {
      return promiseUtils$6.optionalCallback(this._getUdt(keyspaceName, name), callback);
    }
    /**
     * @param {String} keyspaceName
     * @param {String} name
     * @returns {Promise<Object|null>}
     * @private
     */

  }, {
    key: "_getUdt",
    value: function () {
      var _getUdt2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(keyspaceName, name) {
        var cache, keyspace;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this.initialized) {
                  _context3.next = 2;
                  break;
                }

                throw this._uninitializedError();

              case 2:
                if (!this.options.isMetadataSyncEnabled) {
                  _context3.next = 7;
                  break;
                }

                keyspace = this.keyspaces[keyspaceName];

                if (keyspace) {
                  _context3.next = 6;
                  break;
                }

                return _context3.abrupt("return", null);

              case 6:
                cache = keyspace.udts;

              case 7:
                _context3.next = 9;
                return this._schemaParser.getUdt(keyspaceName, name, cache);

              case 9:
                return _context3.abrupt("return", _context3.sent);

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _getUdt(_x3, _x4) {
        return _getUdt2.apply(this, arguments);
      }

      return _getUdt;
    }()
    /**
     * Gets the definition of a table.
     * <p>
     *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
     *   Otherwise, it returns a <code>Promise</code>.
     * </p>
     * <p>
     * When trying to retrieve the same table definition concurrently, it will query once and invoke all callbacks
     * with the retrieved information.
     * </p>
     * @param {String} keyspaceName Name of the keyspace.
     * @param {String} name Name of the Table.
     * @param {Function} [callback] The callback with the err as a first parameter and the {@link TableMetadata} as
     * second parameter.
     */

  }, {
    key: "getTable",
    value: function getTable(keyspaceName, name, callback) {
      return promiseUtils$6.optionalCallback(this._getTable(keyspaceName, name), callback);
    }
    /**
     * @param {String} keyspaceName
     * @param {String} name
     * @private
     */

  }, {
    key: "_getTable",
    value: function () {
      var _getTable2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(keyspaceName, name) {
        var cache, virtual, keyspace;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (this.initialized) {
                  _context4.next = 2;
                  break;
                }

                throw this._uninitializedError();

              case 2:
                if (!this.options.isMetadataSyncEnabled) {
                  _context4.next = 8;
                  break;
                }

                keyspace = this.keyspaces[keyspaceName];

                if (keyspace) {
                  _context4.next = 6;
                  break;
                }

                return _context4.abrupt("return", null);

              case 6:
                cache = keyspace.tables;
                virtual = keyspace.virtual;

              case 8:
                _context4.next = 10;
                return this._schemaParser.getTable(keyspaceName, name, cache, virtual);

              case 10:
                return _context4.abrupt("return", _context4.sent);

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _getTable(_x5, _x6) {
        return _getTable2.apply(this, arguments);
      }

      return _getTable;
    }()
    /**
     * Gets the definition of CQL functions for a given name.
     * <p>
     *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
     *   Otherwise, it returns a <code>Promise</code>.
     * </p>
     * <p>
     * When trying to retrieve the same function definition concurrently, it will query once and invoke all callbacks
     * with the retrieved information.
     * </p>
     * @param {String} keyspaceName Name of the keyspace.
     * @param {String} name Name of the Function.
     * @param {Function} [callback] The callback with the err as a first parameter and the array of {@link SchemaFunction}
     * as second parameter.
     */

  }, {
    key: "getFunctions",
    value: function getFunctions(keyspaceName, name, callback) {
      return promiseUtils$6.optionalCallback(this._getFunctionsWrapper(keyspaceName, name), callback);
    }
    /**
     * @param {String} keyspaceName
     * @param {String} name
     * @private
     */

  }, {
    key: "_getFunctionsWrapper",
    value: function () {
      var _getFunctionsWrapper2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(keyspaceName, name) {
        var functionsMap;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(!keyspaceName || !name)) {
                  _context5.next = 2;
                  break;
                }

                throw new errors$9.ArgumentError('You must provide the keyspace name and cql function name to retrieve the metadata');

              case 2:
                _context5.next = 4;
                return this._getFunctions(keyspaceName, name, false);

              case 4:
                functionsMap = _context5.sent;
                return _context5.abrupt("return", Array.from(functionsMap.values()));

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _getFunctionsWrapper(_x7, _x8) {
        return _getFunctionsWrapper2.apply(this, arguments);
      }

      return _getFunctionsWrapper;
    }()
    /**
     * Gets a definition of CQL function for a given name and signature.
     * <p>
     *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
     *   Otherwise, it returns a <code>Promise</code>.
     * </p>
     * <p>
     * When trying to retrieve the same function definition concurrently, it will query once and invoke all callbacks
     * with the retrieved information.
     * </p>
     * @param {String} keyspaceName Name of the keyspace
     * @param {String} name Name of the Function
     * @param {Array.<String>|Array.<{code, info}>} signature Array of types of the parameters.
     * @param {Function} [callback] The callback with the err as a first parameter and the {@link SchemaFunction} as second
     * parameter.
     */

  }, {
    key: "getFunction",
    value: function getFunction(keyspaceName, name, signature, callback) {
      return promiseUtils$6.optionalCallback(this._getSingleFunction(keyspaceName, name, signature, false), callback);
    }
    /**
     * Gets the definition of CQL aggregate for a given name.
     * <p>
     *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
     *   Otherwise, it returns a <code>Promise</code>.
     * </p>
     * <p>
     * When trying to retrieve the same aggregates definition concurrently, it will query once and invoke all callbacks
     * with the retrieved information.
     * </p>
     * @param {String} keyspaceName Name of the keyspace
     * @param {String} name Name of the Function
     * @param {Function} [callback] The callback with the err as a first parameter and the array of {@link Aggregate} as
     * second parameter.
     */

  }, {
    key: "getAggregates",
    value: function getAggregates(keyspaceName, name, callback) {
      return promiseUtils$6.optionalCallback(this._getAggregates(keyspaceName, name), callback);
    }
    /**
     * @param {String} keyspaceName
     * @param {String} name
     * @private
     */

  }, {
    key: "_getAggregates",
    value: function () {
      var _getAggregates2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(keyspaceName, name) {
        var functionsMap;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(!keyspaceName || !name)) {
                  _context6.next = 2;
                  break;
                }

                throw new errors$9.ArgumentError('You must provide the keyspace name and cql aggregate name to retrieve the metadata');

              case 2:
                _context6.next = 4;
                return this._getFunctions(keyspaceName, name, true);

              case 4:
                functionsMap = _context6.sent;
                return _context6.abrupt("return", Array.from(functionsMap.values()));

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _getAggregates(_x9, _x10) {
        return _getAggregates2.apply(this, arguments);
      }

      return _getAggregates;
    }()
    /**
     * Gets a definition of CQL aggregate for a given name and signature.
     * <p>
     *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
     *   Otherwise, it returns a <code>Promise</code>.
     * </p>
     * <p>
     * When trying to retrieve the same aggregate definition concurrently, it will query once and invoke all callbacks
     * with the retrieved information.
     * </p>
     * @param {String} keyspaceName Name of the keyspace
     * @param {String} name Name of the aggregate
     * @param {Array.<String>|Array.<{code, info}>} signature Array of types of the parameters.
     * @param {Function} [callback] The callback with the err as a first parameter and the {@link Aggregate} as second parameter.
     */

  }, {
    key: "getAggregate",
    value: function getAggregate(keyspaceName, name, signature, callback) {
      return promiseUtils$6.optionalCallback(this._getSingleFunction(keyspaceName, name, signature, true), callback);
    }
    /**
     * Gets the definition of a CQL materialized view for a given name.
     * <p>
     *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
     *   Otherwise, it returns a <code>Promise</code>.
     * </p>
     * <p>
     *   Note that, unlike the rest of the {@link Metadata} methods, this method does not cache the result for following
     *   calls, as the current version of the Cassandra native protocol does not support schema change events for
     *   materialized views. Each call to this method will produce one or more queries to the cluster.
     * </p>
     * @param {String} keyspaceName Name of the keyspace
     * @param {String} name Name of the materialized view
     * @param {Function} [callback] The callback with the err as a first parameter and the {@link MaterializedView} as
     * second parameter.
     */

  }, {
    key: "getMaterializedView",
    value: function getMaterializedView(keyspaceName, name, callback) {
      return promiseUtils$6.optionalCallback(this._getMaterializedView(keyspaceName, name), callback);
    }
    /**
     * @param {String} keyspaceName
     * @param {String} name
     * @returns {Promise<MaterializedView|null>}
     * @private
     */

  }, {
    key: "_getMaterializedView",
    value: function () {
      var _getMaterializedView2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(keyspaceName, name) {
        var cache, keyspace;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this.initialized) {
                  _context7.next = 2;
                  break;
                }

                throw this._uninitializedError();

              case 2:
                if (!this.options.isMetadataSyncEnabled) {
                  _context7.next = 7;
                  break;
                }

                keyspace = this.keyspaces[keyspaceName];

                if (keyspace) {
                  _context7.next = 6;
                  break;
                }

                return _context7.abrupt("return", null);

              case 6:
                cache = keyspace.views;

              case 7:
                _context7.next = 9;
                return this._schemaParser.getMaterializedView(keyspaceName, name, cache);

              case 9:
                return _context7.abrupt("return", _context7.sent);

              case 10:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _getMaterializedView(_x11, _x12) {
        return _getMaterializedView2.apply(this, arguments);
      }

      return _getMaterializedView;
    }()
    /**
     * Gets a map of cql function definitions or aggregates based on signature.
     * @param {String} keyspaceName
     * @param {String} name Name of the function or aggregate
     * @param {Boolean} aggregate
     * @returns {Promise<Map>}
     * @private
     */

  }, {
    key: "_getFunctions",
    value: function () {
      var _getFunctions2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(keyspaceName, name, aggregate) {
        var cache, keyspace;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (this.initialized) {
                  _context8.next = 2;
                  break;
                }

                throw this._uninitializedError();

              case 2:
                if (!this.options.isMetadataSyncEnabled) {
                  _context8.next = 7;
                  break;
                }

                keyspace = this.keyspaces[keyspaceName];

                if (keyspace) {
                  _context8.next = 6;
                  break;
                }

                return _context8.abrupt("return", new Map());

              case 6:
                cache = aggregate ? keyspace.aggregates : keyspace.functions;

              case 7:
                _context8.next = 9;
                return this._schemaParser.getFunctions(keyspaceName, name, aggregate, cache);

              case 9:
                return _context8.abrupt("return", _context8.sent);

              case 10:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _getFunctions(_x13, _x14, _x15) {
        return _getFunctions2.apply(this, arguments);
      }

      return _getFunctions;
    }()
    /**
     * Gets a single cql function or aggregate definition
     * @param {String} keyspaceName
     * @param {String} name
     * @param {Array} signature
     * @param {Boolean} aggregate
     * @returns {Promise<SchemaFunction|Aggregate|null>}
     * @private
     */

  }, {
    key: "_getSingleFunction",
    value: function () {
      var _getSingleFunction2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(keyspaceName, name, signature, aggregate) {
        var functionsMap;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(!keyspaceName || !name)) {
                  _context9.next = 2;
                  break;
                }

                throw new errors$9.ArgumentError('You must provide the keyspace name and cql function name to retrieve the metadata');

              case 2:
                if (Array.isArray(signature)) {
                  _context9.next = 4;
                  break;
                }

                throw new errors$9.ArgumentError('Signature must be an array of types');

              case 4:
                signature = signature.map(function (item) {
                  if (typeof item === 'string') {
                    return item;
                  }

                  return types$b.getDataTypeNameByCode(item);
                });
                _context9.next = 7;
                return this._getFunctions(keyspaceName, name, aggregate);

              case 7:
                functionsMap = _context9.sent;
                return _context9.abrupt("return", functionsMap.get(signature.join(',')) || null);

              case 9:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _getSingleFunction(_x16, _x17, _x18, _x19) {
        return _getSingleFunction2.apply(this, arguments);
      }

      return _getSingleFunction;
    }()
    /**
     * Gets the trace session generated by Cassandra when query tracing is enabled for the
     * query. The trace itself is stored in Cassandra in the <code>sessions</code> and
     * <code>events</code> table in the <code>system_traces</code> keyspace and can be
     * retrieve manually using the trace identifier.
     * <p>
     *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.
     *   Otherwise, it returns a <code>Promise</code>.
     * </p>
     * @param {Uuid} traceId Identifier of the trace session.
     * @param {Number} [consistency] The consistency level to obtain the trace.
     * @param {Function} [callback] The callback with the err as first parameter and the query trace as second parameter.
     */

  }, {
    key: "getTrace",
    value: function getTrace(traceId, consistency, callback) {
      if (!callback && typeof consistency === 'function') {
        // Both callback and consistency are optional parameters
        // In this case, the second parameter is the callback
        callback = consistency;
        consistency = null;
      }

      return promiseUtils$6.optionalCallback(this._getTrace(traceId, consistency), callback);
    }
    /**
     * @param {Uuid} traceId
     * @param {Number} consistency
     * @returns {Promise<Object>}
     * @private
     */

  }, {
    key: "_getTrace",
    value: function () {
      var _getTrace2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(traceId, consistency) {
        var trace, attempts, info, sessionRequest, eventsRequest, sessionResponse, sessionRow, eventsResponse;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (this.initialized) {
                  _context10.next = 2;
                  break;
                }

                throw this._uninitializedError();

              case 2:
                attempts = 0;
                info = ExecutionOptions$1.empty();

                info.getConsistency = function () {
                  return consistency;
                };

                sessionRequest = new requests$4.QueryRequest(util$9.format(_selectTraceSession, traceId), null, info);
                eventsRequest = new requests$4.QueryRequest(util$9.format(_selectTraceEvents, traceId), null, info);

              case 7:
                if (!(!trace && attempts++ < _traceMaxAttemps)) {
                  _context10.next = 23;
                  break;
                }

                _context10.next = 10;
                return this.controlConnection.query(sessionRequest);

              case 10:
                sessionResponse = _context10.sent;
                sessionRow = sessionResponse.rows[0];

                if (!(!sessionRow || typeof sessionRow['duration'] !== 'number')) {
                  _context10.next = 16;
                  break;
                }

                _context10.next = 15;
                return promiseUtils$6.delay(_traceAttemptDelay);

              case 15:
                return _context10.abrupt("continue", 7);

              case 16:
                trace = {
                  requestType: sessionRow['request'],
                  coordinator: sessionRow['coordinator'],
                  parameters: sessionRow['parameters'],
                  startedAt: sessionRow['started_at'],
                  duration: sessionRow['duration'],
                  clientAddress: sessionRow['client'],
                  events: null
                };
                _context10.next = 19;
                return this.controlConnection.query(eventsRequest);

              case 19:
                eventsResponse = _context10.sent;
                trace.events = eventsResponse.rows.map(function (row) {
                  return {
                    id: row['event_id'],
                    activity: row['activity'],
                    source: row['source'],
                    elapsed: row['source_elapsed'],
                    thread: row['thread']
                  };
                });
                _context10.next = 7;
                break;

              case 23:
                if (trace) {
                  _context10.next = 25;
                  break;
                }

                throw new Error("Trace ".concat(traceId.toString(), " could not fully retrieved after ").concat(_traceMaxAttemps, " attempts"));

              case 25:
                return _context10.abrupt("return", trace);

              case 26:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function _getTrace(_x20, _x21) {
        return _getTrace2.apply(this, arguments);
      }

      return _getTrace;
    }()
    /**
     * Checks whether hosts that are currently up agree on the schema definition.
     * <p>
     *   This method performs a one-time check only, without any form of retry; therefore
     *   <code>protocolOptions.maxSchemaAgreementWaitSeconds</code> setting does not apply in this case.
     * </p>
     * @param {Function} [callback] A function that is invoked with a value
     * <code>true</code> when all hosts agree on the schema and <code>false</code> when there is no agreement or when
     * the check could not be performed (for example, if the control connection is down).
     * @returns {Promise} Returns a <code>Promise</code> when a callback is not provided. The promise resolves to
     * <code>true</code> when all hosts agree on the schema and <code>false</code> when there is no agreement or when
     * the check could not be performed (for example, if the control connection is down).
     */

  }, {
    key: "checkSchemaAgreement",
    value: function checkSchemaAgreement(callback) {
      return promiseUtils$6.optionalCallback(this._checkSchemaAgreement(), callback);
    }
    /**
     * Async-only version of check schema agreement.
     * @private
     */

  }, {
    key: "_checkSchemaAgreement",
    value: function () {
      var _checkSchemaAgreement2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var connection;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                connection = this.controlConnection.connection;

                if (connection) {
                  _context11.next = 3;
                  break;
                }

                return _context11.abrupt("return", false);

              case 3:
                _context11.prev = 3;
                _context11.next = 6;
                return this.compareSchemaVersions(connection);

              case 6:
                return _context11.abrupt("return", _context11.sent);

              case 9:
                _context11.prev = 9;
                _context11.t0 = _context11["catch"](3);
                return _context11.abrupt("return", false);

              case 12:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[3, 9]]);
      }));

      function _checkSchemaAgreement() {
        return _checkSchemaAgreement2.apply(this, arguments);
      }

      return _checkSchemaAgreement;
    }()
    /**
     * Uses the metadata to fill the user provided parameter hints
     * @param {String} keyspace
     * @param {Array} hints
     * @internal
     * @ignore
     */

  }, {
    key: "adaptUserHints",
    value: function () {
      var _adaptUserHints = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(keyspace, hints) {
        var udts, i, hint, type, _i2, _udts, _type, udtInfo;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (Array.isArray(hints)) {
                  _context12.next = 2;
                  break;
                }

                return _context12.abrupt("return");

              case 2:
                udts = []; // Check for udts and get the metadata

                i = 0;

              case 4:
                if (!(i < hints.length)) {
                  _context12.next = 14;
                  break;
                }

                hint = hints[i];

                if (!(typeof hint !== 'string')) {
                  _context12.next = 8;
                  break;
                }

                return _context12.abrupt("continue", 11);

              case 8:
                type = types$b.dataTypes.getByName(hint);

                this._checkUdtTypes(udts, type, keyspace);

                hints[i] = type;

              case 11:
                i++;
                _context12.next = 4;
                break;

              case 14:
                _i2 = 0, _udts = udts;

              case 15:
                if (!(_i2 < _udts.length)) {
                  _context12.next = 26;
                  break;
                }

                _type = _udts[_i2];
                _context12.next = 19;
                return this.getUdt(_type.info.keyspace, _type.info.name);

              case 19:
                udtInfo = _context12.sent;

                if (udtInfo) {
                  _context12.next = 22;
                  break;
                }

                throw new TypeError('User defined type not found: ' + _type.info.keyspace + '.' + _type.info.name);

              case 22:
                _type.info = udtInfo;

              case 23:
                _i2++;
                _context12.next = 15;
                break;

              case 26:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function adaptUserHints(_x22, _x23) {
        return _adaptUserHints.apply(this, arguments);
      }

      return adaptUserHints;
    }()
    /**
     * @param {Array} udts
     * @param {{code, info}} type
     * @param {string} keyspace
     * @private
     */

  }, {
    key: "_checkUdtTypes",
    value: function _checkUdtTypes(udts, type, keyspace) {
      if (type.code === types$b.dataTypes.udt) {
        var udtName = type.info.split('.');
        type.info = {
          keyspace: udtName[0],
          name: udtName[1]
        };

        if (!type.info.name) {
          if (!keyspace) {
            throw new TypeError('No keyspace specified for udt: ' + udtName.join('.'));
          } //use the provided keyspace


          type.info.name = type.info.keyspace;
          type.info.keyspace = keyspace;
        }

        udts.push(type);
        return;
      }

      if (!type.info) {
        return;
      }

      if (type.code === types$b.dataTypes.list || type.code === types$b.dataTypes.set) {
        return this._checkUdtTypes(udts, type.info, keyspace);
      }

      if (type.code === types$b.dataTypes.map) {
        this._checkUdtTypes(udts, type.info[0], keyspace);

        this._checkUdtTypes(udts, type.info[1], keyspace);
      }
    }
    /**
     * Uses the provided connection to query the schema versions and compare them.
     * @param {Connection} connection
     * @internal
     * @ignore
     */

  }, {
    key: "compareSchemaVersions",
    value: function () {
      var _compareSchemaVersions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(connection) {
        var versions, response1, response2, _iterator, _step, row, value;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                versions = new Set();
                _context13.next = 3;
                return connection.send(new requests$4.QueryRequest(_selectSchemaVersionLocal), null);

              case 3:
                response1 = _context13.sent;

                if (response1 && response1.rows && response1.rows.length === 1) {
                  versions.add(response1.rows[0]['schema_version'].toString());
                }

                _context13.next = 7;
                return connection.send(new requests$4.QueryRequest(_selectSchemaVersionPeers), null);

              case 7:
                response2 = _context13.sent;

                if (!(response2 && response2.rows)) {
                  _context13.next = 28;
                  break;
                }

                _iterator = _createForOfIteratorHelper(response2.rows);
                _context13.prev = 10;

                _iterator.s();

              case 12:
                if ((_step = _iterator.n()).done) {
                  _context13.next = 20;
                  break;
                }

                row = _step.value;
                value = row['schema_version'];

                if (value) {
                  _context13.next = 17;
                  break;
                }

                return _context13.abrupt("continue", 18);

              case 17:
                versions.add(value.toString());

              case 18:
                _context13.next = 12;
                break;

              case 20:
                _context13.next = 25;
                break;

              case 22:
                _context13.prev = 22;
                _context13.t0 = _context13["catch"](10);

                _iterator.e(_context13.t0);

              case 25:
                _context13.prev = 25;

                _iterator.f();

                return _context13.finish(25);

              case 28:
                return _context13.abrupt("return", versions.size === 1);

              case 29:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, null, [[10, 22, 25, 28]]);
      }));

      function compareSchemaVersions(_x24) {
        return _compareSchemaVersions.apply(this, arguments);
      }

      return compareSchemaVersions;
    }()
  }]);

  return Metadata;
}();
/**
 * Allows to store prepared queries and retrieval by query or query id.
 * @ignore
 */


var PreparedQueries = /*#__PURE__*/function () {
  /**
   * @param {Number} maxPrepared
   * @param {Function} logger
   */
  function PreparedQueries(maxPrepared, logger) {
    _classCallCheck(this, PreparedQueries);

    this.length = 0;
    this._maxPrepared = maxPrepared;
    this._mapByKey = new Map();
    this._mapById = new Map();
    this._logger = logger;
  }

  _createClass(PreparedQueries, [{
    key: "_getKey",
    value: function _getKey(keyspace, query) {
      return (keyspace || '') + query;
    }
  }, {
    key: "getOrAdd",
    value: function getOrAdd(keyspace, query) {
      var key = this._getKey(keyspace, query);

      var info = this._mapByKey.get(key);

      if (info) {
        return info;
      }

      this._validateOverflow();

      info = new events$2.EventEmitter();
      info.setMaxListeners(0);
      info.query = query; // The keyspace in which it was prepared

      info.keyspace = keyspace;

      this._mapByKey.set(key, info);

      this.length++;
      return info;
    }
  }, {
    key: "_validateOverflow",
    value: function _validateOverflow() {
      if (this.length < this._maxPrepared) {
        return;
      }

      var toRemove = [];

      this._logger('warning', 'Prepared statements exceeded maximum. This could be caused by preparing queries that contain parameters');

      var toRemoveLength = this.length - this._maxPrepared + 1;

      var _iterator2 = _createForOfIteratorHelper(this._mapByKey),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _slicedToArray(_step2.value, 2),
              _key = _step2$value[0],
              _info = _step2$value[1];

          if (!_info.queryId) {
            // Only remove queries that contain queryId
            continue;
          }

          var length = toRemove.push([_key, _info]);

          if (length >= toRemoveLength) {
            break;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      for (var _i3 = 0, _toRemove = toRemove; _i3 < _toRemove.length; _i3++) {
        var _toRemove$_i = _slicedToArray(_toRemove[_i3], 2),
            key = _toRemove$_i[0],
            info = _toRemove$_i[1];

        this._mapByKey["delete"](key);

        this._mapById["delete"](info.queryId.toString('hex'));

        this.length--;
      }
    }
  }, {
    key: "setById",
    value: function setById(info) {
      this._mapById.set(info.queryId.toString('hex'), info);
    }
  }, {
    key: "getById",
    value: function getById(id) {
      return this._mapById.get(id.toString('hex'));
    }
  }, {
    key: "clear",
    value: function clear() {
      this._mapByKey = new Map();
      this._mapById = new Map();
      this.length = 0;
    }
  }, {
    key: "getAll",
    value: function getAll() {
      return Array.from(this._mapByKey.values()).filter(function (info) {
        return !!info.queryId;
      });
    }
  }]);

  return PreparedQueries;
}();

var metadata = Metadata$1;

var util$8 = require$$0__default$1["default"];
var utils$h = utils$V;
var promiseUtils$5 = promiseUtils$e;
var _queueOverflowThreshold = 1000;
/**
 * Debounce protocol events by acting on those events with a sliding delay.
 * @ignore
 * @constructor
 */

var EventDebouncer$1 = /*#__PURE__*/function () {
  /**
   * Creates a new instance of the event debouncer.
   * @param {Number} delay
   * @param {Function} logger
   */
  function EventDebouncer(delay, logger) {
    _classCallCheck(this, EventDebouncer);

    this._delay = delay;
    this._logger = logger;
    this._queue = null;
    this._timeout = null;
  }
  /**
   * Adds a new event to the queue and moves the delay.
   * @param {{ handler: Function, all: boolean|undefined, keyspace: String|undefined,
   * cqlObject: String|null|undefined }} event
   * @param {Boolean} processNow
   * @returns {Promise}
   */


  _createClass(EventDebouncer, [{
    key: "eventReceived",
    value: function eventReceived(event, processNow) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        event.callback = promiseUtils$5.getCallback(resolve, reject);
        _this._queue = _this._queue || {
          callbacks: [],
          keyspaces: {}
        };
        var delay = !processNow ? _this._delay : 0;

        if (event.all) {
          // when an event marked with all is received, it supersedes all the rest of events
          // a full update (hosts + keyspaces + tokens) is going to be made
          _this._queue.mainEvent = event;
        }

        if (_this._queue.callbacks.length === _queueOverflowThreshold) {
          // warn once
          _this._logger('warn', util$8.format('Event debouncer queue exceeded %d events', _queueOverflowThreshold));
        }

        _this._queue.callbacks.push(event.callback);

        if (_this._queue.mainEvent) {
          // a full refresh is scheduled and the callback was added, nothing else to do.
          return _this._slideDelay(delay);
        } // Insert at keyspace level


        var keyspaceEvents = _this._queue.keyspaces[event.keyspace];

        if (!keyspaceEvents) {
          keyspaceEvents = _this._queue.keyspaces[event.keyspace] = {
            events: []
          };
        }

        if (event.cqlObject === undefined) {
          // a full refresh of the keyspace, supersedes all child keyspace events
          keyspaceEvents.mainEvent = event;
        }

        keyspaceEvents.events.push(event);

        _this._slideDelay(delay);
      });
    }
    /**
     * @param {Number} delay
     * @private
     * */

  }, {
    key: "_slideDelay",
    value: function _slideDelay(delay) {
      var self = this;

      function process() {
        var q = self._queue;
        self._queue = null;
        self._timeout = null;
        processQueue(q);
      }

      if (delay === 0) {
        // no delay, process immediately
        if (this._timeout) {
          clearTimeout(this._timeout);
        }

        return process();
      }

      var previousTimeout = this._timeout; // Add the new timeout before removing the previous one performs better

      this._timeout = setTimeout(process, delay);

      if (previousTimeout) {
        clearTimeout(previousTimeout);
      }
    }
    /**
     * Clears the timeout and invokes all pending callback.
     */

  }, {
    key: "shutdown",
    value: function shutdown() {
      if (!this._queue) {
        return;
      }

      this._queue.callbacks.forEach(function (cb) {
        cb();
      });

      this._queue = null;
      clearTimeout(this._timeout);
      this._timeout = null;
    }
  }]);

  return EventDebouncer;
}();
/**
 * @param {{callbacks: Array, keyspaces: Object, mainEvent: Object}} q
 * @private
 */


function processQueue(q) {
  if (q.mainEvent) {
    // refresh all by invoking 1 handler and invoke all pending callbacks
    return promiseUtils$5.toCallback(q.mainEvent.handler(), function (err) {
      for (var i = 0; i < q.callbacks.length; i++) {
        q.callbacks[i](err);
      }
    });
  }

  utils$h.each(Object.keys(q.keyspaces), function eachKeyspace(name, next) {
    var keyspaceEvents = q.keyspaces[name];

    if (keyspaceEvents.mainEvent) {
      // refresh a keyspace
      return promiseUtils$5.toCallback(keyspaceEvents.mainEvent.handler(), function mainEventCallback(err) {
        for (var i = 0; i < keyspaceEvents.events.length; i++) {
          keyspaceEvents.events[i].callback(err);
        }

        next();
      });
    } // deal with individual handlers and callbacks


    keyspaceEvents.events.forEach(function (event) {
      // sync handlers
      event.handler();
      event.callback();
    });
    next();
  });
}

var eventDebouncer = EventDebouncer$1;

var events$1 = require$$0__default$2["default"];
var util$7 = require$$0__default$1["default"];
var net = require$$1__default["default"];
var dns = require$$0__default$3["default"];
var errors$8 = errors$s;
var Host = host.Host,
    HostMap = host.HostMap;
var Metadata = metadata;
var EventDebouncer = eventDebouncer;
var Connection = connection;
var requests$3 = requests$7;
var utils$g = utils$V;
var types$a = types$u;
var promiseUtils$4 = promiseUtils$e;
var f = util$7.format;
var selectPeers = "SELECT * FROM system.peers";
var selectLocal = "SELECT * FROM system.local WHERE key='local'";
var newNodeDelay = 1000;
var metadataQueryAbortTimeout = 2000;
var schemaChangeTypes = {
  created: 'CREATED',
  updated: 'UPDATED',
  dropped: 'DROPPED'
};
var supportedProductTypeKey = 'PRODUCT_TYPE';
var supportedDbaas = 'DATASTAX_APOLLO';
/**
 * Represents a connection used by the driver to receive events and to check the status of the cluster.
 * <p>It uses an existing connection from the hosts' connection pool to maintain the driver metadata up-to-date.</p>
 */

var ControlConnection$1 = /*#__PURE__*/function (_events$EventEmitter) {
  _inherits(ControlConnection, _events$EventEmitter);

  var _super = _createSuper(ControlConnection);

  /**
   * Creates a new instance of <code>ControlConnection</code>.
   * @param {Object} options
   * @param {ProfileManager} profileManager
   * @param {{borrowHostConnection: function, createConnection: function}} [context] An object containing methods to
   * allow dependency injection.
   */
  function ControlConnection(options, profileManager, context) {
    var _this;

    _classCallCheck(this, ControlConnection);

    _this = _super.call(this);
    _this.protocolVersion = null;
    _this.hosts = new HostMap();

    _this.setMaxListeners(0);

    _this.log = utils$g.log;
    Object.defineProperty(_assertThisInitialized(_this), "options", {
      value: options,
      enumerable: false,
      writable: false
    });
    /**
     * Cluster metadata that is going to be shared between the Client and ControlConnection
     */

    _this.metadata = new Metadata(_this.options, _assertThisInitialized(_this));
    _this.initialized = false;
    /**
     * Host used by the control connection
     * @type {Host|null}
     */

    _this.host = null;
    /**
     * Connection used to retrieve metadata and subscribed to events
     * @type {Connection|null}
     */

    _this.connection = null;
    _this._addressTranslator = _this.options.policies.addressResolution;
    _this._reconnectionPolicy = _this.options.policies.reconnection;
    _this._reconnectionSchedule = _this._reconnectionPolicy.newSchedule();
    _this._isShuttingDown = false; // Reference to the encoder of the last valid connection

    _this._encoder = null;
    _this._debouncer = new EventDebouncer(options.refreshSchemaDelay, _this.log.bind(_assertThisInitialized(_this)));
    _this._profileManager = profileManager;
    _this._triedHosts = null;
    _this._resolvedContactPoints = new Map();
    _this._contactPoints = new Set(); // Timeout used for delayed handling of topology changes

    _this._topologyChangeTimeout = null; // Timeout used for delayed handling of node status changes

    _this._nodeStatusChangeTimeout = null;

    if (context && context.borrowHostConnection) {
      _this._borrowHostConnection = context.borrowHostConnection;
    }

    if (context && context.createConnection) {
      _this._createConnection = context.createConnection;
    }

    return _this;
  }
  /**
   * Stores the contact point information and what it resolved to.
   * @param {String|null} address
   * @param {String} port
   * @param {String} name
   * @param {Boolean} isIPv6
   */


  _createClass(ControlConnection, [{
    key: "_addContactPoint",
    value: function _addContactPoint(address, port, name, isIPv6) {
      if (address === null) {
        // Contact point could not be resolved, store that the resolution came back empty
        this._resolvedContactPoints.set(name, utils$g.emptyArray);

        return;
      }

      var portNumber = parseInt(port, 10) || this.options.protocolOptions.port;
      var endpoint = "".concat(address, ":").concat(portNumber);

      this._contactPoints.add(endpoint); // Use RFC 3986 for IPv4 and IPv6


      var standardEndpoint = !isIPv6 ? endpoint : "[".concat(address, "]:").concat(portNumber);

      var resolvedAddressedByName = this._resolvedContactPoints.get(name);

      if (resolvedAddressedByName === undefined) {
        resolvedAddressedByName = [];

        this._resolvedContactPoints.set(name, resolvedAddressedByName);
      }

      resolvedAddressedByName.push(standardEndpoint);
    }
  }, {
    key: "_parseContactPoint",
    value: function () {
      var _parseContactPoint2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(name) {
        var _this2 = this;

        var addressOrName, port, index, parts, addresses;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                addressOrName = name;
                port = null;

                if (name.indexOf('[') === 0 && name.indexOf(']:') > 1) {
                  // IPv6 host notation [ip]:port (RFC 3986 section 3.2.2)
                  index = name.lastIndexOf(']:');
                  addressOrName = name.substr(1, index - 1);
                  port = name.substr(index + 2);
                } else if (name.indexOf(':') > 0) {
                  // IPv4 or host name with port notation
                  parts = name.split(':');

                  if (parts.length === 2) {
                    addressOrName = parts[0];
                    port = parts[1];
                  }
                }

                if (!net.isIP(addressOrName)) {
                  _context.next = 6;
                  break;
                }

                this._addContactPoint(addressOrName, port, name, net.isIPv6(addressOrName));

                return _context.abrupt("return");

              case 6:
                _context.next = 8;
                return this._resolveAll(addressOrName);

              case 8:
                addresses = _context.sent;

                if (addresses.length > 0) {
                  addresses.forEach(function (addressInfo) {
                    return _this2._addContactPoint(addressInfo.address, port, name, addressInfo.isIPv6);
                  });
                } else {
                  // Store that we attempted resolving the name but was not found
                  this._addContactPoint(null, null, name, false);
                }

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _parseContactPoint(_x) {
        return _parseContactPoint2.apply(this, arguments);
      }

      return _parseContactPoint;
    }()
    /**
     * Initializes the control connection by establishing a Connection using a suitable protocol
     * version to be used and retrieving cluster metadata.
     */

  }, {
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _this3 = this;

        var address, separatorIndex, nameOrIp;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.initialized) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                if (this.options.sni) {
                  _context2.next = 7;
                  break;
                }

                _context2.next = 5;
                return Promise.all(this.options.contactPoints.map(function (name) {
                  return _this3._parseContactPoint(name);
                }));

              case 5:
                _context2.next = 17;
                break;

              case 7:
                this.options.contactPoints.forEach(function (cp) {
                  return _this3._contactPoints.add(cp);
                });
                address = this.options.sni.address;
                separatorIndex = address.lastIndexOf(':');

                if (!(separatorIndex === -1)) {
                  _context2.next = 12;
                  break;
                }

                throw new new errors$8.DriverInternalError('The SNI endpoint address should contain ip/name and port')();

              case 12:
                nameOrIp = address.substr(0, separatorIndex);
                this.options.sni.port = address.substr(separatorIndex + 1);
                this.options.sni.addressResolver = new utils$g.AddressResolver({
                  nameOrIp: nameOrIp,
                  dns: dns
                });
                _context2.next = 17;
                return this.options.sni.addressResolver.init();

              case 17:
                if (!(this._contactPoints.size === 0)) {
                  _context2.next = 19;
                  break;
                }

                throw new errors$8.NoHostAvailableError({}, 'No host could be resolved');

              case 19:
                _context2.next = 21;
                return this._initializeConnection();

              case 21:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "_setHealthListeners",
    value: function _setHealthListeners(host, connection) {
      var self = this;
      var wasRefreshCalled = 0;

      function removeListeners() {
        host.removeListener('down', downOrIgnoredHandler);
        host.removeListener('ignore', downOrIgnoredHandler);
        connection.removeListener('socketClose', socketClosedHandler);
      }

      function startReconnecting(hostDown) {
        if (wasRefreshCalled++ !== 0) {
          // Prevent multiple calls to reconnect
          return;
        }

        removeListeners();

        if (self._isShuttingDown) {
          // Don't attempt to reconnect when the ControlConnection is being shutdown
          return;
        }

        if (hostDown) {
          self.log('warning', "Host ".concat(host.address, " used by the ControlConnection DOWN, ") + "connection to ".concat(connection.endpointFriendlyName, " will not longer be used"));
        } else {
          self.log('warning', "Connection to ".concat(connection.endpointFriendlyName, " used by the ControlConnection was closed"));
        }

        promiseUtils$4.toBackground(self._refresh());
      }

      function downOrIgnoredHandler() {
        startReconnecting(true);
      }

      function socketClosedHandler() {
        startReconnecting(false);
      }

      host.once('down', downOrIgnoredHandler);
      host.once('ignore', downOrIgnoredHandler);
      connection.once('socketClose', socketClosedHandler);
    }
    /**
     * Iterates through the hostIterator and Gets the following open connection.
     * @param {Iterator<Host>} hostIterator
     * @returns {Connection!}
     */

  }, {
    key: "_borrowAConnection",
    value: function _borrowAConnection(hostIterator) {
      var connection = null;

      while (!connection) {
        var item = hostIterator.next();
        var host = item.value;

        if (item.done) {
          throw new errors$8.NoHostAvailableError(this._triedHosts);
        } // Only check distance once the load-balancing policies have been initialized


        var distance = this._profileManager.getDistance(host);

        if (!host.isUp() || distance === types$a.distance.ignored) {
          continue;
        }

        try {
          connection = this._borrowHostConnection(host);
        } catch (err) {
          this._triedHosts[host.address] = err;
        }
      }

      return connection;
    }
    /**
     * Iterates through the contact points and tries to open a connection.
     * @param {Iterator<string>} contactPointsIterator
     * @returns {Promise<void>}
     */

  }, {
    key: "_borrowFirstConnection",
    value: function () {
      var _borrowFirstConnection2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(contactPointsIterator) {
        var connection, item, contactPoint, err;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                connection = null;

              case 1:
                if (connection) {
                  _context3.next = 17;
                  break;
                }

                item = contactPointsIterator.next();
                contactPoint = item.value;

                if (!item.done) {
                  _context3.next = 6;
                  break;
                }

                throw new errors$8.NoHostAvailableError(this._triedHosts);

              case 6:
                _context3.prev = 6;
                _context3.next = 9;
                return this._createConnection(contactPoint);

              case 9:
                connection = _context3.sent;
                _context3.next = 15;
                break;

              case 12:
                _context3.prev = 12;
                _context3.t0 = _context3["catch"](6);
                this._triedHosts[contactPoint] = _context3.t0;

              case 15:
                _context3.next = 1;
                break;

              case 17:
                if (connection) {
                  _context3.next = 21;
                  break;
                }

                err = new errors$8.NoHostAvailableError(this._triedHosts);
                this.log('error', 'ControlConnection failed to acquire a connection');
                throw err;

              case 21:
                this.protocolVersion = connection.protocolVersion;
                this._encoder = connection.encoder;
                this.connection = connection;

              case 24:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[6, 12]]);
      }));

      function _borrowFirstConnection(_x2) {
        return _borrowFirstConnection2.apply(this, arguments);
      }

      return _borrowFirstConnection;
    }()
    /** Default implementation for borrowing connections, that can be injected at constructor level */

  }, {
    key: "_borrowHostConnection",
    value: function _borrowHostConnection(host) {
      // Borrow any open connection, regardless of the keyspace
      return host.borrowConnection();
    }
    /**
     * Default implementation for creating initial connections, that can be injected at constructor level
     * @param {String} contactPoint
     */

  }, {
    key: "_createConnection",
    value: function () {
      var _createConnection2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(contactPoint) {
        var c;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                c = new Connection(contactPoint, null, this.options);
                _context4.prev = 1;
                _context4.next = 4;
                return c.openAsync();

              case 4:
                _context4.next = 10;
                break;

              case 6:
                _context4.prev = 6;
                _context4.t0 = _context4["catch"](1);
                promiseUtils$4.toBackground(c.closeAsync());
                throw _context4.t0;

              case 10:
                return _context4.abrupt("return", c);

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[1, 6]]);
      }));

      function _createConnection(_x3) {
        return _createConnection2.apply(this, arguments);
      }

      return _createConnection;
    }()
    /**
     * Gets the info from local and peer metadata, reloads the keyspaces metadata and rebuilds tokens.
     * <p>It throws an error when there's a failure or when reconnecting and there's no connection.</p>
     * @param {Boolean} initializing Determines whether this function was called in order to initialize the control
     * connection the first time
     * @param {Boolean} isReconnecting Determines whether the refresh is being done because the ControlConnection is
     * switching to use this connection to this host.
     */

  }, {
    key: "_refreshHosts",
    value: function () {
      var _refreshHosts2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(initializing, isReconnecting) {
        var _this4 = this;

        var c, rsLocal, rsPeers, highestCommon, reconnect;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                // Get a reference to the current connection as it might change from external events
                c = this.connection;

                if (c) {
                  _context5.next = 5;
                  break;
                }

                if (!isReconnecting) {
                  _context5.next = 4;
                  break;
                }

                throw new errors$8.DriverInternalError('Connection reference has been lost when reconnecting');

              case 4:
                return _context5.abrupt("return");

              case 5:
                this.log('info', 'Refreshing local and peers info');
                _context5.next = 8;
                return c.send(new requests$3.QueryRequest(selectLocal), null);

              case 8:
                rsLocal = _context5.sent;

                this._setLocalInfo(initializing, isReconnecting, c, rsLocal);

                if (this.host) {
                  _context5.next = 12;
                  break;
                }

                throw new errors$8.DriverInternalError('Information from system.local could not be retrieved');

              case 12:
                _context5.next = 14;
                return c.send(new requests$3.QueryRequest(selectPeers), null);

              case 14:
                rsPeers = _context5.sent;
                _context5.next = 17;
                return this.setPeersInfo(initializing, rsPeers);

              case 17:
                if (this.initialized) {
                  _context5.next = 44;
                  break;
                }

                // resolve protocol version from highest common version among hosts.
                highestCommon = types$a.protocolVersion.getHighestCommon(c, this.hosts);
                reconnect = highestCommon !== this.protocolVersion; // set protocol version on each host.

                this.protocolVersion = highestCommon;
                this.hosts.forEach(function (h) {
                  return h.setProtocolVersion(_this4.protocolVersion);
                }); // if protocol version changed, reconnect the control connection with new version.

                if (!reconnect) {
                  _context5.next = 36;
                  break;
                }

                this.log('info', "Reconnecting since the protocol version changed to 0x".concat(highestCommon.toString(16)));
                c.decreaseVersion(this.protocolVersion);
                _context5.next = 27;
                return c.closeAsync();

              case 27:
                _context5.prev = 27;
                _context5.next = 30;
                return c.openAsync();

              case 30:
                _context5.next = 36;
                break;

              case 32:
                _context5.prev = 32;
                _context5.t0 = _context5["catch"](27);
                // Close in the background
                promiseUtils$4.toBackground(c.closeAsync());
                throw _context5.t0;

              case 36:
                // To acquire metadata we need to specify the cassandra version
                this.metadata.setCassandraVersion(this.host.getCassandraVersion());
                this.metadata.buildTokens(this.hosts);

                if (this.options.isMetadataSyncEnabled) {
                  _context5.next = 41;
                  break;
                }

                this.metadata.initialized = true;
                return _context5.abrupt("return");

              case 41:
                _context5.next = 43;
                return this.metadata.refreshKeyspacesInternal(false);

              case 43:
                this.metadata.initialized = true;

              case 44:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[27, 32]]);
      }));

      function _refreshHosts(_x4, _x5) {
        return _refreshHosts2.apply(this, arguments);
      }

      return _refreshHosts;
    }()
  }, {
    key: "_refreshControlConnection",
    value: function () {
      var _refreshControlConnection2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(hostIterator) {
        var _this5 = this;

        var refreshedContactPoints;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!this.options.sni) {
                  _context6.next = 4;
                  break;
                }

                this.connection = this._borrowAConnection(hostIterator);
                _context6.next = 19;
                break;

              case 4:
                _context6.prev = 4;
                this.connection = this._borrowAConnection(hostIterator);
                _context6.next = 19;
                break;

              case 8:
                _context6.prev = 8;
                _context6.t0 = _context6["catch"](4);

                /* NODEJS-632: refresh nodes before getting hosts for reconnect since some hostnames may have
                 * shifted during the flight. */
                this.log("info", "ControlConnection could not reconnect using existing connections.  Refreshing contact points and retrying");

                this._contactPoints.clear();

                this._resolvedContactPoints.clear();

                _context6.next = 15;
                return Promise.all(this.options.contactPoints.map(function (name) {
                  return _this5._parseContactPoint(name);
                }));

              case 15:
                refreshedContactPoints = Array.from(this._contactPoints).join(',');
                this.log('info', "Refreshed contact points: ".concat(refreshedContactPoints));
                _context6.next = 19;
                return this._initializeConnection();

              case 19:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[4, 8]]);
      }));

      function _refreshControlConnection(_x6) {
        return _refreshControlConnection2.apply(this, arguments);
      }

      return _refreshControlConnection;
    }()
    /**
     * Acquires a new connection and refreshes topology and keyspace metadata.
     * <p>When it fails obtaining a connection and there aren't any more hosts, it schedules reconnection.</p>
     * <p>When it fails obtaining the metadata, it marks connection and/or host unusable and retries using the same
     * iterator from query plan / host list</p>
     * @param {Iterator<Host>} [hostIterator]
     */

  }, {
    key: "_refresh",
    value: function () {
      var _refresh2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(hostIterator) {
        var _this6 = this;

        var delay;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!this._isShuttingDown) {
                  _context7.next = 3;
                  break;
                }

                this.log('info', 'The ControlConnection will not be refreshed as the Client is being shutdown');
                return _context7.abrupt("return");

              case 3:
                // Reset host and connection
                this.host = null;
                this.connection = null;
                _context7.prev = 5;

                if (hostIterator) {
                  _context7.next = 12;
                  break;
                }

                this.log('info', 'Trying to acquire a connection to a new host');
                this._triedHosts = {};
                _context7.next = 11;
                return promiseUtils$4.newQueryPlan(this._profileManager.getDefaultLoadBalancing(), null, null);

              case 11:
                hostIterator = _context7.sent;

              case 12:
                _context7.next = 14;
                return this._refreshControlConnection(hostIterator);

              case 14:
                _context7.next = 21;
                break;

              case 16:
                _context7.prev = 16;
                _context7.t0 = _context7["catch"](5);
                // There was a failure obtaining a connection or during metadata retrieval
                this.log('error', 'ControlConnection failed to acquire a connection', _context7.t0);

                if (!this._isShuttingDown) {
                  delay = this._reconnectionSchedule.next().value;
                  this.log('warning', "ControlConnection could not reconnect, scheduling reconnection in ".concat(delay, "ms"));
                  setTimeout(function () {
                    return _this6._refresh();
                  }, delay);
                  this.emit('newConnection', _context7.t0);
                }

                return _context7.abrupt("return");

              case 21:
                this.log('info', "ControlConnection connected to ".concat(this.connection.endpointFriendlyName));
                _context7.prev = 22;
                _context7.next = 25;
                return this._refreshHosts(false, true);

              case 25:
                _context7.next = 27;
                return this._registerToConnectionEvents();

              case 27:
                _context7.next = 37;
                break;

              case 29:
                _context7.prev = 29;
                _context7.t1 = _context7["catch"](22);
                this.log('error', 'ControlConnection failed to retrieve topology and keyspaces information', _context7.t1);
                this._triedHosts[this.connection.endpoint] = _context7.t1;

                if (_context7.t1.isSocketError && this.host) {
                  this.host.removeFromPool(this.connection);
                } // Retry the whole thing with the same query plan


                _context7.next = 36;
                return this._refresh(hostIterator);

              case 36:
                return _context7.abrupt("return", _context7.sent);

              case 37:
                this._reconnectionSchedule = this._reconnectionPolicy.newSchedule();

                this._setHealthListeners(this.host, this.connection);

                this.emit('newConnection', null, this.connection, this.host);
                this.log('info', "ControlConnection connected to ".concat(this.connection.endpointFriendlyName, " and up to date"));

              case 41:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[5, 16], [22, 29]]);
      }));

      function _refresh(_x7) {
        return _refresh2.apply(this, arguments);
      }

      return _refresh;
    }()
    /**
     * Acquires a connection and refreshes topology and keyspace metadata for the first time.
     * @returns {Promise<void>}
     */

  }, {
    key: "_initializeConnection",
    value: function () {
      var _initializeConnection2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var contactPointsIterator;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this.log('info', 'Getting first connection'); // Reset host and connection

                this.host = null;
                this.connection = null;
                this._triedHosts = {}; // Randomize order of contact points resolved.

                contactPointsIterator = utils$g.shuffleArray(Array.from(this._contactPoints))[Symbol.iterator]();

              case 5:

                _context8.next = 8;
                return this._borrowFirstConnection(contactPointsIterator);

              case 8:
                this.log('info', "ControlConnection using protocol version 0x".concat(this.protocolVersion.toString(16), ", connected to ").concat(this.connection.endpointFriendlyName));
                _context8.prev = 9;
                _context8.next = 12;
                return this._getSupportedOptions();

              case 12:
                _context8.next = 14;
                return this._refreshHosts(true, true);

              case 14:
                _context8.next = 16;
                return this._registerToConnectionEvents();

              case 16:
                return _context8.abrupt("break", 25);

              case 19:
                _context8.prev = 19;
                _context8.t0 = _context8["catch"](9);
                this.log('error', 'ControlConnection failed to retrieve topology and keyspaces information', _context8.t0);
                this._triedHosts[this.connection.endpoint] = _context8.t0;

              case 23:
                _context8.next = 5;
                break;

              case 25:
                // The healthy connection used to initialize should be part of the Host pool
                this.host.pool.addExistingConnection(this.connection);
                this.initialized = true;

                this._setHealthListeners(this.host, this.connection);

                this.log('info', "ControlConnection connected to ".concat(this.connection.endpointFriendlyName));

              case 29:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[9, 19]]);
      }));

      function _initializeConnection() {
        return _initializeConnection2.apply(this, arguments);
      }

      return _initializeConnection;
    }()
  }, {
    key: "_getSupportedOptions",
    value: function () {
      var _getSupportedOptions2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var response, productType;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.connection.send(requests$3.options, null);

              case 2:
                response = _context9.sent;
                // response.supported is a string multi map, decoded as an Object.
                productType = response.supported && response.supported[supportedProductTypeKey];

                if (Array.isArray(productType) && productType[0] === supportedDbaas) {
                  this.metadata.setProductTypeAsDbaas();
                }

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _getSupportedOptions() {
        return _getSupportedOptions2.apply(this, arguments);
      }

      return _getSupportedOptions;
    }()
  }, {
    key: "_registerToConnectionEvents",
    value: function () {
      var _registerToConnectionEvents2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var request;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this.connection.on('nodeTopologyChange', this._nodeTopologyChangeHandler.bind(this));
                this.connection.on('nodeStatusChange', this._nodeStatusChangeHandler.bind(this));
                this.connection.on('nodeSchemaChange', this._nodeSchemaChangeHandler.bind(this));
                request = new requests$3.RegisterRequest(['TOPOLOGY_CHANGE', 'STATUS_CHANGE', 'SCHEMA_CHANGE']);
                _context10.next = 6;
                return this.connection.send(request, null);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function _registerToConnectionEvents() {
        return _registerToConnectionEvents2.apply(this, arguments);
      }

      return _registerToConnectionEvents;
    }()
    /**
     * Handles a TOPOLOGY_CHANGE event
     */

  }, {
    key: "_nodeTopologyChangeHandler",
    value: function _nodeTopologyChangeHandler(event) {
      var _this7 = this;

      this.log('info', 'Received topology change', event); // all hosts information needs to be refreshed as tokens might have changed

      clearTimeout(this._topologyChangeTimeout); // Use an additional timer to make sure that the refresh hosts is executed only AFTER the delay
      // In this case, the event debouncer doesn't help because it could not honor the sliding delay (ie: processNow)

      this._topologyChangeTimeout = setTimeout(function () {
        return promiseUtils$4.toBackground(_this7._scheduleRefreshHosts());
      }, newNodeDelay);
    }
    /**
     * Handles a STATUS_CHANGE event
     */

  }, {
    key: "_nodeStatusChangeHandler",
    value: function _nodeStatusChangeHandler(event) {
      var self = this;
      var addressToTranslate = event.inet.address.toString();
      var port = this.options.protocolOptions.port;

      this._addressTranslator.translate(addressToTranslate, port, function translateCallback(endPoint) {
        var host = self.hosts.get(endPoint);

        if (!host) {
          self.log('warning', 'Received status change event but host was not found: ' + addressToTranslate);
          return;
        }

        var distance = self._profileManager.getDistance(host);

        if (event.up) {
          if (distance === types$a.distance.ignored) {
            return host.setUp(true);
          }

          clearTimeout(self._nodeStatusChangeTimeout); // Waits a couple of seconds before marking it as UP

          self._nodeStatusChangeTimeout = setTimeout(function () {
            return host.checkIsUp();
          }, newNodeDelay);
          return;
        } // marked as down


        if (distance === types$a.distance.ignored) {
          return host.setDown();
        }

        self.log('warning', 'Received status change to DOWN for host ' + host.address);
      });
    }
    /**
     * Handles a SCHEMA_CHANGE event
     */

  }, {
    key: "_nodeSchemaChangeHandler",
    value: function _nodeSchemaChangeHandler(event) {
      this.log('info', 'Schema change', event);

      if (!this.options.isMetadataSyncEnabled) {
        return;
      }

      promiseUtils$4.toBackground(this.handleSchemaChange(event, false));
    }
    /**
     * Schedules metadata refresh and callbacks when is refreshed.
     * @param {{keyspace: string, isKeyspace: boolean, schemaChangeType, table, udt, functionName, aggregate}} event
     * @param {Boolean} processNow
     * @returns {Promise<void>}
     */

  }, {
    key: "handleSchemaChange",
    value: function handleSchemaChange(event, processNow) {
      var self = this;
      var handler, cqlObject;

      if (event.isKeyspace) {
        if (event.schemaChangeType === schemaChangeTypes.dropped) {
          handler = function removeKeyspace() {
            // if on the same event queue there is a creation, this handler is not going to be executed
            // it is safe to remove the keyspace metadata
            delete self.metadata.keyspaces[event.keyspace];
          };

          return this._scheduleObjectRefresh(handler, event.keyspace, null, processNow);
        }

        return this._scheduleKeyspaceRefresh(event.keyspace, processNow);
      }

      var ksInfo = this.metadata.keyspaces[event.keyspace];

      if (!ksInfo) {
        // it hasn't been loaded and it is not part of the metadata, don't mind
        return Promise.resolve();
      }

      if (event.table) {
        cqlObject = event.table;

        handler = function clearTableState() {
          delete ksInfo.tables[event.table];
          delete ksInfo.views[event.table];
        };
      } else if (event.udt) {
        cqlObject = event.udt;

        handler = function clearUdtState() {
          delete ksInfo.udts[event.udt];
        };
      } else if (event.functionName) {
        cqlObject = event.functionName;

        handler = function clearFunctionState() {
          delete ksInfo.functions[event.functionName];
        };
      } else if (event.aggregate) {
        cqlObject = event.aggregate;

        handler = function clearKeyspaceState() {
          delete ksInfo.aggregates[event.aggregate];
        };
      }

      if (!handler) {
        // Forward compatibility
        return Promise.resolve();
      } // It's a cql object change clean the internal cache


      return this._scheduleObjectRefresh(handler, event.keyspace, cqlObject, processNow);
    }
    /**
     * @param {Function} handler
     * @param {String} keyspace
     * @param {String} cqlObject
     * @param {Boolean} processNow
     * @returns {Promise<void>}
     */

  }, {
    key: "_scheduleObjectRefresh",
    value: function _scheduleObjectRefresh(handler, keyspace, cqlObject, processNow) {
      return this._debouncer.eventReceived({
        handler: handler,
        keyspace: keyspace,
        cqlObject: cqlObject
      }, processNow);
    }
    /**
     * @param {String} keyspace
     * @param {Boolean} processNow
     * @returns {Promise<void>}
     */

  }, {
    key: "_scheduleKeyspaceRefresh",
    value: function _scheduleKeyspaceRefresh(keyspace, processNow) {
      var _this8 = this;

      return this._debouncer.eventReceived({
        handler: function handler() {
          return _this8.metadata.refreshKeyspace(keyspace);
        },
        keyspace: keyspace
      }, processNow);
    }
    /** @returns {Promise<void>} */

  }, {
    key: "_scheduleRefreshHosts",
    value: function _scheduleRefreshHosts() {
      var _this9 = this;

      return this._debouncer.eventReceived({
        handler: function handler() {
          return _this9._refreshHosts(false, false);
        },
        all: true
      }, false);
    }
    /**
     * Sets the information for the host used by the control connection.
     * @param {Boolean} initializing
     * @param {Connection} c
     * @param {Boolean} setCurrentHost Determines if the host retrieved must be set as the current host
     * @param result
     */

  }, {
    key: "_setLocalInfo",
    value: function _setLocalInfo(initializing, setCurrentHost, c, result) {
      if (!result || !result.rows || !result.rows.length) {
        this.log('warning', 'No local info could be obtained');
        return;
      }

      var row = result.rows[0];
      var localHost; // Note that with SNI enabled, we can trust that rpc_address will contain a valid value.

      var endpoint = !this.options.sni ? c.endpoint : "".concat(row['rpc_address'], ":").concat(this.options.protocolOptions.port);

      if (initializing) {
        localHost = new Host(endpoint, this.protocolVersion, this.options, this.metadata);
        this.hosts.set(endpoint, localHost);
        this.log('info', "Adding host ".concat(endpoint));
      } else {
        localHost = this.hosts.get(endpoint);

        if (!localHost) {
          this.log('error', 'Localhost could not be found');
          return;
        }
      }

      localHost.datacenter = row['data_center'];
      localHost.rack = row['rack'];
      localHost.tokens = row['tokens'];
      localHost.hostId = row['host_id'];
      localHost.cassandraVersion = row['release_version'];
      setDseParameters(localHost, row);
      this.metadata.setPartitioner(row['partitioner']);
      this.log('info', 'Local info retrieved');

      if (setCurrentHost) {
        // Set the host as the one being used by the ControlConnection.
        this.host = localHost;
      }
    }
    /**
     * @param {Boolean} initializing Determines whether this function was called in order to initialize the control
     * connection the first time.
     * @param {ResultSet} result
     */

  }, {
    key: "setPeersInfo",
    value: function () {
      var _setPeersInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(initializing, result) {
        var _this10 = this;

        var peers, port, foundDataCenters, _iterator, _step, row, endpoint, host, isNewHost, toRemove, localDc;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(!result || !result.rows)) {
                  _context11.next = 2;
                  break;
                }

                return _context11.abrupt("return");

              case 2:
                // A map of peers, could useful for in case there are discrepancies
                peers = {};
                port = this.options.protocolOptions.port;
                foundDataCenters = new Set();

                if (this.host && this.host.datacenter) {
                  foundDataCenters.add(this.host.datacenter);
                }

                _iterator = _createForOfIteratorHelper(result.rows);
                _context11.prev = 7;

                _iterator.s();

              case 9:
                if ((_step = _iterator.n()).done) {
                  _context11.next = 30;
                  break;
                }

                row = _step.value;
                _context11.next = 13;
                return this.getAddressForPeerHost(row, port);

              case 13:
                endpoint = _context11.sent;

                if (endpoint) {
                  _context11.next = 16;
                  break;
                }

                return _context11.abrupt("continue", 28);

              case 16:
                peers[endpoint] = true;
                host = this.hosts.get(endpoint);
                isNewHost = !host;

                if (isNewHost) {
                  host = new Host(endpoint, this.protocolVersion, this.options, this.metadata);
                  this.log('info', "Adding host ".concat(endpoint));
                  isNewHost = true;
                }

                host.datacenter = row['data_center'];
                host.rack = row['rack'];
                host.tokens = row['tokens'];
                host.hostId = row['host_id'];
                host.cassandraVersion = row['release_version'];
                setDseParameters(host, row);

                if (host.datacenter) {
                  foundDataCenters.add(host.datacenter);
                }

                if (isNewHost) {
                  // Add it to the map (and trigger events) after all the properties
                  // were set to avoid race conditions
                  this.hosts.set(endpoint, host);

                  if (!initializing) {
                    // Set the distance at Host level, that way the connection pool is created with the correct settings
                    this._profileManager.getDistance(host); // When we are not initializing, we start with the node set as DOWN


                    host.setDown();
                  }
                }

              case 28:
                _context11.next = 9;
                break;

              case 30:
                _context11.next = 35;
                break;

              case 32:
                _context11.prev = 32;
                _context11.t0 = _context11["catch"](7);

                _iterator.e(_context11.t0);

              case 35:
                _context11.prev = 35;

                _iterator.f();

                return _context11.finish(35);

              case 38:
                // Is there a difference in number between peers + local != hosts
                if (this.hosts.length > result.rows.length + 1) {
                  // There are hosts in the current state that don't belong (nodes removed or wrong contactPoints)
                  this.log('info', 'Removing nodes from the pool');
                  toRemove = [];
                  this.hosts.forEach(function (h) {
                    //It is not a peer and it is not local host
                    if (!peers[h.address] && h !== _this10.host) {
                      _this10.log('info', 'Removing host ' + h.address);

                      toRemove.push(h.address);
                      h.shutdown(true);
                    }
                  });
                  this.hosts.removeMultiple(toRemove);
                }

                if (!(initializing && this.options.localDataCenter)) {
                  _context11.next = 43;
                  break;
                }

                localDc = this.options.localDataCenter;

                if (foundDataCenters.has(localDc)) {
                  _context11.next = 43;
                  break;
                }

                throw new errors$8.ArgumentError("localDataCenter was configured as '".concat(localDc, "', but only found hosts in data centers: [").concat(Array.from(foundDataCenters).join(', '), "]"));

              case 43:
                this.log('info', 'Peers info retrieved');

              case 44:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[7, 32, 35, 38]]);
      }));

      function setPeersInfo(_x8, _x9) {
        return _setPeersInfo.apply(this, arguments);
      }

      return setPeersInfo;
    }()
    /**
     * Gets the address from a peers row and translates the address.
     * @param {Object|Row} row
     * @param {Number} defaultPort
     * @returns {Promise<string>}
     */

  }, {
    key: "getAddressForPeerHost",
    value: function getAddressForPeerHost(row, defaultPort) {
      var _this11 = this;

      return new Promise(function (resolve) {
        var address = row['rpc_address'];
        var peer = row['peer'];
        var bindAllAddress = '0.0.0.0';

        if (!address) {
          _this11.log('error', f('No rpc_address found for host %s in %s\'s peers system table. %s will be ignored.', peer, _this11.host.address, peer));

          return resolve(null);
        }

        if (address.toString() === bindAllAddress) {
          _this11.log('warning', f('Found host with 0.0.0.0 as rpc_address, using listen_address (%s) to contact it instead.' + ' If this is incorrect you should avoid the use of 0.0.0.0 server side.', peer));

          address = peer;
        }

        _this11._addressTranslator.translate(address.toString(), defaultPort, resolve);
      });
    }
    /**
     * Uses the DNS protocol to resolve a IPv4 and IPv6 addresses (A and AAAA records) for the hostname.
     * It returns an Array of addresses that can be empty and logs the error.
     * @private
     * @param name
     */

  }, {
    key: "_resolveAll",
    value: function () {
      var _resolveAll2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(name) {
        var addresses, resolve4, resolve6, lookup, ipv4Promise, ipv6Promise, arr;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                addresses = [];
                resolve4 = util$7.promisify(dns.resolve4);
                resolve6 = util$7.promisify(dns.resolve6);
                lookup = util$7.promisify(dns.lookup); // Ignore errors for resolve calls

                ipv4Promise = resolve4(name)["catch"](function () {}).then(function (r) {
                  return r || utils$g.emptyArray;
                });
                ipv6Promise = resolve6(name)["catch"](function () {}).then(function (r) {
                  return r || utils$g.emptyArray;
                });
                _context12.next = 8;
                return ipv4Promise;

              case 8:
                arr = _context12.sent;
                arr.forEach(function (address) {
                  return addresses.push({
                    address: address,
                    isIPv6: false
                  });
                });
                _context12.next = 12;
                return ipv6Promise;

              case 12:
                arr = _context12.sent;
                arr.forEach(function (address) {
                  return addresses.push({
                    address: address,
                    isIPv6: true
                  });
                });

                if (!(addresses.length === 0)) {
                  _context12.next = 25;
                  break;
                }

                _context12.prev = 15;
                _context12.next = 18;
                return lookup(name, {
                  all: true
                });

              case 18:
                arr = _context12.sent;
                arr.forEach(function (_ref) {
                  var address = _ref.address,
                      family = _ref.family;
                  return addresses.push({
                    address: address,
                    isIPv6: family === 6
                  });
                });
                _context12.next = 25;
                break;

              case 22:
                _context12.prev = 22;
                _context12.t0 = _context12["catch"](15);
                this.log('error', "Host with name ".concat(name, " could not be resolved"), _context12.t0);

              case 25:
                return _context12.abrupt("return", addresses);

              case 26:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[15, 22]]);
      }));

      function _resolveAll(_x10) {
        return _resolveAll2.apply(this, arguments);
      }

      return _resolveAll;
    }()
    /**
     * Waits for a connection to be available. If timeout expires before getting a connection it callbacks in error.
     * @returns {Promise<void>}
     */

  }, {
    key: "_waitForReconnection",
    value: function _waitForReconnection() {
      var _this12 = this;

      return new Promise(function (resolve, reject) {
        var callback = promiseUtils$4.getCallback(resolve, reject); // eslint-disable-next-line prefer-const

        var timeout;

        function newConnectionListener(err) {
          clearTimeout(timeout);
          callback(err);
        }

        _this12.once('newConnection', newConnectionListener);

        timeout = setTimeout(function () {
          _this12.removeListener('newConnection', newConnectionListener);

          callback(new errors$8.OperationTimedOutError('A connection could not be acquired before timeout.'));
        }, metadataQueryAbortTimeout);
      });
    }
    /**
     * Executes a query using the active connection
     * @param {String|Request} cqlQuery
     * @param {Boolean} [waitReconnect] Determines if it should wait for reconnection in case the control connection is not
     * connected at the moment. Default: true.
     */

  }, {
    key: "query",
    value: function () {
      var _query = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(cqlQuery) {
        var _this13 = this;

        var waitReconnect,
            queryOnConnection,
            _args14 = arguments;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                waitReconnect = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : true;

                queryOnConnection = /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
                    var request;
                    return regeneratorRuntime.wrap(function _callee13$(_context13) {
                      while (1) {
                        switch (_context13.prev = _context13.next) {
                          case 0:
                            if (!(!_this13.connection || _this13._isShuttingDown)) {
                              _context13.next = 2;
                              break;
                            }

                            throw new errors$8.NoHostAvailableError({}, 'ControlConnection is not connected at the time');

                          case 2:
                            request = typeof cqlQuery === 'string' ? new requests$3.QueryRequest(cqlQuery, null, null) : cqlQuery;
                            _context13.next = 5;
                            return _this13.connection.send(request, null);

                          case 5:
                            return _context13.abrupt("return", _context13.sent);

                          case 6:
                          case "end":
                            return _context13.stop();
                        }
                      }
                    }, _callee13);
                  }));

                  return function queryOnConnection() {
                    return _ref2.apply(this, arguments);
                  };
                }();

                if (!(!this.connection && waitReconnect)) {
                  _context14.next = 5;
                  break;
                }

                _context14.next = 5;
                return this._waitForReconnection();

              case 5:
                _context14.next = 7;
                return queryOnConnection();

              case 7:
                return _context14.abrupt("return", _context14.sent);

              case 8:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function query(_x11) {
        return _query.apply(this, arguments);
      }

      return query;
    }()
    /** @returns {Encoder} The encoder used by the current connection */

  }, {
    key: "getEncoder",
    value: function getEncoder() {
      if (!this._encoder) {
        throw new errors$8.DriverInternalError('Encoder is not defined');
      }

      return this._encoder;
    }
    /**
     * Cancels all timers and shuts down synchronously.
     */

  }, {
    key: "shutdown",
    value: function shutdown() {
      this._isShuttingDown = true;

      this._debouncer.shutdown(); // Emit a "newConnection" event with Error, as it may clear timeouts that were waiting new connections


      this.emit('newConnection', new errors$8.DriverError('ControlConnection is being shutdown')); // Cancel timers

      clearTimeout(this._topologyChangeTimeout);
      clearTimeout(this._nodeStatusChangeTimeout);
    }
    /**
     * Resets the Connection to its initial state.
     */

  }, {
    key: "reset",
    value: function () {
      var _reset = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
        var currentHosts;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                // Reset the internal state of the ControlConnection for future initialization attempts
                currentHosts = this.hosts.clear(); // Set the shutting down flag temporarily to avoid reconnects.

                this._isShuttingDown = true; // Shutdown all individual pools, ignoring any shutdown error

                _context15.next = 4;
                return Promise.all(currentHosts.map(function (h) {
                  return h.shutdown();
                }));

              case 4:
                this.initialized = false;
                this._isShuttingDown = false;

              case 6:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function reset() {
        return _reset.apply(this, arguments);
      }

      return reset;
    }()
    /**
     * Gets a Map containing the original contact points and the addresses that each one resolved to.
     */

  }, {
    key: "getResolvedContactPoints",
    value: function getResolvedContactPoints() {
      return this._resolvedContactPoints;
    }
    /**
     * Gets the local IP address to which the control connection socket is bound to.
     * @returns {String|undefined}
     */

  }, {
    key: "getLocalAddress",
    value: function getLocalAddress() {
      if (!this.connection) {
        return undefined;
      }

      return this.connection.getLocalAddress();
    }
    /**
     * Gets the address and port of host the control connection is connected to.
     * @returns {String|undefined}
     */

  }, {
    key: "getEndpoint",
    value: function getEndpoint() {
      if (!this.connection) {
        return undefined;
      }

      return this.connection.endpoint;
    }
  }]);

  return ControlConnection;
}(events$1.EventEmitter);
/**
 * Parses the DSE workload and assigns it to a host.
 * @param {Host} host
 * @param {Row} row
 * @private
 */


function setDseParameters(host, row) {
  if (row['workloads'] !== undefined) {
    host.workloads = row['workloads'];
  } else if (row['workload']) {
    host.workloads = [row['workload']];
  } else {
    host.workloads = utils$g.emptyArray;
  }

  if (row['dse_version'] !== undefined) {
    host.dseVersion = row['dse_version'];
  }
}

var controlConnection = ControlConnection$1;

var errors$7 = errors$s;
var requests$2 = requests$7;
var retry = retry$2;
var types$9 = types$u;
var utils$f = utils$V;
var promiseUtils$3 = promiseUtils$e;
var retryOnCurrentHost = Object.freeze({
  decision: retry.RetryPolicy.retryDecision.retry,
  useCurrentHost: true,
  consistency: undefined
});
var rethrowDecision = Object.freeze({
  decision: retry.RetryPolicy.retryDecision.rethrow
});
/**
 * An internal representation of an error that occurred during the execution of a request.
 */

var errorCodes = {
  none: 0,
  // Socket error
  socketError: 1,
  // Socket error before the request was written to the wire
  socketErrorBeforeRequestWritten: 2,
  // OperationTimedOutError
  clientTimeout: 3,
  // Response error "unprepared"
  serverErrorUnprepared: 4,
  // Response error "overloaded", "is_bootstrapping" and "truncateError":
  serverErrorOverloaded: 5,
  serverErrorReadTimeout: 6,
  serverErrorUnavailable: 7,
  serverErrorWriteTimeout: 8,
  // Any other server error (different from the ones detailed above)
  serverErrorOther: 9
};
var metricsHandlers = new Map([[errorCodes.none, function (metrics, err, latency) {
  return metrics.onSuccessfulResponse(latency);
}], [errorCodes.socketError, function (metrics, err) {
  return metrics.onConnectionError(err);
}], [errorCodes.clientTimeout, function (metrics, err) {
  return metrics.onClientTimeoutError(err);
}], [errorCodes.serverErrorOverloaded, function (metrics, err) {
  return metrics.onOtherError(err);
}], [errorCodes.serverErrorReadTimeout, function (metrics, err) {
  return metrics.onReadTimeoutError(err);
}], [errorCodes.serverErrorUnavailable, function (metrics, err) {
  return metrics.onUnavailableError(err);
}], [errorCodes.serverErrorWriteTimeout, function (metrics, err) {
  return metrics.onWriteTimeoutError(err);
}], [errorCodes.serverErrorOther, function (metrics, err) {
  return metrics.onOtherError(err);
}]]);
var metricsRetryHandlers = new Map([[errorCodes.socketError, function (metrics, err) {
  return metrics.onOtherErrorRetry(err);
}], [errorCodes.clientTimeout, function (metrics, err) {
  return metrics.onClientTimeoutRetry(err);
}], [errorCodes.serverErrorOverloaded, function (metrics, err) {
  return metrics.onOtherErrorRetry(err);
}], [errorCodes.serverErrorReadTimeout, function (metrics, err) {
  return metrics.onReadTimeoutRetry(err);
}], [errorCodes.serverErrorUnavailable, function (metrics, err) {
  return metrics.onUnavailableRetry(err);
}], [errorCodes.serverErrorWriteTimeout, function (metrics, err) {
  return metrics.onWriteTimeoutRetry(err);
}], [errorCodes.serverErrorOther, function (metrics, err) {
  return metrics.onOtherErrorRetry(err);
}]]);

var RequestExecution$1 = /*#__PURE__*/function () {
  /**
   * Encapsulates a single flow of execution against a coordinator, handling individual retries and failover.
   * @param {RequestHandler!} parent
   * @param {Host!} host
   * @param {Connection!} connection
   */
  function RequestExecution(parent, host, connection) {
    _classCallCheck(this, RequestExecution);

    this._parent = parent;
    /** @type {OperationState} */

    this._operation = null;
    this._host = host;
    this._connection = connection;
    this._cancelled = false;
    this._startTime = null;
    this._retryCount = 0; // The streamId information is not included in the request.
    // A pointer to the parent request can be used, except when changing the consistency level from the retry policy

    this._request = this._parent.request; // Mark that it launched a new execution

    parent.speculativeExecutions++;
  }
  /**
   * Sends the request using the active connection.
   */


  _createClass(RequestExecution, [{
    key: "start",
    value: function start() {
      this._sendOnConnection();
    }
    /**
     * Borrows the next connection available using the query plan and sends the request.
     * @returns {Promise<void>}
     */

  }, {
    key: "restart",
    value: function () {
      var _restart = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this$_parent$getNext, host, connection, keyspace;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _this$_parent$getNext = this._parent.getNextConnection(), host = _this$_parent$getNext.host, connection = _this$_parent$getNext.connection;
                this._connection = connection;
                this._host = host;
                _context.next = 9;
                break;

              case 6:
                _context.prev = 6;
                _context.t0 = _context["catch"](0);
                return _context.abrupt("return", this._parent.handleNoHostAvailable(_context.t0, this));

              case 9:
                // It could be a new connection from the pool, we should make sure it's in the correct keyspace.
                keyspace = this._parent.client.keyspace;

                if (!(keyspace && keyspace !== this._connection.keyspace)) {
                  _context.next = 19;
                  break;
                }

                _context.prev = 11;
                _context.next = 14;
                return this._connection.changeKeyspace(keyspace);

              case 14:
                _context.next = 19;
                break;

              case 16:
                _context.prev = 16;
                _context.t1 = _context["catch"](11);
                return _context.abrupt("return", this._handleError(_context.t1, RequestExecution._getErrorCode(_context.t1)));

              case 19:
                if (!this._cancelled) {
                  _context.next = 21;
                  break;
                }

                return _context.abrupt("return");

              case 21:
                this._sendOnConnection();

              case 22:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 6], [11, 16]]);
      }));

      function restart() {
        return _restart.apply(this, arguments);
      }

      return restart;
    }()
    /**
     * Sends the request using the active connection.
     * @private
     */

  }, {
    key: "_sendOnConnection",
    value: function _sendOnConnection() {
      var _this = this;

      this._startTime = process.hrtime();
      this._operation = this._connection.sendStream(this._request, this._parent.executionOptions, function (err, response, length) {
        var errorCode = RequestExecution._getErrorCode(err);

        _this._trackResponse(process.hrtime(_this._startTime), errorCode, err, length);

        if (_this._cancelled) {
          // Avoid handling the response / err
          return;
        }

        if (errorCode !== errorCodes.none) {
          return _this._handleError(errorCode, err);
        }

        if (response.schemaChange) {
          return promiseUtils$3.toBackground(_this._parent.client.handleSchemaAgreementAndRefresh(_this._connection, response.schemaChange).then(function (agreement) {
            if (_this._cancelled) {
              // After the schema agreement method was started, this execution was cancelled
              return;
            }

            _this._parent.setCompleted(null, _this._getResultSet(response, agreement));
          }));
        }

        if (response.keyspaceSet) {
          _this._parent.client.keyspace = response.keyspaceSet;
        }

        if (response.meta && response.meta.newResultId && _this._request.queryId) {
          // Update the resultId on the existing prepared statement.
          // Eventually would want to update the result metadata as well (NODEJS-433)
          var info = _this._parent.client.metadata.getPreparedById(_this._request.queryId);

          info.meta.resultId = response.meta.newResultId;
        }

        _this._parent.setCompleted(null, _this._getResultSet(response));
      });
    }
  }, {
    key: "_trackResponse",
    value: function _trackResponse(latency, errorCode, err, length) {
      // Record metrics
      RequestExecution._invokeMetricsHandler(errorCode, this._parent.client.metrics, err, latency); // Request tracker


      var tracker = this._parent.client.options.requestTracker;

      if (tracker === null) {
        return;
      } // Avoid using instanceof as property check is faster


      var query = this._request.query || this._request.queries;
      var parameters = this._request.params;
      var requestLength = this._request.length;

      if (err) {
        tracker.onError(this._host, query, parameters, this._parent.executionOptions, requestLength, err, latency);
      } else {
        tracker.onSuccess(this._host, query, parameters, this._parent.executionOptions, requestLength, length, latency);
      }
    }
  }, {
    key: "_getResultSet",
    value: function _getResultSet(response, agreement) {
      var rs = new types$9.ResultSet(response, this._host.address, this._parent.triedHosts, this._parent.speculativeExecutions, this._request.consistency, agreement === undefined || agreement);

      if (rs.rawPageState) {
        rs.nextPageAsync = this._parent.getNextPageHandler();
      }

      return rs;
    }
    /**
     * Gets the method of the {ClientMetrics} instance depending on the error code and invokes it.
     * @param {Number} errorCode
     * @param {ClientMetrics} metrics
     * @param {Error} err
     * @param {Array} latency
     * @private
     */

  }, {
    key: "cancel",
    value:
    /**
     * Allows the handler to cancel the current request.
     * When the request has been already written, we can unset the callback and forget about it.
     */
    function cancel() {
      this._cancelled = true;

      if (this._operation === null) {
        return;
      }

      this._operation.cancel();
    }
    /**
     * Determines if the current execution was cancelled.
     */

  }, {
    key: "wasCancelled",
    value: function wasCancelled() {
      return this._cancelled;
    }
  }, {
    key: "_handleError",
    value: function _handleError(errorCode, err) {
      this._parent.triedHosts[this._host.address] = err;
      err['coordinator'] = this._host.address;

      if (errorCode === errorCodes.serverErrorUnprepared) {
        return this._prepareAndRetry(err.queryId);
      }

      if (errorCode === errorCodes.socketError || errorCode === errorCodes.socketErrorBeforeRequestWritten) {
        this._host.removeFromPool(this._connection);
      } else if (errorCode === errorCodes.clientTimeout) {
        this._parent.log('warning', err.message);

        this._host.checkHealth(this._connection);
      }

      var decisionInfo = this._getDecision(errorCode, err);

      if (!decisionInfo || decisionInfo.decision === retry.RetryPolicy.retryDecision.rethrow) {
        if (this._request instanceof requests$2.QueryRequest || this._request instanceof requests$2.ExecuteRequest) {
          err['query'] = this._request.query;
        }

        return this._parent.setCompleted(err);
      }

      var metrics = this._parent.client.metrics;

      if (decisionInfo.decision === retry.RetryPolicy.retryDecision.ignore) {
        metrics.onIgnoreError(err); // Return an empty ResultSet

        return this._parent.setCompleted(null, this._getResultSet(utils$f.emptyObject));
      }

      RequestExecution._invokeMetricsHandlerForRetry(errorCode, metrics, err);

      return this._retry(decisionInfo.consistency, decisionInfo.useCurrentHost);
    }
    /**
     * Gets a decision whether or not to retry based on the error information.
     * @param {Number} errorCode
     * @param {Error} err
     * @returns {{decision, useCurrentHost, consistency}}
     */

  }, {
    key: "_getDecision",
    value: function _getDecision(errorCode, err) {
      var operationInfo = {
        query: this._request && this._request.query,
        executionOptions: this._parent.executionOptions,
        nbRetry: this._retryCount
      };
      var retryPolicy = operationInfo.executionOptions.getRetryPolicy();

      switch (errorCode) {
        case errorCodes.socketErrorBeforeRequestWritten:
          // The request was definitely not applied, it's safe to retry.
          // Retry on the current host as there might be other connections open, in case it fails to obtain a connection
          // on the current host, the driver will immediately retry on the next host.
          return retryOnCurrentHost;

        case errorCodes.socketError:
        case errorCodes.clientTimeout:
        case errorCodes.serverErrorOverloaded:
          if (operationInfo.executionOptions.isIdempotent()) {
            return retryPolicy.onRequestError(operationInfo, this._request.consistency, err);
          }

          return rethrowDecision;

        case errorCodes.serverErrorUnavailable:
          return retryPolicy.onUnavailable(operationInfo, err.consistencies, err.required, err.alive);

        case errorCodes.serverErrorReadTimeout:
          return retryPolicy.onReadTimeout(operationInfo, err.consistencies, err.received, err.blockFor, err.isDataPresent);

        case errorCodes.serverErrorWriteTimeout:
          if (operationInfo.executionOptions.isIdempotent()) {
            return retryPolicy.onWriteTimeout(operationInfo, err.consistencies, err.received, err.blockFor, err.writeType);
          }

          return rethrowDecision;

        default:
          return rethrowDecision;
      }
    }
  }, {
    key: "_retry",
    value:
    /**
     * @param {Number|undefined} consistency
     * @param {Boolean} useCurrentHost
     * @param {Object} [meta]
     * @private
     */
    function _retry(consistency, useCurrentHost, meta) {
      if (this._cancelled) {
        // No point in retrying
        return;
      }

      this._parent.log('info', 'Retrying request');

      this._retryCount++;

      if (meta || typeof consistency === 'number' && this._request.consistency !== consistency) {
        this._request = this._request.clone();

        if (typeof consistency === 'number') {
          this._request.consistency = consistency;
        } // possible that we are retrying because we had to reprepare.  In this case it is also possible
        // that our known metadata had changed, therefore we update it on the request.


        if (meta) {
          this._request.meta = meta;
        }
      }

      if (useCurrentHost !== false) {
        // Reusing the existing connection is suitable for the most common scenarios, like server read timeouts that
        // will be fixed with a new request.
        // To cover all scenarios (e.g., where a different connection to the same host might mean something different),
        // we obtain a new connection from the host pool.
        // When there was a socket error, the connection provided was already removed from the pool earlier.
        try {
          this._connection = this._host.borrowConnection(this._connection);
        } catch (err) {
          // All connections are busy (`BusyConnectionError`) or there isn't a ready connection in the pool (`Error`)
          // The retry policy declared the intention to retry on the current host but its not available anymore.
          // Use the next host
          return promiseUtils$3.toBackground(this.restart());
        }

        return this._sendOnConnection();
      } // Use the next host in the query plan to send the request in the background


      promiseUtils$3.toBackground(this.restart());
    }
    /**
     * Issues a PREPARE request on the current connection.
     * If there's a socket or timeout issue, it moves to next host and executes the original request.
     * @param {Buffer} queryId
     * @private
     */

  }, {
    key: "_prepareAndRetry",
    value: function _prepareAndRetry(queryId) {
      var connection = this._connection;

      this._parent.log('info', "Query 0x".concat(queryId.toString('hex'), " not prepared on") + " host ".concat(connection.endpointFriendlyName, ", preparing and retrying"));

      var info = this._parent.client.metadata.getPreparedById(queryId);

      if (!info) {
        return this._parent.setCompleted(new errors$7.DriverInternalError("Unprepared response invalid, id: 0x".concat(queryId.toString('hex'))));
      }

      var version = this._connection.protocolVersion;

      if (!types$9.protocolVersion.supportsKeyspaceInRequest(version) && info.keyspace && info.keyspace !== connection.keyspace) {
        return this._parent.setCompleted(new Error("Query was prepared on keyspace ".concat(info.keyspace, ", can't execute it on ").concat(connection.keyspace, " (").concat(info.query, ")")));
      }

      var self = this;

      this._connection.prepareOnce(info.query, info.keyspace, function (err, result) {
        if (err) {
          if (!err.isSocketError && err instanceof errors$7.OperationTimedOutError) {
            self._parent.log('warning', "Unexpected timeout error when re-preparing query on host ".concat(connection.endpointFriendlyName));
          } // There was a failure re-preparing on this connection.
          // Execute the original request on the next connection and forget about the PREPARE-UNPREPARE flow.


          return self._retry(undefined, false);
        } // It's possible that when re-preparing we got new metadata (i.e. if schema changed), update cache.


        info.meta = result.meta; // pass the metadata so it can be used in retry.

        self._retry(undefined, true, result.meta);
      });
    }
  }], [{
    key: "_invokeMetricsHandler",
    value: function _invokeMetricsHandler(errorCode, metrics, err, latency) {
      var handler = metricsHandlers.get(errorCode);

      if (handler !== undefined) {
        handler(metrics, err, latency);
      }

      if (!err || err instanceof errors$7.ResponseError) {
        metrics.onResponse(latency);
      }
    }
    /**
     * Gets the method of the {ClientMetrics} instance related to retry depending on the error code and invokes it.
     * @param {Number} errorCode
     * @param {ClientMetrics} metrics
     * @param {Error} err
     * @private
     */

  }, {
    key: "_invokeMetricsHandlerForRetry",
    value: function _invokeMetricsHandlerForRetry(errorCode, metrics, err) {
      var handler = metricsRetryHandlers.get(errorCode);

      if (handler !== undefined) {
        handler(metrics, err);
      }
    }
  }, {
    key: "_getErrorCode",
    value: function _getErrorCode(err) {
      if (!err) {
        return errorCodes.none;
      }

      if (err.isSocketError) {
        if (err.requestNotWritten) {
          return errorCodes.socketErrorBeforeRequestWritten;
        }

        return errorCodes.socketError;
      }

      if (err instanceof errors$7.OperationTimedOutError) {
        return errorCodes.clientTimeout;
      }

      if (err instanceof errors$7.ResponseError) {
        switch (err.code) {
          case types$9.responseErrorCodes.overloaded:
          case types$9.responseErrorCodes.isBootstrapping:
          case types$9.responseErrorCodes.truncateError:
            return errorCodes.serverErrorOverloaded;

          case types$9.responseErrorCodes.unavailableException:
            return errorCodes.serverErrorUnavailable;

          case types$9.responseErrorCodes.readTimeout:
            return errorCodes.serverErrorReadTimeout;

          case types$9.responseErrorCodes.writeTimeout:
            return errorCodes.serverErrorWriteTimeout;

          case types$9.responseErrorCodes.unprepared:
            return errorCodes.serverErrorUnprepared;
        }
      }

      return errorCodes.serverErrorOther;
    }
  }]);

  return RequestExecution;
}();

var requestExecution = RequestExecution$1;

var util$6 = require$$0__default$1["default"];
var errors$6 = errors$s;
var types$8 = types$u;
var utils$e = utils$V;
var RequestExecution = requestExecution;
var promiseUtils$2 = promiseUtils$e;
/**
 * Handles a BATCH, QUERY and EXECUTE request to the server, dealing with host fail-over and retries on error
 */

var RequestHandler$1 = /*#__PURE__*/function () {
  /**
   * Creates a new instance of RequestHandler.
   * @param {Request} request
   * @param {ExecutionOptions} execOptions
   * @param {Client} client Client instance used to retrieve and set the keyspace.
   */
  function RequestHandler(request, execOptions, client) {
    _classCallCheck(this, RequestHandler);

    this.client = client;
    this._speculativeExecutionPlan = client.options.policies.speculativeExecution.newPlan(client.keyspace, request.query || request.queries);
    this.logEmitter = client.options.logEmitter;
    this.log = utils$e.log;
    this.request = request;
    this.executionOptions = execOptions;
    this.stackContainer = null;
    this.triedHosts = {}; // start at -1 as first request does not count.

    this.speculativeExecutions = -1;
    this._hostIterator = null;
    this._resolveCallback = null;
    this._rejectCallback = null;
    this._newExecutionTimeout = null;
    /** @type {RequestExecution[]} */

    this._executions = [];
  }
  /**
   * Sends a new BATCH, QUERY or EXECUTE request.
   * @param {Request} request
   * @param {ExecutionOptions} execOptions
   * @param {Client} client Client instance used to retrieve and set the keyspace.
   * @returns {Promise<ResultSet>}
   */


  _createClass(RequestHandler, [{
    key: "getNextConnection",
    value:
    /**
     * Gets a connection from the next host according to the query plan or throws a NoHostAvailableError.
     * @returns {{host, connection}}
     * @throws {NoHostAvailableError}
     */
    function getNextConnection() {
      var host;
      var connection;
      var iterator = this._hostIterator; // Get a host that is UP in a sync loop

      while (true) {
        var item = iterator.next();

        if (item.done) {
          throw new errors$6.NoHostAvailableError(this.triedHosts);
        }

        host = item.value; // Set the distance relative to the client first

        var distance = this.client.profileManager.getDistance(host);

        if (distance === types$8.distance.ignored) {
          //If its marked as ignore by the load balancing policy, move on.
          continue;
        }

        if (!host.isUp()) {
          this.triedHosts[host.address] = 'Host considered as DOWN';
          continue;
        }

        try {
          connection = host.borrowConnection();
          this.triedHosts[host.address] = null;
          break;
        } catch (err) {
          this.triedHosts[host.address] = err;
        }
      }

      return {
        connection: connection,
        host: host
      };
    }
    /**
     * Gets an available connection and sends the request
     * @returns {Promise<ResultSet>}
     */

  }, {
    key: "send",
    value: function send() {
      var _this = this;

      if (this.executionOptions.getCaptureStackTrace()) {
        Error.captureStackTrace(this.stackContainer = {});
      }

      return new Promise(function (resolve, reject) {
        _this._resolveCallback = resolve;
        _this._rejectCallback = reject;

        var lbp = _this.executionOptions.getLoadBalancingPolicy();

        var fixedHost = _this.executionOptions.getFixedHost();

        if (fixedHost) {
          // if host is configured bypass load balancing policy and use
          // a single host plan.
          _this._hostIterator = utils$e.arrayIterator([fixedHost]);
          promiseUtils$2.toBackground(_this._startNewExecution());
        } else {
          lbp.newQueryPlan(_this.client.keyspace, _this.executionOptions, function (err, iterator) {
            if (err) {
              return reject(err);
            }

            _this._hostIterator = iterator;
            promiseUtils$2.toBackground(_this._startNewExecution());
          });
        }
      });
    }
    /**
     * Starts a new execution on the next host of the query plan.
     * @param {Boolean} [isSpecExec]
     * @returns {Promise<void>}
     * @private
     */

  }, {
    key: "_startNewExecution",
    value: function () {
      var _startNewExecution2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(isSpecExec) {
        var host, connection, _this$getNextConnecti, execution;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (isSpecExec) {
                  this.client.metrics.onSpeculativeExecution();
                }

                _context.prev = 1;
                _this$getNextConnecti = this.getNextConnection();
                host = _this$getNextConnecti.host;
                connection = _this$getNextConnecti.connection;
                _context.next = 10;
                break;

              case 7:
                _context.prev = 7;
                _context.t0 = _context["catch"](1);
                return _context.abrupt("return", this.handleNoHostAvailable(_context.t0, null));

              case 10:
                if (!(isSpecExec && this._executions.length >= 0 && this._executions[0].wasCancelled())) {
                  _context.next = 12;
                  break;
                }

                return _context.abrupt("return");

              case 12:
                if (!(this.client.keyspace && this.client.keyspace !== connection.keyspace)) {
                  _context.next = 22;
                  break;
                }

                _context.prev = 13;
                _context.next = 16;
                return connection.changeKeyspace(this.client.keyspace);

              case 16:
                _context.next = 22;
                break;

              case 18:
                _context.prev = 18;
                _context.t1 = _context["catch"](13);
                this.triedHosts[host.address] = _context.t1; // The error occurred asynchronously
                // We can blindly re-try to obtain a different host/connection.

                return _context.abrupt("return", this._startNewExecution(isSpecExec));

              case 22:
                execution = new RequestExecution(this, host, connection);

                this._executions.push(execution);

                execution.start();

                if (this.executionOptions.isIdempotent()) {
                  this._scheduleSpeculativeExecution(host);
                }

              case 26:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 7], [13, 18]]);
      }));

      function _startNewExecution(_x) {
        return _startNewExecution2.apply(this, arguments);
      }

      return _startNewExecution;
    }()
    /**
     * Schedules next speculative execution, if any.
     * @param {Host!} host
     * @private
     */

  }, {
    key: "_scheduleSpeculativeExecution",
    value: function _scheduleSpeculativeExecution(host) {
      var _this2 = this;

      var delay = this._speculativeExecutionPlan.nextExecution(host);

      if (typeof delay !== 'number' || delay < 0) {
        return;
      }

      if (delay === 0) {
        // Parallel speculative execution
        return process.nextTick(function () {
          promiseUtils$2.toBackground(_this2._startNewExecution(true));
        });
      } // Create timer for speculative execution


      this._newExecutionTimeout = setTimeout(function () {
        return promiseUtils$2.toBackground(_this2._startNewExecution(true));
      }, delay);
    }
    /**
     * Sets the keyspace in any connection that is already opened.
     * @param {Client} client
     * @returns {Promise}
     */

  }, {
    key: "setCompleted",
    value:
    /**
     * @param {Error} err
     * @param {ResultSet} [result]
     */
    function setCompleted(err, result) {
      if (this._newExecutionTimeout !== null) {
        clearTimeout(this._newExecutionTimeout);
      } // Mark all executions as cancelled


      var _iterator = _createForOfIteratorHelper(this._executions),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var execution = _step.value;
          execution.cancel();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (err) {
        if (this.executionOptions.getCaptureStackTrace()) {
          utils$e.fixStack(this.stackContainer.stack, err);
        } // Reject the promise


        return this._rejectCallback(err);
      }

      if (result.info.warnings) {
        // Log the warnings from the response
        result.info.warnings.forEach(function (message, i, warnings) {
          this.log('warning', util$6.format('Received warning (%d of %d) "%s" for "%s"', i + 1, warnings.length, message, this.request.query || 'batch'));
        }, this);
      } // We used to invoke the callback on next tick to allow stack unwinding and prevent the optimizing compiler to
      // optimize read and write functions together.
      // As we are resolving a Promise then() and catch() are always scheduled in the microtask queue
      // We can invoke the resolve method directly.


      this._resolveCallback(result);
    }
    /**
     * @param {NoHostAvailableError} err
     * @param {RequestExecution|null} execution
     */

  }, {
    key: "handleNoHostAvailable",
    value: function handleNoHostAvailable(err, execution) {
      if (execution !== null) {
        // Remove the execution
        var index = this._executions.indexOf(execution);

        this._executions.splice(index, 1);
      }

      if (this._executions.length === 0) {
        // There aren't any other executions, we should report back to the user that there isn't
        // a host available for executing the request
        this.setCompleted(err);
      }
    }
    /**
     * Gets a long lived closure that can fetch the next page.
     * @returns {Function}
     */

  }, {
    key: "getNextPageHandler",
    value: function getNextPageHandler() {
      var request = this.request;
      var execOptions = this.executionOptions;
      var client = this.client;
      return function nextPageHandler(pageState) {
        execOptions.setPageState(pageState);
        return new RequestHandler(request, execOptions, client).send();
      };
    }
  }], [{
    key: "send",
    value: function send(request, execOptions, client) {
      var instance = new RequestHandler(request, execOptions, client);
      return instance.send();
    }
  }, {
    key: "setKeyspace",
    value: function setKeyspace(client) {
      var connection;

      var _iterator2 = _createForOfIteratorHelper(client.hosts.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var host = _step2.value;
          connection = host.getActiveConnection();

          if (connection) {
            break;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      if (!connection) {
        throw new errors$6.DriverInternalError('No active connection found');
      }

      return connection.changeKeyspace(client.keyspace);
    }
  }]);

  return RequestHandler;
}();

var requestHandler = RequestHandler$1;

var os = require$$0__default$7["default"];
var path = require$$1__default$1["default"];
var fs$2 = require$$0__default$6["default"];
var utils$d = utils$V;
var promiseUtils$1 = promiseUtils$e;
var types$7 = types$u;
var requests$1 = requests$7;
var ExecutionOptions = executionOptions.ExecutionOptions;
var packageInfo = require$$17;
var VersionNumber = versionNumber;
var NoAuthProvider$1 = auth$1.NoAuthProvider;
var kerberosModule;

try {
  // eslint-disable-next-line
  kerberosModule = require('kerberos');
} catch (err) {// Kerberos is an optional dependency
}

var minDse6Version = new VersionNumber(6, 0, 5);
var minDse51Version = new VersionNumber(5, 1, 13);
var dse600Version = new VersionNumber(6, 0, 0);
var rpc = "CALL InsightsRpc.reportInsight(?)";
var maxStatusErrorLogs = 5;
/**
 * Contains methods and functionality to send events to DSE Insights.
 */

var InsightsClient$1 = /*#__PURE__*/function () {
  /**
   * Creates a new instance of the {@link InsightsClient} using the driver {@link Client}.
   * @param {Client} client
   * @param {Object} [options]
   * @param {Number} [options.statusEventDelay]
   * @param {Function} [options.errorCallback]
   */
  function InsightsClient(client, options) {
    _classCallCheck(this, InsightsClient);

    this._client = client;
    this._sessionId = types$7.Uuid.random().toString();
    this._enabled = false;
    this._closed = false;
    this._firstTimeout = null;
    this._recurrentTimeout = null;
    this._statusErrorLogs = 0;
    options = options || {};
    this._statusEventDelay = options.statusEventDelay || 300000;
    this._errorCallback = options.errorCallback || utils$d.noop;
  }
  /**
   * Initializes the insights client in the background by sending the startup event and scheduling status events at
   * regular intervals.
   * @returns {undefined}
   */


  _createClass(InsightsClient, [{
    key: "init",
    value: function init() {
      this._enabled = this._client.options.monitorReporting.enabled && this._dseSupportsInsights();

      if (!this._enabled) {
        return;
      }

      promiseUtils$1.toBackground(this._init());
    }
  }, {
    key: "_init",
    value: function () {
      var _init2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this = this;

        var firstDelay;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return this._sendStartupEvent();

              case 3:
                if (!this._closed) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return");

              case 5:
                // Send the status event the first time with a delay containing some random portion
                // Initial delay should be statusEventDelay - (0 to 10%)
                firstDelay = Math.floor(this._statusEventDelay - 0.1 * this._statusEventDelay * Math.random()); // Schedule the first timer

                this._firstTimeout = setTimeout(function () {
                  // Send the first status event, the promise will never be rejected
                  _this._sendStatusEvent(); // The following status events are sent at regular intervals


                  _this._recurrentTimeout = setInterval(function () {
                    return _this._sendStatusEvent();
                  }, _this._statusEventDelay);
                }, firstDelay);
                _context.next = 15;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](0);

                if (!this._closed) {
                  _context.next = 13;
                  break;
                }

                return _context.abrupt("return");

              case 13:
                // We shouldn't try to recover
                this._client.log('verbose', "Insights startup message could not be sent (".concat(_context.t0, ")"), _context.t0);

                this._errorCallback(_context.t0);

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 9]]);
      }));

      function _init() {
        return _init2.apply(this, arguments);
      }

      return _init;
    }()
    /**
     * Sends the startup event.
     * @returns {Promise}
     * @private
     */

  }, {
    key: "_sendStartupEvent",
    value: function () {
      var _sendStartupEvent2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var message, request;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._getStartupMessage();

              case 2:
                message = _context2.sent;
                request = new requests$1.QueryRequest(rpc, [message], ExecutionOptions.empty());
                _context2.next = 6;
                return this._client.controlConnection.query(request, false);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _sendStartupEvent() {
        return _sendStartupEvent2.apply(this, arguments);
      }

      return _sendStartupEvent;
    }()
    /**
     * Sends the status event.
     * @returns {Promise} A promise that is never rejected.
     * @private
     */

  }, {
    key: "_sendStatusEvent",
    value: function () {
      var _sendStatusEvent2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var request;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                request = new requests$1.QueryRequest(rpc, [this._getStatusEvent()], ExecutionOptions.empty());
                _context3.prev = 1;
                _context3.next = 4;
                return this._client.controlConnection.query(request, false);

              case 4:
                _context3.next = 12;
                break;

              case 6:
                _context3.prev = 6;
                _context3.t0 = _context3["catch"](1);

                if (!this._closed) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt("return");

              case 10:
                if (this._statusErrorLogs < maxStatusErrorLogs) {
                  this._client.log('warning', "Insights status message could not be sent (".concat(_context3.t0, ")"), _context3.t0);

                  this._statusErrorLogs++;
                }

                this._errorCallback(_context3.t0);

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[1, 6]]);
      }));

      function _sendStatusEvent() {
        return _sendStatusEvent2.apply(this, arguments);
      }

      return _sendStatusEvent;
    }()
    /**
     * Validates the minimum server version for all nodes in the cluster.
     * @private
     */

  }, {
    key: "_dseSupportsInsights",
    value: function _dseSupportsInsights() {
      if (this._client.hosts.length === 0) {
        return false;
      }

      return this._client.hosts.values().reduce(function (acc, host) {
        if (!acc) {
          return acc;
        }

        var versionArr = host.getDseVersion();

        if (versionArr.length === 0) {
          return false;
        }

        var version = _construct(VersionNumber, _toConsumableArray(versionArr));

        return version.compare(minDse6Version) >= 0 || version.compare(dse600Version) < 0 && version.compare(minDse51Version) >= 0;
      }, true);
    }
    /**
     * @returns {Promise<String>} Returns a json string with the startup message.
     * @private
     */

  }, {
    key: "_getStartupMessage",
    value: function () {
      var _getStartupMessage2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var cc, options, appInfo, message;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                cc = this._client.controlConnection;
                options = this._client.options;
                _context4.next = 4;
                return this._getAppInfo(options);

              case 4:
                appInfo = _context4.sent;
                message = {
                  metadata: {
                    name: 'driver.startup',
                    insightMappingId: 'v1',
                    insightType: 'EVENT',
                    timestamp: Date.now(),
                    tags: {
                      language: 'nodejs'
                    }
                  },
                  data: {
                    driverName: packageInfo.description,
                    driverVersion: packageInfo.version,
                    clientId: options.id,
                    sessionId: this._sessionId,
                    applicationName: appInfo.applicationName,
                    applicationVersion: appInfo.applicationVersion,
                    applicationNameWasGenerated: appInfo.applicationNameWasGenerated,
                    contactPoints: mapToObject(cc.getResolvedContactPoints()),
                    dataCenters: this._getDataCenters(),
                    initialControlConnection: cc.host ? cc.host.address : undefined,
                    protocolVersion: cc.protocolVersion,
                    localAddress: cc.getLocalAddress(),
                    hostName: os.hostname(),
                    executionProfiles: getExecutionProfiles(this._client),
                    poolSizeByHostDistance: {
                      local: options.pooling.coreConnectionsPerHost[types$7.distance.local],
                      remote: options.pooling.coreConnectionsPerHost[types$7.distance.remote]
                    },
                    heartbeatInterval: options.pooling.heartBeatInterval,
                    compression: 'NONE',
                    reconnectionPolicy: getPolicyInfo(options.policies.reconnection),
                    ssl: {
                      enabled: !!options.sslOptions,
                      certValidation: options.sslOptions ? !!options.sslOptions.rejectUnauthorized : undefined
                    },
                    authProvider: {
                      type: !(options.authProvider instanceof NoAuthProvider$1) ? getConstructor(options.authProvider) : undefined
                    },
                    otherOptions: {
                      coalescingThreshold: options.socketOptions.coalescingThreshold
                    },
                    platformInfo: {
                      os: {
                        name: os.platform(),
                        version: os.release(),
                        arch: os.arch()
                      },
                      cpus: {
                        length: os.cpus().length,
                        model: os.cpus()[0].model
                      },
                      runtime: {
                        node: process.versions['node'],
                        v8: process.versions['v8'],
                        uv: process.versions['uv'],
                        openssl: process.versions['openssl'],
                        kerberos: kerberosModule ? kerberosModule.version : undefined
                      }
                    },
                    configAntiPatterns: this._getConfigAntiPatterns(),
                    periodicStatusInterval: Math.floor(this._statusEventDelay / 1000)
                  }
                };
                return _context4.abrupt("return", JSON.stringify(message));

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _getStartupMessage() {
        return _getStartupMessage2.apply(this, arguments);
      }

      return _getStartupMessage;
    }()
  }, {
    key: "_getConfigAntiPatterns",
    value: function _getConfigAntiPatterns() {
      var options = this._client.options;
      var result = {};

      if (options.sslOptions && !options.sslOptions.rejectUnauthorized) {
        result.sslWithoutCertValidation = 'Client-to-node encryption is enabled but server certificate validation is disabled';
      }

      return result;
    }
    /**
     * Gets an array of data centers the driver connects to.
     * Whether the driver connects to a certain host is determined by the host distance (local and remote hosts)
     * and the pooling options (whether connection length for remote hosts is greater than 0).
     * @returns {Array}
     * @private
     */

  }, {
    key: "_getDataCenters",
    value: function _getDataCenters() {
      var _this2 = this;

      var remoteConnectionsLength = this._client.options.pooling.coreConnectionsPerHost[types$7.distance.remote];
      var dataCenters = new Set();

      this._client.hosts.values().forEach(function (h) {
        var distance = _this2._client.profileManager.getDistance(h);

        if (distance === types$7.distance.local || distance === types$7.distance.remote && remoteConnectionsLength > 0) {
          dataCenters.add(h.datacenter);
        }
      });

      return Array.from(dataCenters);
    }
    /**
     * Tries to obtain the application name and version from
     * @param {DseClientOptions} options
     * @returns {Promise}
     * @private
     */

  }, {
    key: "_getAppInfo",
    value: function () {
      var _getAppInfo2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(options) {
        var readPromise, packageInfoPath, text, applicationName, applicationVersion, _packageInfo;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(typeof options.applicationName === 'string')) {
                  _context5.next = 2;
                  break;
                }

                return _context5.abrupt("return", Promise.resolve({
                  applicationName: options.applicationName,
                  applicationVersion: options.applicationVersion,
                  applicationNameWasGenerated: false
                }));

              case 2:
                readPromise = Promise.resolve();

                if (require.main && require.main.filename) {
                  packageInfoPath = path.dirname(require.main.filename);
                  readPromise = this._readPackageInfoFile(packageInfoPath);
                }

                _context5.next = 6;
                return readPromise;

              case 6:
                text = _context5.sent;
                applicationName = 'Default Node.js Application';

                if (text) {
                  try {
                    _packageInfo = JSON.parse(text);

                    if (_packageInfo.name) {
                      applicationName = _packageInfo.name;
                      applicationVersion = _packageInfo.version;
                    }
                  } catch (err) {// The package.json file could not be parsed
                    // Use the default name
                  }
                }

                return _context5.abrupt("return", {
                  applicationName: applicationName,
                  applicationVersion: applicationVersion,
                  applicationNameWasGenerated: true
                });

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _getAppInfo(_x) {
        return _getAppInfo2.apply(this, arguments);
      }

      return _getAppInfo;
    }()
    /**
     * @private
     * @returns {Promise<string>} A Promise that will never be rejected
     */

  }, {
    key: "_readPackageInfoFile",
    value: function _readPackageInfoFile(packageInfoPath) {
      return new Promise(function (resolve) {
        fs$2.readFile(path.join(packageInfoPath, 'package.json'), 'utf8', function (err, data) {
          // Swallow error
          resolve(data);
        });
      });
    }
    /**
     * @returns {String} Returns a json string with the startup message.
     * @private
     */

  }, {
    key: "_getStatusEvent",
    value: function _getStatusEvent() {
      var cc = this._client.controlConnection;
      var options = this._client.options;

      var state = this._client.getState();

      var connectedNodes = {};
      state.getConnectedHosts().forEach(function (h) {
        connectedNodes[h.address] = {
          connections: state.getOpenConnections(h),
          inFlightQueries: state.getInFlightQueries(h)
        };
      });
      var message = {
        metadata: {
          name: 'driver.status',
          insightMappingId: 'v1',
          insightType: 'EVENT',
          timestamp: Date.now(),
          tags: {
            language: 'nodejs'
          }
        },
        data: {
          clientId: options.id,
          sessionId: this._sessionId,
          controlConnection: cc.host ? cc.host.address : undefined,
          connectedNodes: connectedNodes
        }
      };
      return JSON.stringify(message);
    }
    /**
     * Cleans any timer used internally and sets the client as closed.
     */

  }, {
    key: "shutdown",
    value: function shutdown() {
      if (!this._enabled) {
        return;
      }

      this._closed = true;

      if (this._firstTimeout !== null) {
        clearTimeout(this._firstTimeout);
      }

      if (this._recurrentTimeout !== null) {
        clearInterval(this._recurrentTimeout);
      }
    }
  }]);

  return InsightsClient;
}();

var insightsClient = InsightsClient$1;

function mapToObject(map) {
  var result = {};
  map.forEach(function (value, key) {
    return result[key] = value;
  });
  return result;
}

function getPolicyInfo(policy) {
  if (!policy) {
    return undefined;
  }

  var options = policy.getOptions && policy.getOptions();
  return {
    type: policy.constructor.name,
    options: options instanceof Map ? mapToObject(options) : utils$d.emptyObject
  };
}

function getConsistencyString(c) {
  if (typeof c !== 'number') {
    return undefined;
  }

  return types$7.consistencyToString[c];
}

function getConstructor(instance) {
  return instance ? instance.constructor.name : undefined;
}

function getExecutionProfiles(client) {
  var executionProfiles = {};
  var defaultProfile = client.profileManager.getDefault();
  setExecutionProfileProperties(client, executionProfiles, defaultProfile, defaultProfile);
  client.profileManager.getAll().filter(function (p) {
    return p !== defaultProfile;
  }).forEach(function (profile) {
    return setExecutionProfileProperties(client, executionProfiles, profile, defaultProfile);
  });
  return executionProfiles;
}

function setExecutionProfileProperties(client, parent, profile, defaultProfile) {
  var output = parent[profile.name] = {};
  setExecutionProfileItem(output, profile, defaultProfile, 'readTimeout');
  setExecutionProfileItem(output, profile, defaultProfile, 'loadBalancing', getPolicyInfo);
  setExecutionProfileItem(output, profile, defaultProfile, 'retry', getPolicyInfo);
  setExecutionProfileItem(output, profile, defaultProfile, 'consistency', getConsistencyString);
  setExecutionProfileItem(output, profile, defaultProfile, 'serialConsistency', getConsistencyString);

  if (profile === defaultProfile) {
    // Speculative execution policy is included in the profiles as some drivers support
    // different spec exec policy per profile, in this case is fixed for all profiles
    output.speculativeExecution = getPolicyInfo(client.options.policies.speculativeExecution);
  }

  if (profile.graphOptions) {
    output.graphOptions = {};
    var defaultGraphOptions = defaultProfile.graphOptions || utils$d.emptyObject;
    setExecutionProfileItem(output.graphOptions, profile.graphOptions, defaultGraphOptions, 'language');
    setExecutionProfileItem(output.graphOptions, profile.graphOptions, defaultGraphOptions, 'name');
    setExecutionProfileItem(output.graphOptions, profile.graphOptions, defaultGraphOptions, 'readConsistency', getConsistencyString);
    setExecutionProfileItem(output.graphOptions, profile.graphOptions, defaultGraphOptions, 'source');
    setExecutionProfileItem(output.graphOptions, profile.graphOptions, defaultGraphOptions, 'writeConsistency', getConsistencyString);

    if (Object.keys(output.graphOptions).length === 0) {
      // Properties that are undefined will not be included in the JSON
      output.graphOptions = undefined;
    }
  }
}

function setExecutionProfileItem(output, profile, defaultProfile, prop, valueGetter) {
  var value = profile[prop];

  valueGetter = valueGetter || function (x) {
    return x;
  };

  if (profile === defaultProfile && value !== undefined || value !== defaultProfile[prop]) {
    output[prop] = valueGetter(value);
  }
}

var util$5 = {exports: {}};

var fileSystem = {};

var require$1 = fileSystem.require = function () {
  if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process.versions && process.versions["electron"]) {
    try {
      var originalFs = require$1("original-fs");

      if (Object.keys(originalFs).length > 0) {
        return originalFs;
      }
    } catch (e) {}
  }

  return require$$0__default$6["default"];
};

var constants = {
  /* The local file header */
  LOCHDR: 30,
  // LOC header size
  LOCSIG: 0x04034b50,
  // "PK\003\004"
  LOCVER: 4,
  // version needed to extract
  LOCFLG: 6,
  // general purpose bit flag
  LOCHOW: 8,
  // compression method
  LOCTIM: 10,
  // modification time (2 bytes time, 2 bytes date)
  LOCCRC: 14,
  // uncompressed file crc-32 value
  LOCSIZ: 18,
  // compressed size
  LOCLEN: 22,
  // uncompressed size
  LOCNAM: 26,
  // filename length
  LOCEXT: 28,
  // extra field length

  /* The Data descriptor */
  EXTSIG: 0x08074b50,
  // "PK\007\008"
  EXTHDR: 16,
  // EXT header size
  EXTCRC: 4,
  // uncompressed file crc-32 value
  EXTSIZ: 8,
  // compressed size
  EXTLEN: 12,
  // uncompressed size

  /* The central directory file header */
  CENHDR: 46,
  // CEN header size
  CENSIG: 0x02014b50,
  // "PK\001\002"
  CENVEM: 4,
  // version made by
  CENVER: 6,
  // version needed to extract
  CENFLG: 8,
  // encrypt, decrypt flags
  CENHOW: 10,
  // compression method
  CENTIM: 12,
  // modification time (2 bytes time, 2 bytes date)
  CENCRC: 16,
  // uncompressed file crc-32 value
  CENSIZ: 20,
  // compressed size
  CENLEN: 24,
  // uncompressed size
  CENNAM: 28,
  // filename length
  CENEXT: 30,
  // extra field length
  CENCOM: 32,
  // file comment length
  CENDSK: 34,
  // volume number start
  CENATT: 36,
  // internal file attributes
  CENATX: 38,
  // external file attributes (host system dependent)
  CENOFF: 42,
  // LOC header offset

  /* The entries in the end of central directory */
  ENDHDR: 22,
  // END header size
  ENDSIG: 0x06054b50,
  // "PK\005\006"
  ENDSUB: 8,
  // number of entries on this disk
  ENDTOT: 10,
  // total number of entries
  ENDSIZ: 12,
  // central directory size in bytes
  ENDOFF: 16,
  // offset of first CEN header
  ENDCOM: 20,
  // zip file comment length
  END64HDR: 20,
  // zip64 END header size
  END64SIG: 0x07064b50,
  // zip64 Locator signature, "PK\006\007"
  END64START: 4,
  // number of the disk with the start of the zip64
  END64OFF: 8,
  // relative offset of the zip64 end of central directory
  END64NUMDISKS: 16,
  // total number of disks
  ZIP64SIG: 0x06064b50,
  // zip64 signature, "PK\006\006"
  ZIP64HDR: 56,
  // zip64 record minimum size
  ZIP64LEAD: 12,
  // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE
  ZIP64SIZE: 4,
  // zip64 size of the central directory record
  ZIP64VEM: 12,
  // zip64 version made by
  ZIP64VER: 14,
  // zip64 version needed to extract
  ZIP64DSK: 16,
  // zip64 number of this disk
  ZIP64DSKDIR: 20,
  // number of the disk with the start of the record directory
  ZIP64SUB: 24,
  // number of entries on this disk
  ZIP64TOT: 32,
  // total number of entries
  ZIP64SIZB: 40,
  // zip64 central directory size in bytes
  ZIP64OFF: 48,
  // offset of start of central directory with respect to the starting disk number
  ZIP64EXTRA: 56,
  // extensible data sector

  /* Compression methods */
  STORED: 0,
  // no compression
  SHRUNK: 1,
  // shrunk
  REDUCED1: 2,
  // reduced with compression factor 1
  REDUCED2: 3,
  // reduced with compression factor 2
  REDUCED3: 4,
  // reduced with compression factor 3
  REDUCED4: 5,
  // reduced with compression factor 4
  IMPLODED: 6,
  // imploded
  // 7 reserved for Tokenizing compression algorithm
  DEFLATED: 8,
  // deflated
  ENHANCED_DEFLATED: 9,
  // enhanced deflated
  PKWARE: 10,
  // PKWare DCL imploded
  // 11 reserved by PKWARE
  BZIP2: 12,
  //  compressed using BZIP2
  // 13 reserved by PKWARE
  LZMA: 14,
  // LZMA
  // 15-17 reserved by PKWARE
  IBM_TERSE: 18,
  // compressed using IBM TERSE
  IBM_LZ77: 19,
  // IBM LZ77 z
  AES_ENCRYPT: 99,
  // WinZIP AES encryption method

  /* General purpose bit flag */
  // values can obtained with expression 2**bitnr
  FLG_ENC: 1,
  // Bit 0: encrypted file
  FLG_COMP1: 2,
  // Bit 1, compression option
  FLG_COMP2: 4,
  // Bit 2, compression option
  FLG_DESC: 8,
  // Bit 3, data descriptor
  FLG_ENH: 16,
  // Bit 4, enhanced deflating
  FLG_PATCH: 32,
  // Bit 5, indicates that the file is compressed patched data.
  FLG_STR: 64,
  // Bit 6, strong encryption (patented)
  // Bits 7-10: Currently unused.
  FLG_EFS: 2048,
  // Bit 11: Language encoding flag (EFS)
  // Bit 12: Reserved by PKWARE for enhanced compression.
  // Bit 13: encrypted the Central Directory (patented).
  // Bits 14-15: Reserved by PKWARE.
  FLG_MSK: 4096,
  // mask header values

  /* Load type */
  FILE: 2,
  BUFFER: 1,
  NONE: 0,

  /* 4.5 Extensible data fields */
  EF_ID: 0,
  EF_SIZE: 2,

  /* Header IDs */
  ID_ZIP64: 0x0001,
  ID_AVINFO: 0x0007,
  ID_PFS: 0x0008,
  ID_OS2: 0x0009,
  ID_NTFS: 0x000a,
  ID_OPENVMS: 0x000c,
  ID_UNIX: 0x000d,
  ID_FORK: 0x000e,
  ID_PATCH: 0x000f,
  ID_X509_PKCS7: 0x0014,
  ID_X509_CERTID_F: 0x0015,
  ID_X509_CERTID_C: 0x0016,
  ID_STRONGENC: 0x0017,
  ID_RECORD_MGT: 0x0018,
  ID_X509_PKCS7_RL: 0x0019,
  ID_IBM1: 0x0065,
  ID_IBM2: 0x0066,
  ID_POSZIP: 0x4690,
  EF_ZIP64_OR_32: 0xffffffff,
  EF_ZIP64_OR_16: 0xffff,
  EF_ZIP64_SUNCOMP: 0,
  EF_ZIP64_SCOMP: 8,
  EF_ZIP64_RHO: 16,
  EF_ZIP64_DSN: 24
};

var fsystem = fileSystem.require();

var pth$2 = require$$1__default$1["default"];
var Constants$3 = constants;
var isWin = (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && "win32" === process.platform;

var is_Obj = function is_Obj(obj) {
  return obj && _typeof(obj) === "object";
}; // generate CRC32 lookup table


var crcTable = new Uint32Array(256).map(function (t, c) {
  for (var k = 0; k < 8; k++) {
    if ((c & 1) !== 0) {
      c = 0xedb88320 ^ c >>> 1;
    } else {
      c >>>= 1;
    }
  }

  return c >>> 0;
}); // UTILS functions

function Utils$5(opts) {
  this.sep = pth$2.sep;
  this.fs = fsystem;

  if (is_Obj(opts)) {
    // custom filesystem
    if (is_Obj(opts.fs) && typeof opts.fs.statSync === "function") {
      this.fs = opts.fs;
    }
  }
}

var utils$c = Utils$5; // INSTANCED functions

Utils$5.prototype.makeDir = function (
/*String*/
folder) {
  var self = this; // Sync - make directories tree

  function mkdirSync(
  /*String*/
  fpath) {
    var resolvedPath = fpath.split(self.sep)[0];
    fpath.split(self.sep).forEach(function (name) {
      if (!name || name.substr(-1, 1) === ":") return;
      resolvedPath += self.sep + name;
      var stat;

      try {
        stat = self.fs.statSync(resolvedPath);
      } catch (e) {
        self.fs.mkdirSync(resolvedPath);
      }

      if (stat && stat.isFile()) throw Errors.FILE_IN_THE_WAY.replace("%s", resolvedPath);
    });
  }

  mkdirSync(folder);
};

Utils$5.prototype.writeFileTo = function (
/*String*/
path,
/*Buffer*/
content,
/*Boolean*/
overwrite,
/*Number*/
attr) {
  var self = this;

  if (self.fs.existsSync(path)) {
    if (!overwrite) return false; // cannot overwrite

    var stat = self.fs.statSync(path);

    if (stat.isDirectory()) {
      return false;
    }
  }

  var folder = pth$2.dirname(path);

  if (!self.fs.existsSync(folder)) {
    self.makeDir(folder);
  }

  var fd;

  try {
    fd = self.fs.openSync(path, "w", 438); // 0666
  } catch (e) {
    self.fs.chmodSync(path, 438);
    fd = self.fs.openSync(path, "w", 438);
  }

  if (fd) {
    try {
      self.fs.writeSync(fd, content, 0, content.length, 0);
    } finally {
      self.fs.closeSync(fd);
    }
  }

  self.fs.chmodSync(path, attr || 438);
  return true;
};

Utils$5.prototype.writeFileToAsync = function (
/*String*/
path,
/*Buffer*/
content,
/*Boolean*/
overwrite,
/*Number*/
attr,
/*Function*/
callback) {
  if (typeof attr === "function") {
    callback = attr;
    attr = undefined;
  }

  var self = this;
  self.fs.exists(path, function (exist) {
    if (exist && !overwrite) return callback(false);
    self.fs.stat(path, function (err, stat) {
      if (exist && stat.isDirectory()) {
        return callback(false);
      }

      var folder = pth$2.dirname(path);
      self.fs.exists(folder, function (exists) {
        if (!exists) self.makeDir(folder);
        self.fs.open(path, "w", 438, function (err, fd) {
          if (err) {
            self.fs.chmod(path, 438, function () {
              self.fs.open(path, "w", 438, function (err, fd) {
                self.fs.write(fd, content, 0, content.length, 0, function () {
                  self.fs.close(fd, function () {
                    self.fs.chmod(path, attr || 438, function () {
                      callback(true);
                    });
                  });
                });
              });
            });
          } else if (fd) {
            self.fs.write(fd, content, 0, content.length, 0, function () {
              self.fs.close(fd, function () {
                self.fs.chmod(path, attr || 438, function () {
                  callback(true);
                });
              });
            });
          } else {
            self.fs.chmod(path, attr || 438, function () {
              callback(true);
            });
          }
        });
      });
    });
  });
};

Utils$5.prototype.findFiles = function (
/*String*/
path) {
  var self = this;

  function findSync(
  /*String*/
  dir,
  /*RegExp*/
  pattern,
  /*Boolean*/
  recursive) {
    if (typeof pattern === "boolean") {
      recursive = pattern;
      pattern = undefined;
    }

    var files = [];
    self.fs.readdirSync(dir).forEach(function (file) {
      var path = pth$2.join(dir, file);
      if (self.fs.statSync(path).isDirectory() && recursive) files = files.concat(findSync(path, pattern, recursive));

      if (!pattern || pattern.test(path)) {
        files.push(pth$2.normalize(path) + (self.fs.statSync(path).isDirectory() ? self.sep : ""));
      }
    });
    return files;
  }

  return findSync(path, undefined, true);
};

Utils$5.prototype.getAttributes = function () {};

Utils$5.prototype.setAttributes = function () {}; // STATIC functions
// crc32 single update (it is part of crc32)


Utils$5.crc32update = function (crc, _byte) {
  return crcTable[(crc ^ _byte) & 0xff] ^ crc >>> 8;
};

Utils$5.crc32 = function (buf) {
  if (typeof buf === "string") {
    buf = Buffer.from(buf, "utf8");
  } // Generate crcTable


  if (!crcTable.length) genCRCTable();
  var len = buf.length;
  var crc = ~0;

  for (var off = 0; off < len;) {
    crc = Utils$5.crc32update(crc, buf[off++]);
  } // xor and cast as uint32 number


  return ~crc >>> 0;
};

Utils$5.methodToString = function (
/*Number*/
method) {
  switch (method) {
    case Constants$3.STORED:
      return "STORED (" + method + ")";

    case Constants$3.DEFLATED:
      return "DEFLATED (" + method + ")";

    default:
      return "UNSUPPORTED (" + method + ")";
  }
}; // removes ".." style path elements


Utils$5.canonical = function (
/*string*/
path) {
  if (!path) return ""; // trick normalize think path is absolute

  var safeSuffix = pth$2.posix.normalize("/" + path.split("\\").join("/"));
  return pth$2.join(".", safeSuffix);
}; // make abolute paths taking prefix as root folder


Utils$5.sanitize = function (
/*string*/
prefix,
/*string*/
name) {
  prefix = pth$2.resolve(pth$2.normalize(prefix));
  var parts = name.split("/");

  for (var i = 0, l = parts.length; i < l; i++) {
    var path = pth$2.normalize(pth$2.join(prefix, parts.slice(i, l).join(pth$2.sep)));

    if (path.indexOf(prefix) === 0) {
      return path;
    }
  }

  return pth$2.normalize(pth$2.join(prefix, pth$2.basename(name)));
}; // converts buffer, Uint8Array, string types to buffer


Utils$5.toBuffer = function toBuffer(
/*buffer, Uint8Array, string*/
input) {
  if (Buffer.isBuffer(input)) {
    return input;
  } else if (input instanceof Uint8Array) {
    return Buffer.from(input);
  } else {
    // expect string all other values are invalid and return empty buffer
    return typeof input === "string" ? Buffer.from(input, "utf8") : Buffer.alloc(0);
  }
};

Utils$5.readBigUInt64LE = function (
/*Buffer*/
buffer,
/*int*/
index) {
  var slice = Buffer.from(buffer.slice(index, index + 8));
  slice.swap64();
  return parseInt("0x".concat(slice.toString("hex")));
};

Utils$5.isWin = isWin; // Do we have windows system

Utils$5.crcTable = crcTable;

var errors$5 = {
  /* Header error messages */
  INVALID_LOC: "Invalid LOC header (bad signature)",
  INVALID_CEN: "Invalid CEN header (bad signature)",
  INVALID_END: "Invalid END header (bad signature)",

  /* ZipEntry error messages*/
  NO_DATA: "Nothing to decompress",
  BAD_CRC: "CRC32 checksum failed",
  FILE_IN_THE_WAY: "There is a file in the way: %s",
  UNKNOWN_METHOD: "Invalid/unsupported compression method",

  /* Inflater error messages */
  AVAIL_DATA: "inflate::Available inflate data did not terminate",
  INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
  TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
  INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
  INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
  INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
  INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
  INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
  INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
  INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",

  /* ADM-ZIP error messages */
  CANT_EXTRACT_FILE: "Could not extract the file",
  CANT_OVERRIDE: "Target file already exists",
  NO_ZIP: "No zip file was loaded",
  NO_ENTRY: "Entry doesn't exist",
  DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
  FILE_NOT_FOUND: "File not found: %s",
  NOT_IMPLEMENTED: "Not implemented",
  INVALID_FILENAME: "Invalid filename",
  INVALID_FORMAT: "Invalid or unsupported zip format. No END header found"
};

var fs$1 = fileSystem.require();

var pth$1 = require$$1__default$1["default"];
fs$1.existsSync = fs$1.existsSync || pth$1.existsSync;

var fattr = function fattr(
/*String*/
path) {
  var _path = path || "",
      _obj = newAttr(),
      _stat = null;

  function newAttr() {
    return {
      directory: false,
      readonly: false,
      hidden: false,
      executable: false,
      mtime: 0,
      atime: 0
    };
  }

  if (_path && fs$1.existsSync(_path)) {
    _stat = fs$1.statSync(_path);
    _obj.directory = _stat.isDirectory();
    _obj.mtime = _stat.mtime;
    _obj.atime = _stat.atime;
    _obj.executable = (73 & _stat.mode) !== 0; // file is executable who ever har right not just owner

    _obj.readonly = (128 & _stat.mode) === 0; // readonly if owner has no write right

    _obj.hidden = pth$1.basename(_path)[0] === ".";
  } else {
    console.warn("Invalid path: " + _path);
  }

  return {
    get directory() {
      return _obj.directory;
    },

    get readOnly() {
      return _obj.readonly;
    },

    get hidden() {
      return _obj.hidden;
    },

    get mtime() {
      return _obj.mtime;
    },

    get atime() {
      return _obj.atime;
    },

    get executable() {
      return _obj.executable;
    },

    decodeAttributes: function decodeAttributes() {},
    encodeAttributes: function encodeAttributes() {},
    toJSON: function toJSON() {
      return {
        path: _path,
        isDirectory: _obj.directory,
        isReadOnly: _obj.readonly,
        isHidden: _obj.hidden,
        isExecutable: _obj.executable,
        mTime: _obj.mtime,
        aTime: _obj.atime
      };
    },
    toString: function toString() {
      return JSON.stringify(this.toJSON(), null, "\t");
    }
  };
};

util$5.exports = utils$c;
util$5.exports.Constants = constants;
util$5.exports.Errors = errors$5;
util$5.exports.FileAttr = fattr;

var headers = {};

var Utils$4 = util$5.exports,
    Constants$2 = Utils$4.Constants;
/* The central directory file header */

var entryHeader = function entryHeader() {
  var _verMade = 20,
      // v2.0
  _version = 10,
      // v1.0
  _flags = 0,
      _method = 0,
      _time = 0,
      _crc = 0,
      _compressedSize = 0,
      _size = 0,
      _fnameLen = 0,
      _extraLen = 0,
      _comLen = 0,
      _diskStart = 0,
      _inattr = 0,
      _attr = 0,
      _offset = 0;
  _verMade |= Utils$4.isWin ? 0x0a00 : 0x0300; // Set EFS flag since filename and comment fields are all by default encoded using UTF-8.
  // Without it file names may be corrupted for other apps when file names use unicode chars

  _flags |= Constants$2.FLG_EFS;
  var _dataHeader = {};

  function setTime(val) {
    val = new Date(val);
    _time = (val.getFullYear() - 1980 & 0x7f) << 25 | // b09-16 years from 1980
    val.getMonth() + 1 << 21 | // b05-08 month
    val.getDate() << 16 | // b00-04 hour
    // 2 bytes time
    val.getHours() << 11 | // b11-15 hour
    val.getMinutes() << 5 | // b05-10 minute
    val.getSeconds() >> 1; // b00-04 seconds divided by 2
  }

  setTime(+new Date());
  return {
    get made() {
      return _verMade;
    },

    set made(val) {
      _verMade = val;
    },

    get version() {
      return _version;
    },

    set version(val) {
      _version = val;
    },

    get flags() {
      return _flags;
    },

    set flags(val) {
      _flags = val;
    },

    get method() {
      return _method;
    },

    set method(val) {
      switch (val) {
        case Constants$2.STORED:
          this.version = 10;

        case Constants$2.DEFLATED:
        default:
          this.version = 20;
      }

      _method = val;
    },

    get time() {
      return new Date((_time >> 25 & 0x7f) + 1980, (_time >> 21 & 0x0f) - 1, _time >> 16 & 0x1f, _time >> 11 & 0x1f, _time >> 5 & 0x3f, (_time & 0x1f) << 1);
    },

    set time(val) {
      setTime(val);
    },

    get crc() {
      return _crc;
    },

    set crc(val) {
      _crc = Math.max(0, val) >>> 0;
    },

    get compressedSize() {
      return _compressedSize;
    },

    set compressedSize(val) {
      _compressedSize = Math.max(0, val) >>> 0;
    },

    get size() {
      return _size;
    },

    set size(val) {
      _size = Math.max(0, val) >>> 0;
    },

    get fileNameLength() {
      return _fnameLen;
    },

    set fileNameLength(val) {
      _fnameLen = val;
    },

    get extraLength() {
      return _extraLen;
    },

    set extraLength(val) {
      _extraLen = val;
    },

    get commentLength() {
      return _comLen;
    },

    set commentLength(val) {
      _comLen = val;
    },

    get diskNumStart() {
      return _diskStart;
    },

    set diskNumStart(val) {
      _diskStart = Math.max(0, val) >>> 0;
    },

    get inAttr() {
      return _inattr;
    },

    set inAttr(val) {
      _inattr = Math.max(0, val) >>> 0;
    },

    get attr() {
      return _attr;
    },

    set attr(val) {
      _attr = Math.max(0, val) >>> 0;
    },

    // get Unix file permissions
    get fileAttr() {
      return _attr ? (_attr >>> 0 | 0) >> 16 & 0xfff : 0;
    },

    get offset() {
      return _offset;
    },

    set offset(val) {
      _offset = Math.max(0, val) >>> 0;
    },

    get encripted() {
      return (_flags & 1) === 1;
    },

    get entryHeaderSize() {
      return Constants$2.CENHDR + _fnameLen + _extraLen + _comLen;
    },

    get realDataOffset() {
      return _offset + Constants$2.LOCHDR + _dataHeader.fnameLen + _dataHeader.extraLen;
    },

    get dataHeader() {
      return _dataHeader;
    },

    loadDataHeaderFromBinary: function loadDataHeaderFromBinary(
    /*Buffer*/
    input) {
      var data = input.slice(_offset, _offset + Constants$2.LOCHDR); // 30 bytes and should start with "PK\003\004"

      if (data.readUInt32LE(0) !== Constants$2.LOCSIG) {
        throw new Error(Utils$4.Errors.INVALID_LOC);
      }

      _dataHeader = {
        // version needed to extract
        version: data.readUInt16LE(Constants$2.LOCVER),
        // general purpose bit flag
        flags: data.readUInt16LE(Constants$2.LOCFLG),
        // compression method
        method: data.readUInt16LE(Constants$2.LOCHOW),
        // modification time (2 bytes time, 2 bytes date)
        time: data.readUInt32LE(Constants$2.LOCTIM),
        // uncompressed file crc-32 value
        crc: data.readUInt32LE(Constants$2.LOCCRC),
        // compressed size
        compressedSize: data.readUInt32LE(Constants$2.LOCSIZ),
        // uncompressed size
        size: data.readUInt32LE(Constants$2.LOCLEN),
        // filename length
        fnameLen: data.readUInt16LE(Constants$2.LOCNAM),
        // extra field length
        extraLen: data.readUInt16LE(Constants$2.LOCEXT)
      };
    },
    loadFromBinary: function loadFromBinary(
    /*Buffer*/
    data) {
      // data should be 46 bytes and start with "PK 01 02"
      if (data.length !== Constants$2.CENHDR || data.readUInt32LE(0) !== Constants$2.CENSIG) {
        throw new Error(Utils$4.Errors.INVALID_CEN);
      } // version made by


      _verMade = data.readUInt16LE(Constants$2.CENVEM); // version needed to extract

      _version = data.readUInt16LE(Constants$2.CENVER); // encrypt, decrypt flags

      _flags = data.readUInt16LE(Constants$2.CENFLG); // compression method

      _method = data.readUInt16LE(Constants$2.CENHOW); // modification time (2 bytes time, 2 bytes date)

      _time = data.readUInt32LE(Constants$2.CENTIM); // uncompressed file crc-32 value

      _crc = data.readUInt32LE(Constants$2.CENCRC); // compressed size

      _compressedSize = data.readUInt32LE(Constants$2.CENSIZ); // uncompressed size

      _size = data.readUInt32LE(Constants$2.CENLEN); // filename length

      _fnameLen = data.readUInt16LE(Constants$2.CENNAM); // extra field length

      _extraLen = data.readUInt16LE(Constants$2.CENEXT); // file comment length

      _comLen = data.readUInt16LE(Constants$2.CENCOM); // volume number start

      _diskStart = data.readUInt16LE(Constants$2.CENDSK); // internal file attributes

      _inattr = data.readUInt16LE(Constants$2.CENATT); // external file attributes

      _attr = data.readUInt32LE(Constants$2.CENATX); // LOC header offset

      _offset = data.readUInt32LE(Constants$2.CENOFF);
    },
    dataHeaderToBinary: function dataHeaderToBinary() {
      // LOC header size (30 bytes)
      var data = Buffer.alloc(Constants$2.LOCHDR); // "PK\003\004"

      data.writeUInt32LE(Constants$2.LOCSIG, 0); // version needed to extract

      data.writeUInt16LE(_version, Constants$2.LOCVER); // general purpose bit flag

      data.writeUInt16LE(_flags, Constants$2.LOCFLG); // compression method

      data.writeUInt16LE(_method, Constants$2.LOCHOW); // modification time (2 bytes time, 2 bytes date)

      data.writeUInt32LE(_time, Constants$2.LOCTIM); // uncompressed file crc-32 value

      data.writeUInt32LE(_crc, Constants$2.LOCCRC); // compressed size

      data.writeUInt32LE(_compressedSize, Constants$2.LOCSIZ); // uncompressed size

      data.writeUInt32LE(_size, Constants$2.LOCLEN); // filename length

      data.writeUInt16LE(_fnameLen, Constants$2.LOCNAM); // extra field length

      data.writeUInt16LE(_extraLen, Constants$2.LOCEXT);
      return data;
    },
    entryHeaderToBinary: function entryHeaderToBinary() {
      // CEN header size (46 bytes)
      var data = Buffer.alloc(Constants$2.CENHDR + _fnameLen + _extraLen + _comLen); // "PK\001\002"

      data.writeUInt32LE(Constants$2.CENSIG, 0); // version made by

      data.writeUInt16LE(_verMade, Constants$2.CENVEM); // version needed to extract

      data.writeUInt16LE(_version, Constants$2.CENVER); // encrypt, decrypt flags

      data.writeUInt16LE(_flags, Constants$2.CENFLG); // compression method

      data.writeUInt16LE(_method, Constants$2.CENHOW); // modification time (2 bytes time, 2 bytes date)

      data.writeUInt32LE(_time, Constants$2.CENTIM); // uncompressed file crc-32 value

      data.writeUInt32LE(_crc, Constants$2.CENCRC); // compressed size

      data.writeUInt32LE(_compressedSize, Constants$2.CENSIZ); // uncompressed size

      data.writeUInt32LE(_size, Constants$2.CENLEN); // filename length

      data.writeUInt16LE(_fnameLen, Constants$2.CENNAM); // extra field length

      data.writeUInt16LE(_extraLen, Constants$2.CENEXT); // file comment length

      data.writeUInt16LE(_comLen, Constants$2.CENCOM); // volume number start

      data.writeUInt16LE(_diskStart, Constants$2.CENDSK); // internal file attributes

      data.writeUInt16LE(_inattr, Constants$2.CENATT); // external file attributes

      data.writeUInt32LE(_attr, Constants$2.CENATX); // LOC header offset

      data.writeUInt32LE(_offset, Constants$2.CENOFF); // fill all with

      data.fill(0x00, Constants$2.CENHDR);
      return data;
    },
    toJSON: function toJSON() {
      var bytes = function bytes(nr) {
        return nr + " bytes";
      };

      return {
        made: _verMade,
        version: _version,
        flags: _flags,
        method: Utils$4.methodToString(_method),
        time: this.time,
        crc: "0x" + _crc.toString(16).toUpperCase(),
        compressedSize: bytes(_compressedSize),
        size: bytes(_size),
        fileNameLength: bytes(_fnameLen),
        extraLength: bytes(_extraLen),
        commentLength: bytes(_comLen),
        diskNumStart: _diskStart,
        inAttr: _inattr,
        attr: _attr,
        offset: _offset,
        entryHeaderSize: bytes(Constants$2.CENHDR + _fnameLen + _extraLen + _comLen)
      };
    },
    toString: function toString() {
      return JSON.stringify(this.toJSON(), null, "\t");
    }
  };
};

var Utils$3 = util$5.exports,
    Constants$1 = Utils$3.Constants;
/* The entries in the end of central directory */

var mainHeader = function mainHeader() {
  var _volumeEntries = 0,
      _totalEntries = 0,
      _size = 0,
      _offset = 0,
      _commentLength = 0;
  return {
    get diskEntries() {
      return _volumeEntries;
    },

    set diskEntries(
    /*Number*/
    val) {
      _volumeEntries = _totalEntries = val;
    },

    get totalEntries() {
      return _totalEntries;
    },

    set totalEntries(
    /*Number*/
    val) {
      _totalEntries = _volumeEntries = val;
    },

    get size() {
      return _size;
    },

    set size(
    /*Number*/
    val) {
      _size = val;
    },

    get offset() {
      return _offset;
    },

    set offset(
    /*Number*/
    val) {
      _offset = val;
    },

    get commentLength() {
      return _commentLength;
    },

    set commentLength(
    /*Number*/
    val) {
      _commentLength = val;
    },

    get mainHeaderSize() {
      return Constants$1.ENDHDR + _commentLength;
    },

    loadFromBinary: function loadFromBinary(
    /*Buffer*/
    data) {
      // data should be 22 bytes and start with "PK 05 06"
      // or be 56+ bytes and start with "PK 06 06" for Zip64
      if ((data.length !== Constants$1.ENDHDR || data.readUInt32LE(0) !== Constants$1.ENDSIG) && (data.length < Constants$1.ZIP64HDR || data.readUInt32LE(0) !== Constants$1.ZIP64SIG)) {
        throw new Error(Utils$3.Errors.INVALID_END);
      }

      if (data.readUInt32LE(0) === Constants$1.ENDSIG) {
        // number of entries on this volume
        _volumeEntries = data.readUInt16LE(Constants$1.ENDSUB); // total number of entries

        _totalEntries = data.readUInt16LE(Constants$1.ENDTOT); // central directory size in bytes

        _size = data.readUInt32LE(Constants$1.ENDSIZ); // offset of first CEN header

        _offset = data.readUInt32LE(Constants$1.ENDOFF); // zip file comment length

        _commentLength = data.readUInt16LE(Constants$1.ENDCOM);
      } else {
        // number of entries on this volume
        _volumeEntries = Utils$3.readBigUInt64LE(data, Constants$1.ZIP64SUB); // total number of entries

        _totalEntries = Utils$3.readBigUInt64LE(data, Constants$1.ZIP64TOT); // central directory size in bytes

        _size = Utils$3.readBigUInt64LE(data, Constants$1.ZIP64SIZ); // offset of first CEN header

        _offset = Utils$3.readBigUInt64LE(data, Constants$1.ZIP64OFF);
        _commentLength = 0;
      }
    },
    toBinary: function toBinary() {
      var b = Buffer.alloc(Constants$1.ENDHDR + _commentLength); // "PK 05 06" signature

      b.writeUInt32LE(Constants$1.ENDSIG, 0);
      b.writeUInt32LE(0, 4); // number of entries on this volume

      b.writeUInt16LE(_volumeEntries, Constants$1.ENDSUB); // total number of entries

      b.writeUInt16LE(_totalEntries, Constants$1.ENDTOT); // central directory size in bytes

      b.writeUInt32LE(_size, Constants$1.ENDSIZ); // offset of first CEN header

      b.writeUInt32LE(_offset, Constants$1.ENDOFF); // zip file comment length

      b.writeUInt16LE(_commentLength, Constants$1.ENDCOM); // fill comment memory with spaces so no garbage is left there

      b.fill(" ", Constants$1.ENDHDR);
      return b;
    },
    toJSON: function toJSON() {
      // creates 0x0000 style output
      var offset = function offset(nr, len) {
        var offs = nr.toString(16).toUpperCase();

        while (offs.length < len) {
          offs = "0" + offs;
        }

        return "0x" + offs;
      };

      return {
        diskEntries: _volumeEntries,
        totalEntries: _totalEntries,
        size: _size + " bytes",
        offset: offset(_offset, 4),
        commentLength: _commentLength
      };
    },
    toString: function toString() {
      return JSON.stringify(this.toJSON(), null, "\t");
    }
  };
};

headers.EntryHeader = entryHeader;
headers.MainHeader = mainHeader;

var methods = {};

var deflater = function deflater(
/*Buffer*/
inbuf) {
  var zlib = require$$0__default$8["default"];
  var opts = {
    chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024
  };
  return {
    deflate: function deflate() {
      return zlib.deflateRawSync(inbuf, opts);
    },
    deflateAsync: function deflateAsync(
    /*Function*/
    callback) {
      var tmp = zlib.createDeflateRaw(opts),
          parts = [],
          total = 0;
      tmp.on("data", function (data) {
        parts.push(data);
        total += data.length;
      });
      tmp.on("end", function () {
        var buf = Buffer.alloc(total),
            written = 0;
        buf.fill(0);

        for (var i = 0; i < parts.length; i++) {
          var part = parts[i];
          part.copy(buf, written);
          written += part.length;
        }

        callback && callback(buf);
      });
      tmp.end(inbuf);
    }
  };
};

var inflater = function inflater(
/*Buffer*/
inbuf) {
  var zlib = require$$0__default$8["default"];
  return {
    inflate: function inflate() {
      return zlib.inflateRawSync(inbuf);
    },
    inflateAsync: function inflateAsync(
    /*Function*/
    callback) {
      var tmp = zlib.createInflateRaw(),
          parts = [],
          total = 0;
      tmp.on("data", function (data) {
        parts.push(data);
        total += data.length;
      });
      tmp.on("end", function () {
        var buf = Buffer.alloc(total),
            written = 0;
        buf.fill(0);

        for (var i = 0; i < parts.length; i++) {
          var part = parts[i];
          part.copy(buf, written);
          written += part.length;
        }

        callback && callback(buf);
      });
      tmp.end(inbuf);
    }
  };
};

// eslint-disable-next-line node/no-unsupported-features/node-builtins


var randomFillSync = require$$0__default$4["default"].randomFillSync; // generate CRC32 lookup table

var crctable = new Uint32Array(256).map(function (t, crc) {
  for (var j = 0; j < 8; j++) {
    if (0 !== (crc & 1)) {
      crc = crc >>> 1 ^ 0xedb88320;
    } else {
      crc >>>= 1;
    }
  }

  return crc >>> 0;
}); // C-style uInt32 Multiply (discards higher bits, when JS multiply discards lower bits)

var uMul = function uMul(a, b) {
  return Math.imul(a, b) >>> 0;
}; // crc32 byte single update (actually same function is part of utils.crc32 function :) )


var crc32update = function crc32update(pCrc32, bval) {
  return crctable[(pCrc32 ^ bval) & 0xff] ^ pCrc32 >>> 8;
}; // function for generating salt for encrytion header


var genSalt = function genSalt() {
  if ("function" === typeof randomFillSync) {
    return randomFillSync(Buffer.alloc(12));
  } else {
    // fallback if function is not defined
    return genSalt.node();
  }
}; // salt generation with node random function (mainly as fallback)


genSalt.node = function () {
  var salt = Buffer.alloc(12);
  var len = salt.length;

  for (var i = 0; i < len; i++) {
    salt[i] = Math.random() * 256 & 0xff;
  }

  return salt;
}; // general config


var config = {
  genSalt: genSalt
}; // Class Initkeys handles same basic ops with keys

function Initkeys(pw) {
  var pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);
  this.keys = new Uint32Array([0x12345678, 0x23456789, 0x34567890]);

  for (var i = 0; i < pass.length; i++) {
    this.updateKeys(pass[i]);
  }
}

Initkeys.prototype.updateKeys = function (byteValue) {
  var keys = this.keys;
  keys[0] = crc32update(keys[0], byteValue);
  keys[1] += keys[0] & 0xff;
  keys[1] = uMul(keys[1], 134775813) + 1;
  keys[2] = crc32update(keys[2], keys[1] >>> 24);
  return byteValue;
};

Initkeys.prototype.next = function () {
  var k = (this.keys[2] | 2) >>> 0; // key

  return uMul(k, k ^ 1) >> 8 & 0xff; // decode
};

function make_decrypter(
/*Buffer*/
pwd) {
  // 1. Stage initialize key
  var keys = new Initkeys(pwd); // return decrypter function

  return function (
  /*Buffer*/
  data) {
    // result - we create new Buffer for results
    var result = Buffer.alloc(data.length);
    var pos = 0; // process input data

    var _iterator = _createForOfIteratorHelper(data),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var c = _step.value;
        //c ^= keys.next();
        //result[pos++] = c; // decode & Save Value
        result[pos++] = keys.updateKeys(c ^ keys.next()); // update keys with decoded byte
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return result;
  };
}

function make_encrypter(
/*Buffer*/
pwd) {
  // 1. Stage initialize key
  var keys = new Initkeys(pwd); // return encrypting function, result and pos is here so we dont have to merge buffers later

  return function (
  /*Buffer*/
  data,
  /*Buffer*/
  result) {
    var pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    // result - we create new Buffer for results
    if (!result) result = Buffer.alloc(data.length); // process input data

    var _iterator2 = _createForOfIteratorHelper(data),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var c = _step2.value;
        var k = keys.next(); // save key byte

        result[pos++] = c ^ k; // save val

        keys.updateKeys(c); // update keys with decoded byte
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return result;
  };
}

function decrypt(
/*Buffer*/
data,
/*Object*/
header,
/*String, Buffer*/
pwd) {
  if (!data || !Buffer.isBuffer(data) || data.length < 12) {
    return Buffer.alloc(0);
  } // 1. We Initialize and generate decrypting function


  var decrypter = make_decrypter(pwd); // 2. decrypt salt what is always 12 bytes and is a part of file content

  var salt = decrypter(data.slice(0, 12)); // 3. does password meet expectations

  if (salt[11] !== header.crc >>> 24) {
    throw "ADM-ZIP: Wrong Password";
  } // 4. decode content


  return decrypter(data.slice(12));
} // lets add way to populate salt, NOT RECOMMENDED for production but maybe useful for testing general functionality


function _salter(data) {
  if (Buffer.isBuffer(data) && data.length >= 12) {
    // be aware - currently salting buffer data is modified
    config.genSalt = function () {
      return data.slice(0, 12);
    };
  } else if (data === "node") {
    // test salt generation with node random function
    config.genSalt = genSalt.node;
  } else {
    // if value is not acceptable config gets reset.
    config.genSalt = genSalt;
  }
}

function encrypt(
/*Buffer*/
data,
/*Object*/
header,
/*String, Buffer*/
pwd) {
  var oldlike = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  // 1. test data if data is not Buffer we make buffer from it
  if (data == null) data = Buffer.alloc(0); // if data is not buffer be make buffer from it

  if (!Buffer.isBuffer(data)) data = Buffer.from(data.toString()); // 2. We Initialize and generate encrypting function

  var encrypter = make_encrypter(pwd); // 3. generate salt (12-bytes of random data)

  var salt = config.genSalt();
  salt[11] = header.crc >>> 24 & 0xff; // old implementations (before PKZip 2.04g) used two byte check

  if (oldlike) salt[10] = header.crc >>> 16 & 0xff; // 4. create output

  var result = Buffer.alloc(data.length + 12);
  encrypter(salt, result); // finally encode content

  return encrypter(data, result, 12);
}

var zipcrypto = {
  decrypt: decrypt,
  encrypt: encrypt,
  _salter: _salter
};

methods.Deflater = deflater;
methods.Inflater = inflater;
methods.ZipCrypto = zipcrypto;

var Utils$2 = util$5.exports,
    Headers$1 = headers,
    Constants = Utils$2.Constants,
    Methods = methods;

var zipEntry = function zipEntry(
/*Buffer*/
input) {
  var _entryHeader = new Headers$1.EntryHeader(),
      _entryName = Buffer.alloc(0),
      _comment = Buffer.alloc(0),
      _isDirectory = false,
      uncompressedData = null,
      _extra = Buffer.alloc(0);

  function getCompressedDataFromZip() {
    if (!input || !Buffer.isBuffer(input)) {
      return Buffer.alloc(0);
    }

    _entryHeader.loadDataHeaderFromBinary(input);

    return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize);
  }

  function crc32OK(data) {
    // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written
    if ((_entryHeader.flags & 0x8) !== 0x8) {
      if (Utils$2.crc32(data) !== _entryHeader.dataHeader.crc) {
        return false;
      }
    }

    return true;
  }

  function decompress(
  /*Boolean*/
  async,
  /*Function*/
  callback,
  /*String, Buffer*/
  pass) {
    if (typeof callback === "undefined" && typeof async === "string") {
      pass = async;
      async = void 0;
    }

    if (_isDirectory) {
      if (async && callback) {
        callback(Buffer.alloc(0), Utils$2.Errors.DIRECTORY_CONTENT_ERROR); //si added error.
      }

      return Buffer.alloc(0);
    }

    var compressedData = getCompressedDataFromZip();

    if (compressedData.length === 0) {
      // File is empty, nothing to decompress.
      if (async && callback) callback(compressedData);
      return compressedData;
    }

    if (_entryHeader.encripted) {
      if ("string" !== typeof pass && !Buffer.isBuffer(pass)) {
        throw new Error("ADM-ZIP: Incompatible password parameter");
      }

      compressedData = Methods.ZipCrypto.decrypt(compressedData, _entryHeader, pass);
    }

    var data = Buffer.alloc(_entryHeader.size);

    switch (_entryHeader.method) {
      case Utils$2.Constants.STORED:
        compressedData.copy(data);

        if (!crc32OK(data)) {
          if (async && callback) callback(data, Utils$2.Errors.BAD_CRC); //si added error

          throw new Error(Utils$2.Errors.BAD_CRC);
        } else {
          //si added otherwise did not seem to return data.
          if (async && callback) callback(data);
          return data;
        }

      case Utils$2.Constants.DEFLATED:
        var inflater = new Methods.Inflater(compressedData);

        if (!async) {
          var result = inflater.inflate(data);
          result.copy(data, 0);

          if (!crc32OK(data)) {
            throw new Error(Utils$2.Errors.BAD_CRC + " " + _entryName.toString());
          }

          return data;
        } else {
          inflater.inflateAsync(function (result) {
            result.copy(result, 0);

            if (callback) {
              if (!crc32OK(result)) {
                callback(result, Utils$2.Errors.BAD_CRC); //si added error
              } else {
                callback(result);
              }
            }
          });
        }

        break;

      default:
        if (async && callback) callback(Buffer.alloc(0), Utils$2.Errors.UNKNOWN_METHOD);
        throw new Error(Utils$2.Errors.UNKNOWN_METHOD);
    }
  }

  function compress(
  /*Boolean*/
  async,
  /*Function*/
  callback) {
    if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {
      // no data set or the data wasn't changed to require recompression
      if (async && callback) callback(getCompressedDataFromZip());
      return getCompressedDataFromZip();
    }

    if (uncompressedData.length && !_isDirectory) {
      var compressedData; // Local file header

      switch (_entryHeader.method) {
        case Utils$2.Constants.STORED:
          _entryHeader.compressedSize = _entryHeader.size;
          compressedData = Buffer.alloc(uncompressedData.length);
          uncompressedData.copy(compressedData);
          if (async && callback) callback(compressedData);
          return compressedData;

        default:
        case Utils$2.Constants.DEFLATED:
          var deflater = new Methods.Deflater(uncompressedData);

          if (!async) {
            var deflated = deflater.deflate();
            _entryHeader.compressedSize = deflated.length;
            return deflated;
          } else {
            deflater.deflateAsync(function (data) {
              compressedData = Buffer.alloc(data.length);
              _entryHeader.compressedSize = data.length;
              data.copy(compressedData);
              callback && callback(compressedData);
            });
          }

          deflater = null;
          break;
      }
    } else if (async && callback) {
      callback(Buffer.alloc(0));
    } else {
      return Buffer.alloc(0);
    }
  }

  function readUInt64LE(buffer, offset) {
    return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);
  }

  function parseExtra(data) {
    var offset = 0;
    var signature, size, part;

    while (offset < data.length) {
      signature = data.readUInt16LE(offset);
      offset += 2;
      size = data.readUInt16LE(offset);
      offset += 2;
      part = data.slice(offset, offset + size);
      offset += size;

      if (Constants.ID_ZIP64 === signature) {
        parseZip64ExtendedInformation(part);
      }
    }
  } //Override header field values with values from the ZIP64 extra field


  function parseZip64ExtendedInformation(data) {
    var size, compressedSize, offset, diskNumStart;

    if (data.length >= Constants.EF_ZIP64_SCOMP) {
      size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);

      if (_entryHeader.size === Constants.EF_ZIP64_OR_32) {
        _entryHeader.size = size;
      }
    }

    if (data.length >= Constants.EF_ZIP64_RHO) {
      compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);

      if (_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {
        _entryHeader.compressedSize = compressedSize;
      }
    }

    if (data.length >= Constants.EF_ZIP64_DSN) {
      offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);

      if (_entryHeader.offset === Constants.EF_ZIP64_OR_32) {
        _entryHeader.offset = offset;
      }
    }

    if (data.length >= Constants.EF_ZIP64_DSN + 4) {
      diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);

      if (_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {
        _entryHeader.diskNumStart = diskNumStart;
      }
    }
  }

  return {
    get entryName() {
      return _entryName.toString();
    },

    get rawEntryName() {
      return _entryName;
    },

    set entryName(val) {
      _entryName = Utils$2.toBuffer(val);
      var lastChar = _entryName[_entryName.length - 1];
      _isDirectory = lastChar === 47 || lastChar === 92;
      _entryHeader.fileNameLength = _entryName.length;
    },

    get extra() {
      return _extra;
    },

    set extra(val) {
      _extra = val;
      _entryHeader.extraLength = val.length;
      parseExtra(val);
    },

    get comment() {
      return _comment.toString();
    },

    set comment(val) {
      _comment = Utils$2.toBuffer(val);
      _entryHeader.commentLength = _comment.length;
    },

    get name() {
      var n = _entryName.toString();

      return _isDirectory ? n.substr(n.length - 1).split("/").pop() : n.split("/").pop();
    },

    get isDirectory() {
      return _isDirectory;
    },

    getCompressedData: function getCompressedData() {
      return compress(false, null);
    },
    getCompressedDataAsync: function getCompressedDataAsync(
    /*Function*/
    callback) {
      compress(true, callback);
    },
    setData: function setData(value) {
      uncompressedData = Utils$2.toBuffer(value);

      if (!_isDirectory && uncompressedData.length) {
        _entryHeader.size = uncompressedData.length;
        _entryHeader.method = Utils$2.Constants.DEFLATED;
        _entryHeader.crc = Utils$2.crc32(value);
        _entryHeader.changed = true;
      } else {
        // folders and blank files should be stored
        _entryHeader.method = Utils$2.Constants.STORED;
      }
    },
    getData: function getData(pass) {
      if (_entryHeader.changed) {
        return uncompressedData;
      } else {
        return decompress(false, null, pass);
      }
    },
    getDataAsync: function getDataAsync(
    /*Function*/
    callback, pass) {
      if (_entryHeader.changed) {
        callback(uncompressedData);
      } else {
        decompress(true, callback, pass);
      }
    },

    set attr(attr) {
      _entryHeader.attr = attr;
    },

    get attr() {
      return _entryHeader.attr;
    },

    set header(
    /*Buffer*/
    data) {
      _entryHeader.loadFromBinary(data);
    },

    get header() {
      return _entryHeader;
    },

    packHeader: function packHeader() {
      // 1. create header (buffer)
      var header = _entryHeader.entryHeaderToBinary();

      var addpos = Utils$2.Constants.CENHDR; // 2. add file name

      _entryName.copy(header, addpos);

      addpos += _entryName.length; // 3. add extra data

      if (_entryHeader.extraLength) {
        _extra.copy(header, addpos);

        addpos += _entryHeader.extraLength;
      } // 4. add file comment


      if (_entryHeader.commentLength) {
        _comment.copy(header, addpos);
      }

      return header;
    },
    toJSON: function toJSON() {
      var bytes = function bytes(nr) {
        return "<" + (nr && nr.length + " bytes buffer" || "null") + ">";
      };

      return {
        entryName: this.entryName,
        name: this.name,
        comment: this.comment,
        isDirectory: this.isDirectory,
        header: _entryHeader.toJSON(),
        compressedData: bytes(input),
        data: bytes(uncompressedData)
      };
    },
    toString: function toString() {
      return JSON.stringify(this.toJSON(), null, "\t");
    }
  };
};

var ZipEntry$1 = zipEntry;
var Headers = headers;
var Utils$1 = util$5.exports;

var zipFile = function zipFile(
/*Buffer|null*/
inBuffer,
/** object */
options) {
  var entryList = [],
      entryTable = {},
      _comment = Buffer.alloc(0),
      mainHeader = new Headers.MainHeader(),
      loadedEntries = false; // assign options


  var opts = Object.assign(Object.create(null), options);
  var noSort = opts.noSort;

  if (inBuffer) {
    // is a memory buffer
    readMainHeader(opts.readEntries);
  } else {
    // none. is a new file
    loadedEntries = true;
  }

  function iterateEntries(callback) {
    var totalEntries = mainHeader.diskEntries; // total number of entries

    var index = mainHeader.offset; // offset of first CEN header

    for (var i = 0; i < totalEntries; i++) {
      var tmp = index;
      var entry = new ZipEntry$1(inBuffer);
      entry.header = inBuffer.slice(tmp, tmp += Utils$1.Constants.CENHDR);
      entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);
      index += entry.header.entryHeaderSize;
      callback(entry);
    }
  }

  function readEntries() {
    loadedEntries = true;
    entryTable = {};
    entryList = new Array(mainHeader.diskEntries); // total number of entries

    var index = mainHeader.offset; // offset of first CEN header

    for (var i = 0; i < entryList.length; i++) {
      var tmp = index,
          entry = new ZipEntry$1(inBuffer);
      entry.header = inBuffer.slice(tmp, tmp += Utils$1.Constants.CENHDR);
      entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);

      if (entry.header.extraLength) {
        entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);
      }

      if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);
      index += entry.header.entryHeaderSize;
      entryList[i] = entry;
      entryTable[entry.entryName] = entry;
    }
  }

  function readMainHeader(
  /*Boolean*/
  readNow) {
    var i = inBuffer.length - Utils$1.Constants.ENDHDR,
        // END header size
    max = Math.max(0, i - 0xffff),
        // 0xFFFF is the max zip file comment length
    n = max,
        endStart = inBuffer.length,
        endOffset = -1,
        // Start offset of the END header
    commentEnd = 0;

    for (i; i >= n; i--) {
      if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'

      if (inBuffer.readUInt32LE(i) === Utils$1.Constants.ENDSIG) {
        // "PK\005\006"
        endOffset = i;
        commentEnd = i;
        endStart = i + Utils$1.Constants.ENDHDR; // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature

        n = i - Utils$1.Constants.END64HDR;
        continue;
      }

      if (inBuffer.readUInt32LE(i) === Utils$1.Constants.END64SIG) {
        // Found a zip64 signature, let's continue reading the whole zip64 record
        n = max;
        continue;
      }

      if (inBuffer.readUInt32LE(i) === Utils$1.Constants.ZIP64SIG) {
        // Found the zip64 record, let's determine it's size
        endOffset = i;
        endStart = i + Utils$1.readBigUInt64LE(inBuffer, i + Utils$1.Constants.ZIP64SIZE) + Utils$1.Constants.ZIP64LEAD;
        break;
      }
    }

    if (!~endOffset) throw new Error(Utils$1.Errors.INVALID_FORMAT);
    mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));

    if (mainHeader.commentLength) {
      _comment = inBuffer.slice(commentEnd + Utils$1.Constants.ENDHDR);
    }

    if (readNow) readEntries();
  }

  function sortEntries() {
    if (entryList.length > 1 && !noSort) {
      entryList.sort(function (a, b) {
        return a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase());
      });
    }
  }

  return {
    /**
     * Returns an array of ZipEntry objects existent in the current opened archive
     * @return Array
     */
    get entries() {
      if (!loadedEntries) {
        readEntries();
      }

      return entryList;
    },

    /**
     * Archive comment
     * @return {String}
     */
    get comment() {
      return _comment.toString();
    },

    set comment(val) {
      _comment = Utils$1.toBuffer(val);
      mainHeader.commentLength = _comment.length;
    },

    getEntryCount: function getEntryCount() {
      if (!loadedEntries) {
        return mainHeader.diskEntries;
      }

      return entryList.length;
    },
    forEach: function forEach(callback) {
      if (!loadedEntries) {
        iterateEntries(callback);
        return;
      }

      entryList.forEach(callback);
    },

    /**
     * Returns a reference to the entry with the given name or null if entry is inexistent
     *
     * @param entryName
     * @return ZipEntry
     */
    getEntry: function getEntry(
    /*String*/
    entryName) {
      if (!loadedEntries) {
        readEntries();
      }

      return entryTable[entryName] || null;
    },

    /**
     * Adds the given entry to the entry list
     *
     * @param entry
     */
    setEntry: function setEntry(
    /*ZipEntry*/
    entry) {
      if (!loadedEntries) {
        readEntries();
      }

      entryList.push(entry);
      entryTable[entry.entryName] = entry;
      mainHeader.totalEntries = entryList.length;
    },

    /**
     * Removes the entry with the given name from the entry list.
     *
     * If the entry is a directory, then all nested files and directories will be removed
     * @param entryName
     */
    deleteEntry: function deleteEntry(
    /*String*/
    entryName) {
      if (!loadedEntries) {
        readEntries();
      }

      var entry = entryTable[entryName];

      if (entry && entry.isDirectory) {
        var _self = this;

        this.getEntryChildren(entry).forEach(function (child) {
          if (child.entryName !== entryName) {
            _self.deleteEntry(child.entryName);
          }
        });
      }

      entryList.splice(entryList.indexOf(entry), 1);
      delete entryTable[entryName];
      mainHeader.totalEntries = entryList.length;
    },

    /**
     *  Iterates and returns all nested files and directories of the given entry
     *
     * @param entry
     * @return Array
     */
    getEntryChildren: function getEntryChildren(
    /*ZipEntry*/
    entry) {
      if (!loadedEntries) {
        readEntries();
      }

      if (entry && entry.isDirectory) {
        var list = [];
        var name = entry.entryName;
        var len = name.length;
        entryList.forEach(function (zipEntry) {
          if (zipEntry.entryName.substr(0, len) === name) {
            list.push(zipEntry);
          }
        });
        return list;
      }

      return [];
    },

    /**
     * Returns the zip file
     *
     * @return Buffer
     */
    compressToBuffer: function compressToBuffer() {
      if (!loadedEntries) {
        readEntries();
      }

      sortEntries();
      var dataBlock = [];
      var entryHeaders = [];
      var totalSize = 0;
      var dindex = 0;
      mainHeader.size = 0;
      mainHeader.offset = 0;

      var _iterator = _createForOfIteratorHelper(entryList),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var entry = _step.value;
          // compress data and set local and entry header accordingly. Reason why is called first
          var compressedData = entry.getCompressedData(); // 1. construct data header

          entry.header.offset = dindex;
          var dataHeader = entry.header.dataHeaderToBinary();
          var entryNameLen = entry.rawEntryName.length; // 1.2. postheader - data after data header

          var postHeader = Buffer.alloc(entryNameLen + entry.extra.length);
          entry.rawEntryName.copy(postHeader, 0);
          postHeader.copy(entry.extra, entryNameLen); // 2. offsets

          var dataLength = dataHeader.length + postHeader.length + compressedData.length;
          dindex += dataLength; // 3. store values in sequence

          dataBlock.push(dataHeader);
          dataBlock.push(postHeader);
          dataBlock.push(compressedData); // 4. construct entry header

          var entryHeader = entry.packHeader();
          entryHeaders.push(entryHeader); // 5. update main header

          mainHeader.size += entryHeader.length;
          totalSize += dataLength + entryHeader.length;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
      // point to end of data and beginning of central directory first record

      mainHeader.offset = dindex;
      dindex = 0;
      var outBuffer = Buffer.alloc(totalSize); // write data blocks

      for (var _i = 0, _dataBlock = dataBlock; _i < _dataBlock.length; _i++) {
        var content = _dataBlock[_i];
        content.copy(outBuffer, dindex);
        dindex += content.length;
      } // write central directory entries


      for (var _i2 = 0, _entryHeaders = entryHeaders; _i2 < _entryHeaders.length; _i2++) {
        var _content = _entryHeaders[_i2];

        _content.copy(outBuffer, dindex);

        dindex += _content.length;
      } // write main header


      var mh = mainHeader.toBinary();

      if (_comment) {
        _comment.copy(mh, Utils$1.Constants.ENDHDR); // add zip file comment

      }

      mh.copy(outBuffer, dindex);
      return outBuffer;
    },
    toAsyncBuffer: function toAsyncBuffer(
    /*Function*/
    onSuccess,
    /*Function*/
    onFail,
    /*Function*/
    onItemStart,
    /*Function*/
    onItemEnd) {
      try {
        if (!loadedEntries) {
          readEntries();
        }

        sortEntries();
        var dataBlock = [];
        var entryHeaders = [];
        var totalSize = 0;
        var dindex = 0;
        mainHeader.size = 0;
        mainHeader.offset = 0;

        var compress2Buffer = function compress2Buffer(entryLists) {
          if (entryLists.length) {
            var entry = entryLists.pop();
            var name = entry.entryName + entry.extra.toString();
            if (onItemStart) onItemStart(name);
            entry.getCompressedDataAsync(function (compressedData) {
              if (onItemEnd) onItemEnd(name);
              entry.header.offset = dindex; // data header

              var dataHeader = entry.header.dataHeaderToBinary();
              var postHeader = Buffer.alloc(name.length, name);
              var dataLength = dataHeader.length + postHeader.length + compressedData.length;
              dindex += dataLength;
              dataBlock.push(dataHeader);
              dataBlock.push(postHeader);
              dataBlock.push(compressedData);
              var entryHeader = entry.packHeader();
              entryHeaders.push(entryHeader);
              mainHeader.size += entryHeader.length;
              totalSize += dataLength + entryHeader.length;
              compress2Buffer(entryLists);
            });
          } else {
            totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
            // point to end of data and beginning of central directory first record

            mainHeader.offset = dindex;
            dindex = 0;
            var outBuffer = Buffer.alloc(totalSize);
            dataBlock.forEach(function (content) {
              content.copy(outBuffer, dindex); // write data blocks

              dindex += content.length;
            });
            entryHeaders.forEach(function (content) {
              content.copy(outBuffer, dindex); // write central directory entries

              dindex += content.length;
            });
            var mh = mainHeader.toBinary();

            if (_comment) {
              _comment.copy(mh, Utils$1.Constants.ENDHDR); // add zip file comment

            }

            mh.copy(outBuffer, dindex); // write main header

            onSuccess(outBuffer);
          }
        };

        compress2Buffer(entryList);
      } catch (e) {
        onFail(e);
      }
    }
  };
};

var Utils = util$5.exports;
var pth = require$$1__default$1["default"];
var ZipEntry = zipEntry;
var ZipFile = zipFile;

var get_Bool = function get_Bool(val, def) {
  return typeof val === "boolean" ? val : def;
};

var get_Str = function get_Str(val, def) {
  return typeof val === "string" ? val : def;
};

var defaultOptions = {
  // option "noSort" : if true it disables files sorting
  noSort: false,
  // read entries during load (initial loading may be slower)
  readEntries: false,
  // default method is none
  method: Utils.Constants.NONE,
  // file system
  fs: null
};

var admZip = function admZip(
/**String*/
input,
/** object */
options) {
  var inBuffer = null; // create object based default options, allowing them to be overwritten

  var opts = Object.assign(Object.create(null), defaultOptions); // test input variable

  if (input && "object" === _typeof(input)) {
    // if value is not buffer we accept it to be object with options
    if (!(input instanceof Uint8Array)) {
      Object.assign(opts, input);
      input = opts.input ? opts.input : undefined;
      if (opts.input) delete opts.input;
    } // if input is buffer


    if (Buffer.isBuffer(input)) {
      inBuffer = input;
      opts.method = Utils.Constants.BUFFER;
      input = undefined;
    }
  } // assign options


  Object.assign(opts, options); // instanciate utils filesystem

  var filetools = new Utils(opts); // if input is file name we retrieve its content

  if (input && "string" === typeof input) {
    // load zip file
    if (filetools.fs.existsSync(input)) {
      opts.method = Utils.Constants.FILE;
      opts.filename = input;
      inBuffer = filetools.fs.readFileSync(input);
    } else {
      throw new Error(Utils.Errors.INVALID_FILENAME);
    }
  } // create variable


  var _zip = new ZipFile(inBuffer, opts);

  var canonical = Utils.canonical,
      sanitize = Utils.sanitize;

  function _getEntry(
  /**Object*/
  entry) {
    if (entry && _zip) {
      var item; // If entry was given as a file name

      if (typeof entry === "string") item = _zip.getEntry(entry); // if entry was given as a ZipEntry object

      if (_typeof(entry) === "object" && typeof entry.entryName !== "undefined" && typeof entry.header !== "undefined") item = _zip.getEntry(entry.entryName);

      if (item) {
        return item;
      }
    }

    return null;
  }

  function fixPath(zipPath) {
    var _pth$posix = pth.posix,
        join = _pth$posix.join,
        normalize = _pth$posix.normalize,
        sep = _pth$posix.sep; // convert windows file separators and normalize

    return join(".", normalize(sep + zipPath.split("\\").join(sep) + sep));
  }

  return {
    /**
     * Extracts the given entry from the archive and returns the content as a Buffer object
     * @param entry ZipEntry object or String with the full path of the entry
     *
     * @return Buffer or Null in case of error
     */
    readFile: function readFile(
    /**Object*/
    entry,
    /*String, Buffer*/
    pass) {
      var item = _getEntry(entry);

      return item && item.getData(pass) || null;
    },

    /**
     * Asynchronous readFile
     * @param entry ZipEntry object or String with the full path of the entry
     * @param callback
     *
     * @return Buffer or Null in case of error
     */
    readFileAsync: function readFileAsync(
    /**Object*/
    entry,
    /**Function*/
    callback) {
      var item = _getEntry(entry);

      if (item) {
        item.getDataAsync(callback);
      } else {
        callback(null, "getEntry failed for:" + entry);
      }
    },

    /**
     * Extracts the given entry from the archive and returns the content as plain text in the given encoding
     * @param entry ZipEntry object or String with the full path of the entry
     * @param encoding Optional. If no encoding is specified utf8 is used
     *
     * @return String
     */
    readAsText: function readAsText(
    /**Object*/
    entry,
    /**String=*/
    encoding) {
      var item = _getEntry(entry);

      if (item) {
        var data = item.getData();

        if (data && data.length) {
          return data.toString(encoding || "utf8");
        }
      }

      return "";
    },

    /**
     * Asynchronous readAsText
     * @param entry ZipEntry object or String with the full path of the entry
     * @param callback
     * @param encoding Optional. If no encoding is specified utf8 is used
     *
     * @return String
     */
    readAsTextAsync: function readAsTextAsync(
    /**Object*/
    entry,
    /**Function*/
    callback,
    /**String=*/
    encoding) {
      var item = _getEntry(entry);

      if (item) {
        item.getDataAsync(function (data, err) {
          if (err) {
            callback(data, err);
            return;
          }

          if (data && data.length) {
            callback(data.toString(encoding || "utf8"));
          } else {
            callback("");
          }
        });
      } else {
        callback("");
      }
    },

    /**
     * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
     *
     * @param entry
     */
    deleteFile: function deleteFile(
    /**Object*/
    entry) {
      // @TODO: test deleteFile
      var item = _getEntry(entry);

      if (item) {
        _zip.deleteEntry(item.entryName);
      }
    },

    /**
     * Adds a comment to the zip. The zip must be rewritten after adding the comment.
     *
     * @param comment
     */
    addZipComment: function addZipComment(
    /**String*/
    comment) {
      // @TODO: test addZipComment
      _zip.comment = comment;
    },

    /**
     * Returns the zip comment
     *
     * @return String
     */
    getZipComment: function getZipComment() {
      return _zip.comment || "";
    },

    /**
     * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
     * The comment cannot exceed 65535 characters in length
     *
     * @param entry
     * @param comment
     */
    addZipEntryComment: function addZipEntryComment(
    /**Object*/
    entry,
    /**String*/
    comment) {
      var item = _getEntry(entry);

      if (item) {
        item.comment = comment;
      }
    },

    /**
     * Returns the comment of the specified entry
     *
     * @param entry
     * @return String
     */
    getZipEntryComment: function getZipEntryComment(
    /**Object*/
    entry) {
      var item = _getEntry(entry);

      if (item) {
        return item.comment || "";
      }

      return "";
    },

    /**
     * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
     *
     * @param entry
     * @param content
     */
    updateFile: function updateFile(
    /**Object*/
    entry,
    /**Buffer*/
    content) {
      var item = _getEntry(entry);

      if (item) {
        item.setData(content);
      }
    },

    /**
     * Adds a file from the disk to the archive
     *
     * @param localPath File to add to zip
     * @param zipPath Optional path inside the zip
     * @param zipName Optional name for the file
     */
    addLocalFile: function addLocalFile(
    /**String*/
    localPath,
    /**String=*/
    zipPath,
    /**String=*/
    zipName,
    /**String*/
    comment) {
      if (filetools.fs.existsSync(localPath)) {
        // fix ZipPath
        zipPath = zipPath ? fixPath(zipPath) : ""; // p - local file name

        var p = localPath.split("\\").join("/").split("/").pop(); // add file name into zippath

        zipPath += zipName ? zipName : p; // read file attributes

        var _attr = filetools.fs.statSync(localPath); // add file into zip file


        this.addFile(zipPath, filetools.fs.readFileSync(localPath), comment, _attr);
      } else {
        throw new Error(Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
      }
    },

    /**
     * Adds a local directory and all its nested files and directories to the archive
     *
     * @param localPath
     * @param zipPath optional path inside zip
     * @param filter optional RegExp or Function if files match will
     *               be included.
     */
    addLocalFolder: function addLocalFolder(
    /**String*/
    localPath,
    /**String=*/
    zipPath,
    /**=RegExp|Function*/
    filter) {
      // Prepare filter
      if (filter instanceof RegExp) {
        // if filter is RegExp wrap it
        filter = function (rx) {
          return function (filename) {
            return rx.test(filename);
          };
        }(filter);
      } else if ("function" !== typeof filter) {
        // if filter is not function we will replace it
        filter = function filter() {
          return true;
        };
      } // fix ZipPath


      zipPath = zipPath ? fixPath(zipPath) : ""; // normalize the path first

      localPath = pth.normalize(localPath);

      if (filetools.fs.existsSync(localPath)) {
        var items = filetools.findFiles(localPath);
        var self = this;

        if (items.length) {
          items.forEach(function (filepath) {
            var p = pth.relative(localPath, filepath).split("\\").join("/"); //windows fix

            if (filter(p)) {
              var stats = filetools.fs.statSync(filepath);

              if (stats.isFile()) {
                self.addFile(zipPath + p, filetools.fs.readFileSync(filepath), "", stats);
              } else {
                self.addFile(zipPath + p + "/", Buffer.alloc(0), "", stats);
              }
            }
          });
        }
      } else {
        throw new Error(Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
      }
    },

    /**
     * Asynchronous addLocalFile
     * @param localPath
     * @param callback
     * @param zipPath optional path inside zip
     * @param filter optional RegExp or Function if files match will
     *               be included.
     */
    addLocalFolderAsync: function addLocalFolderAsync(
    /*String*/
    localPath,
    /*Function*/
    callback,
    /*String*/
    zipPath,
    /*RegExp|Function*/
    filter) {
      if (filter instanceof RegExp) {
        filter = function (rx) {
          return function (filename) {
            return rx.test(filename);
          };
        }(filter);
      } else if ("function" !== typeof filter) {
        filter = function filter() {
          return true;
        };
      } // fix ZipPath


      zipPath = zipPath ? fixPath(zipPath) : ""; // normalize the path first

      localPath = pth.normalize(localPath);
      var self = this;
      filetools.fs.open(localPath, "r", function (err) {
        if (err && err.code === "ENOENT") {
          callback(undefined, Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
        } else if (err) {
          callback(undefined, err);
        } else {
          var items = filetools.findFiles(localPath);
          var i = -1;

          var next = function next() {
            i += 1;

            if (i < items.length) {
              var filepath = items[i];
              var p = pth.relative(localPath, filepath).split("\\").join("/"); //windows fix

              p = p.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, ""); // accent fix

              if (filter(p)) {
                filetools.fs.stat(filepath, function (er0, stats) {
                  if (er0) callback(undefined, er0);

                  if (stats.isFile()) {
                    filetools.fs.readFile(filepath, function (er1, data) {
                      if (er1) {
                        callback(undefined, er1);
                      } else {
                        self.addFile(zipPath + p, data, "", stats);
                        next();
                      }
                    });
                  } else {
                    self.addFile(zipPath + p + "/", Buffer.alloc(0), "", stats);
                    next();
                  }
                });
              } else {
                next();
              }
            } else {
              callback(true, undefined);
            }
          };

          next();
        }
      });
    },

    /**
     *
     * @param {string} localPath - path where files will be extracted
     * @param {object} props - optional properties
     * @param {string} props.zipPath - optional path inside zip
     * @param {regexp, function} props.filter - RegExp or Function if files match will be included.
     */
    addLocalFolderPromise: function addLocalFolderPromise(
    /*String*/
    localPath,
    /* object */
    props) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var _Object$assign = Object.assign({}, props),
            filter = _Object$assign.filter,
            zipPath = _Object$assign.zipPath;

        _this.addLocalFolderAsync(localPath, function (done, err) {
          if (err) reject(err);
          if (done) resolve(_this);
        }, zipPath, filter);
      });
    },

    /**
     * Allows you to create a entry (file or directory) in the zip file.
     * If you want to create a directory the entryName must end in / and a null buffer should be provided.
     * Comment and attributes are optional
     *
     * @param {string} entryName
     * @param {Buffer | string} content - file content as buffer or utf8 coded string
     * @param {string} comment - file comment
     * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object
     */
    addFile: function addFile(
    /**String*/
    entryName,
    /**Buffer*/
    content,
    /**String*/
    comment,
    /**Number*/
    attr) {
      var entry = _getEntry(entryName);

      var update = entry != null; // prepare new entry

      if (!update) {
        entry = new ZipEntry();
        entry.entryName = entryName;
      }

      entry.comment = comment || "";
      var isStat = "object" === _typeof(attr) && attr instanceof filetools.fs.Stats; // last modification time from file stats

      if (isStat) {
        entry.header.time = attr.mtime;
      } // Set file attribute


      var fileattr = entry.isDirectory ? 0x10 : 0; // (MS-DOS directory flag)
      // extended attributes field for Unix

      if (!Utils.isWin) {
        // set file type either S_IFDIR / S_IFREG
        var unix = entry.isDirectory ? 0x4000 : 0x8000;

        if (isStat) {
          // File attributes from file stats
          unix |= 0xfff & attr.mode;
        } else if ("number" === typeof attr) {
          // attr from given attr values
          unix |= 0xfff & attr;
        } else {
          // Default values:
          unix |= entry.isDirectory ? 493 : 420; // permissions (drwxr-xr-x) or (-r-wr--r--)
        }

        fileattr = (fileattr | unix << 16) >>> 0; // add attributes
      }

      entry.attr = fileattr;
      entry.setData(content);
      if (!update) _zip.setEntry(entry);
    },

    /**
     * Returns an array of ZipEntry objects representing the files and folders inside the archive
     *
     * @return Array
     */
    getEntries: function getEntries() {
      return _zip ? _zip.entries : [];
    },

    /**
     * Returns a ZipEntry object representing the file or folder specified by ``name``.
     *
     * @param name
     * @return ZipEntry
     */
    getEntry: function getEntry(
    /**String*/
    name) {
      return _getEntry(name);
    },
    getEntryCount: function getEntryCount() {
      return _zip.getEntryCount();
    },
    forEach: function forEach(callback) {
      return _zip.forEach(callback);
    },

    /**
     * Extracts the given entry to the given targetPath
     * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
     *
     * @param entry ZipEntry object or String with the full path of the entry
     * @param targetPath Target folder where to write the file
     * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder
     *                          will be created in targetPath as well. Default is TRUE
     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     * @param outFileName String If set will override the filename of the extracted file (Only works if the entry is a file)
     *
     * @return Boolean
     */
    extractEntryTo: function extractEntryTo(
    /**Object*/
    entry,
    /**String*/
    targetPath,
    /**Boolean*/
    maintainEntryPath,
    /**Boolean*/
    overwrite,
    /**Boolean*/
    keepOriginalPermission,
    /**String**/
    outFileName) {
      overwrite = get_Bool(overwrite, false);
      keepOriginalPermission = get_Bool(keepOriginalPermission, false);
      maintainEntryPath = get_Bool(maintainEntryPath, true);
      outFileName = get_Str(outFileName, get_Str(keepOriginalPermission, undefined));

      var item = _getEntry(entry);

      if (!item) {
        throw new Error(Utils.Errors.NO_ENTRY);
      }

      var entryName = canonical(item.entryName);
      var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));

      if (item.isDirectory) {
        var children = _zip.getEntryChildren(item);

        children.forEach(function (child) {
          if (child.isDirectory) return;
          var content = child.getData();

          if (!content) {
            throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
          }

          var name = canonical(child.entryName);
          var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name)); // The reverse operation for attr depend on method addFile()

          var fileAttr = keepOriginalPermission ? child.header.fileAttr : undefined;
          filetools.writeFileTo(childName, content, overwrite, fileAttr);
        });
        return true;
      }

      var content = item.getData();
      if (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);

      if (filetools.fs.existsSync(target) && !overwrite) {
        throw new Error(Utils.Errors.CANT_OVERRIDE);
      } // The reverse operation for attr depend on method addFile()


      var fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
      filetools.writeFileTo(target, content, overwrite, fileAttr);
      return true;
    },

    /**
     * Test the archive
     *
     */
    test: function test(pass) {
      if (!_zip) {
        return false;
      }

      for (var entry in _zip.entries) {
        try {
          if (entry.isDirectory) {
            continue;
          }

          var content = _zip.entries[entry].getData(pass);

          if (!content) {
            return false;
          }
        } catch (err) {
          return false;
        }
      }

      return true;
    },

    /**
     * Extracts the entire archive to the given location
     *
     * @param targetPath Target location
     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     */
    extractAllTo: function extractAllTo(
    /**String*/
    targetPath,
    /**Boolean*/
    overwrite,
    /**Boolean*/
    keepOriginalPermission,
    /*String, Buffer*/
    pass) {
      overwrite = get_Bool(overwrite, false);
      pass = get_Str(keepOriginalPermission, pass);
      keepOriginalPermission = get_Bool(keepOriginalPermission, false);

      if (!_zip) {
        throw new Error(Utils.Errors.NO_ZIP);
      }

      _zip.entries.forEach(function (entry) {
        var entryName = sanitize(targetPath, canonical(entry.entryName.toString()));

        if (entry.isDirectory) {
          filetools.makeDir(entryName);
          return;
        }

        var content = entry.getData(pass);

        if (!content) {
          throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
        } // The reverse operation for attr depend on method addFile()


        var fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
        filetools.writeFileTo(entryName, content, overwrite, fileAttr);

        try {
          filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);
        } catch (err) {
          throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
        }
      });
    },

    /**
     * Asynchronous extractAllTo
     *
     * @param targetPath Target location
     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
     *                  Default is FALSE
     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
     *                  Default is FALSE
     * @param callback The callback will be executed when all entries are extracted successfully or any error is thrown.
     */
    extractAllToAsync: function extractAllToAsync(
    /**String*/
    targetPath,
    /**Boolean*/
    overwrite,
    /**Boolean*/
    keepOriginalPermission,
    /**Function*/
    callback) {
      if (!callback) {
        callback = function callback() {};
      }

      overwrite = get_Bool(overwrite, false);
      if (typeof keepOriginalPermission === "function" && !callback) callback = keepOriginalPermission;
      keepOriginalPermission = get_Bool(keepOriginalPermission, false);

      if (!_zip) {
        callback(new Error(Utils.Errors.NO_ZIP));
        return;
      }

      targetPath = pth.resolve(targetPath); // convert entryName to

      var getPath = function getPath(entry) {
        return sanitize(targetPath, pth.normalize(canonical(entry.entryName.toString())));
      };

      var getError = function getError(msg, file) {
        return new Error(msg + ': "' + file + '"');
      }; // separate directories from files


      var dirEntries = [];
      var fileEntries = new Set();

      _zip.entries.forEach(function (e) {
        if (e.isDirectory) {
          dirEntries.push(e);
        } else {
          fileEntries.add(e);
        }
      }); // Create directory entries first synchronously
      // this prevents race condition and assures folders are there before writing files


      for (var _i = 0, _dirEntries = dirEntries; _i < _dirEntries.length; _i++) {
        var entry = _dirEntries[_i];
        var dirPath = getPath(entry); // The reverse operation for attr depend on method addFile()

        var dirAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;

        try {
          filetools.makeDir(dirPath);
          if (dirAttr) filetools.fs.chmodSync(dirPath, dirAttr); // in unix timestamp will change if files are later added to folder, but still

          filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);
        } catch (er) {
          callback(getError("Unable to create folder", dirPath));
        }
      } // callback wrapper, for some house keeping


      var done = function done() {
        if (fileEntries.size === 0) {
          callback();
        }
      }; // Extract file entries asynchronously


      var _iterator = _createForOfIteratorHelper(fileEntries.values()),
          _step;

      try {
        var _loop = function _loop() {
          var entry = _step.value;
          var entryName = pth.normalize(canonical(entry.entryName.toString()));
          var filePath = sanitize(targetPath, entryName);
          entry.getDataAsync(function (content, err_1) {
            if (err_1) {
              callback(new Error(err_1));
              return;
            }

            if (!content) {
              callback(new Error(Utils.Errors.CANT_EXTRACT_FILE));
            } else {
              // The reverse operation for attr depend on method addFile()
              var fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
              filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function (succ) {
                if (!succ) {
                  callback(getError("Unable to write file", filePath));
                  return;
                }

                filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function (err_2) {
                  if (err_2) {
                    callback(getError("Unable to set times", filePath));
                    return;
                  }

                  fileEntries["delete"](entry); // call the callback if it was last entry

                  done();
                });
              });
            }
          });
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        } // call the callback if fileEntries was empty

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      done();
    },

    /**
     * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
     *
     * @param targetFileName
     * @param callback
     */
    writeZip: function writeZip(
    /**String*/
    targetFileName,
    /**Function*/
    callback) {
      if (arguments.length === 1) {
        if (typeof targetFileName === "function") {
          callback = targetFileName;
          targetFileName = "";
        }
      }

      if (!targetFileName && opts.filename) {
        targetFileName = opts.filename;
      }

      if (!targetFileName) return;

      var zipData = _zip.compressToBuffer();

      if (zipData) {
        var ok = filetools.writeFileTo(targetFileName, zipData, true);
        if (typeof callback === "function") callback(!ok ? new Error("failed") : null, "");
      }
    },
    writeZipPromise: function writeZipPromise(
    /**String*/
    targetFileName,
    /* object */
    props) {
      var _this2 = this;

      var _Object$assign2 = Object.assign({
        overwrite: true
      }, props),
          overwrite = _Object$assign2.overwrite,
          perm = _Object$assign2.perm;

      return new Promise(function (resolve, reject) {
        // find file name
        if (!targetFileName && opts.filename) targetFileName = opts.filename;
        if (!targetFileName) reject("ADM-ZIP: ZIP File Name Missing");

        _this2.toBufferPromise().then(function (zipData) {
          var ret = function ret(done) {
            return done ? resolve(done) : reject("ADM-ZIP: Wasn't able to write zip file");
          };

          filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);
        }, reject);
      });
    },
    toBufferPromise: function toBufferPromise() {
      return new Promise(function (resolve, reject) {
        _zip.toAsyncBuffer(resolve, reject);
      });
    },

    /**
     * Returns the content of the entire zip file as a Buffer object
     *
     * @return Buffer
     */
    toBuffer: function toBuffer(
    /**Function=*/
    onSuccess,
    /**Function=*/
    onFail,
    /**Function=*/
    onItemStart,
    /**Function=*/
    onItemEnd) {
      this.valueOf = 2;

      if (typeof onSuccess === "function") {
        _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);

        return null;
      }

      return _zip.compressToBuffer();
    }
  };
};

var https = require$$0__default$9["default"];
var fs = require$$0__default$6["default"];
var util$4 = require$$0__default$1["default"];
var AdmZip = admZip;
var URL$1 = require$$4__default["default"].URL;
var errors$4 = errors$s;
var utils$b = utils$V;
var DsePlainTextAuthProvider = auth$1.DsePlainTextAuthProvider,
    NoAuthProvider = auth$1.NoAuthProvider; // Use the callback-based method fs.readFile() instead of fs.promises as we have to support Node.js 8+

var readFile = util$4.promisify(fs.readFile);
/**
 * When the user sets the cloud options, it uses the secure bundle or endpoint to access the metadata service and
 * setting the connection options
 * @param {ClientOptions} options
 * @returns {Promise<void>}
 */

function init(_x) {
  return _init.apply(this, arguments);
}

function _init() {
  _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(options) {
    var cloudOptions;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (options.cloud) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return");

          case 2:
            cloudOptions = new CloudOptions(options);
            _context.next = 5;
            return parseZipFile(cloudOptions);

          case 5:
            _context.next = 7;
            return getMetadataServiceInfoAsync(cloudOptions);

          case 7:
            if (!cloudOptions.clientOptions.sslOptions.checkServerIdentity) {
              // With SNI enabled, hostname (uuid) and CN will not match
              // Use a custom validation function to validate against the proxy address.
              // Note: this function is only called if the certificate passed all other checks, like CA validation.
              cloudOptions.clientOptions.sslOptions.checkServerIdentity = function (_, cert) {
                return checkServerIdentity(cert, cloudOptions.clientOptions.sni.address);
              };
            }

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _init.apply(this, arguments);
}

var CloudOptions = /*#__PURE__*/function () {
  function CloudOptions(clientOptions) {
    _classCallCheck(this, CloudOptions);

    this.clientOptions = clientOptions;

    if (clientOptions.cloud.secureConnectBundle) {
      this.secureConnectBundle = clientOptions.cloud.secureConnectBundle;
      this.serviceUrl = null;
    } else {
      this.serviceUrl = clientOptions.cloud.endpoint;
    }

    this.contactPoints = null;
    this.localDataCenter = null;
  }
  /**
   * The sslOptions in the client options from a given map.
   * @param {Map<String, Buffer>} zipEntries
   */


  _createClass(CloudOptions, [{
    key: "setSslOptions",
    value: function setSslOptions(zipEntries) {
      this.clientOptions.sslOptions = Object.assign({
        ca: [zipEntries.get('ca.crt')],
        cert: zipEntries.get('cert'),
        key: zipEntries.get('key'),
        rejectUnauthorized: true
      }, this.clientOptions.sslOptions);
    }
    /**
     *
     * @param username
     * @param password
     */

  }, {
    key: "setAuthProvider",
    value: function setAuthProvider(username, password) {
      if (!username || !password) {
        return;
      }

      if (this.clientOptions.authProvider && !(this.clientOptions.authProvider instanceof NoAuthProvider)) {
        // There is an auth provider set by the user
        return;
      }

      this.clientOptions.authProvider = new DsePlainTextAuthProvider(username, password);
    }
  }]);

  return CloudOptions;
}();
/**
 * @param {CloudOptions} cloudOptions
 * @returns {Promise<void>}
 */


function parseZipFile(_x2) {
  return _parseZipFile.apply(this, arguments);
}
/**
 * Gets the information retrieved from the metadata service.
 * Invokes the callback with {proxyAddress, localDataCenter, contactPoints} as result
 * @param {CloudOptions} cloudOptions
 * @param {Function} callback
 */


function _parseZipFile() {
  _parseZipFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(cloudOptions) {
    var data, zip, zipEntries, config;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!cloudOptions.serviceUrl) {
              _context2.next = 2;
              break;
            }

            return _context2.abrupt("return");

          case 2:
            if (cloudOptions.secureConnectBundle) {
              _context2.next = 4;
              break;
            }

            throw new TypeError('secureConnectBundle must be provided');

          case 4:
            _context2.next = 6;
            return readFile(cloudOptions.secureConnectBundle);

          case 6:
            data = _context2.sent;
            zip = new AdmZip(data);
            zipEntries = new Map(zip.getEntries().map(function (e) {
              return [e.entryName, e.getData()];
            }));

            if (zipEntries.get('config.json')) {
              _context2.next = 11;
              break;
            }

            throw new TypeError('Config file must be contained in secure bundle');

          case 11:
            config = JSON.parse(zipEntries.get('config.json').toString('utf8'));

            if (!(!config['host'] || !config['port'])) {
              _context2.next = 14;
              break;
            }

            throw new TypeError('Config file must include host and port information');

          case 14:
            cloudOptions.serviceUrl = "".concat(config['host'], ":").concat(config['port'], "/metadata");
            cloudOptions.setSslOptions(zipEntries);
            cloudOptions.setAuthProvider(config.username, config.password);

          case 17:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseZipFile.apply(this, arguments);
}

function getMetadataServiceInfo(cloudOptions, callback) {
  var regex = /^(.+?):(\d+)(.*)$/;
  var matches = regex.exec(cloudOptions.serviceUrl);
  callback = utils$b.callbackOnce(callback);

  if (!matches || matches.length !== 4) {
    throw new TypeError('url should be composed of host, port number and path, without scheme');
  }

  var requestOptions = Object.assign({
    hostname: matches[1],
    port: matches[2],
    path: matches[3] || undefined,
    timeout: cloudOptions.clientOptions.socketOptions.connectTimeout
  }, cloudOptions.clientOptions.sslOptions);
  var req = https.get(requestOptions, function (res) {
    var data = '';
    res.on('data', function (chunk) {
      return data += chunk.toString();
    }).on('end', function () {
      if (res.statusCode !== 200) {
        return callback(getServiceRequestError(new Error("Obtained http status ".concat(res.statusCode)), requestOptions));
      }

      var message;

      try {
        message = JSON.parse(data);

        if (!message || !message['contact_info']) {
          throw new TypeError('contact_info should be defined in response');
        }
      } catch (err) {
        return callback(getServiceRequestError(err, requestOptions, true));
      }

      var contactInfo = message['contact_info']; // Set the connect options

      cloudOptions.clientOptions.contactPoints = contactInfo['contact_points'];
      cloudOptions.clientOptions.localDataCenter = contactInfo['local_dc'];
      cloudOptions.clientOptions.sni = {
        address: contactInfo['sni_proxy_address']
      };
      callback();
    });
  });
  req.on('error', function (err) {
    return callback(getServiceRequestError(err, requestOptions));
  }); // We need to both set the timeout in the requestOptions and invoke ClientRequest#setTimeout()
  // to handle all possible scenarios, for some reason... (tested with one OR the other and didn't fully work)
  // Setting the also the timeout handler, aborting will emit 'error' and close

  req.setTimeout(cloudOptions.clientOptions.socketOptions.connectTimeout, function () {
    return req.abort();
  });
}

var getMetadataServiceInfoAsync = util$4.promisify(getMetadataServiceInfo);
/**
 * Returns an Error that wraps the inner error obtained while fetching metadata information.
 * @private
 */

function getServiceRequestError(err, requestOptions, isParsingError) {
  var message = isParsingError ? 'There was an error while parsing the metadata service information' : 'There was an error fetching the metadata information';
  var url = "".concat(requestOptions.hostname, ":").concat(requestOptions.port).concat(requestOptions.path ? requestOptions.path : '/');
  return new errors$4.NoHostAvailableError(_defineProperty({}, url, err), message);
}
/**
 * @param {{subject: {CN: string}, subjectaltname: string?}} cert A certificate object as defined by
 * TLS module https://nodejs.org/docs/latest-v12.x/api/tls.html#tls_certificate_object
 * @param {string} sniAddress
 * @returns {Error|undefined} Similar to tls.checkServerIdentity() returns an Error object, populating it with reason,
 * host, and cert on failure. Otherwise, it returns undefined.
 * @internal
 * @ignore
 */


function checkServerIdentity(cert, sniAddress) {
  // Based on logic defined by the Node.js Core module
  // https://github.com/nodejs/node/blob/ff48009fefcecedfee2c6ff1719e5be3f6969049/lib/tls.js#L212-L290
  // SNI address is composed by hostname and port
  var hostName = sniAddress.split(':')[0];
  var altNames = cert.subjectaltname;
  var cn = cert.subject.CN;

  if (hostName === cn) {
    // quick check based on common name
    return undefined;
  }

  var parsedAltNames = [];

  if (altNames) {
    var _iterator = _createForOfIteratorHelper(altNames.split(', ')),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var name = _step.value;

        if (name.startsWith('DNS:')) {
          parsedAltNames.push(name.slice(4));
        } else if (name.startsWith('URI:')) {
          parsedAltNames.push(new URL$1(name.slice(4)).hostname);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  var hostParts = hostName.split('.');

  var wildcard = function wildcard(pattern) {
    return checkParts(hostParts, pattern);
  };

  var valid;

  if (parsedAltNames.length > 0) {
    valid = parsedAltNames.some(wildcard);
  } else {
    // Use the common name
    valid = wildcard(cn);
  }

  if (!valid) {
    var error = new Error("Host: ".concat(hostName, " is not cert's CN/altnames: ").concat(cn, " / ").concat(altNames));
    error.reason = error.message;
    error.host = hostName;
    error.cert = cert;
    return error;
  }
}
/**
 * Simplified version of Node.js tls core lib check() function
 * https://github.com/nodejs/node/blob/ff48009fefcecedfee2c6ff1719e5be3f6969049/lib/tls.js#L148-L209
 * @private
 * @returns {boolean}
 */


function checkParts(hostParts, pattern) {
  // Empty strings, null, undefined, etc. never match.
  if (!pattern) {
    return false;
  }

  var patternParts = pattern.split('.');

  if (hostParts.length !== patternParts.length) {
    return false;
  } // Check host parts from right to left first.


  for (var i = hostParts.length - 1; i > 0; i -= 1) {
    if (hostParts[i] !== patternParts[i]) {
      return false;
    }
  }

  var hostSubdomain = hostParts[0];
  var patternSubdomain = patternParts[0];
  var patternSubdomainParts = patternSubdomain.split('*'); // Short-circuit when the subdomain does not contain a wildcard.
  // RFC 6125 does not allow wildcard substitution for components
  // containing IDNA A-labels (Punycode) so match those verbatim.

  if (patternSubdomainParts.length === 1 || patternSubdomain.includes('xn--')) {
    return hostSubdomain === patternSubdomain;
  } // More than one wildcard is always wrong.


  if (patternSubdomainParts.length > 2) {
    return false;
  } // *.tld wildcards are not allowed.


  if (patternParts.length <= 2) {
    return false;
  }

  var _patternSubdomainPart = _slicedToArray(patternSubdomainParts, 2),
      prefix = _patternSubdomainPart[0],
      suffix = _patternSubdomainPart[1];

  if (prefix.length + suffix.length > hostSubdomain.length) {
    return false;
  }

  if (!hostSubdomain.startsWith(prefix)) {
    return false;
  }

  if (!hostSubdomain.endsWith(suffix)) {
    return false;
  }

  return true;
}

var cloud$1 = {
  checkServerIdentity: checkServerIdentity,
  init: init
};

var utils$a = utils$V;
/**
 * Creates a new instance of <code>GraphResultSet</code>.
 * @class
 * @classdesc
 * Represents the result set of a [graph query execution]{@link Client#executeGraph} containing vertices, edges or
 * scalar values depending on the query.
 * <p>
 * It allows iteration of the items using <code>for..of</code> statements under ES2015 and exposes
 * <code>forEach()</code>, <code>first()</code> and <code>toArray()</code> to access the underlying items.
 * </p>
 * @example
 * for (let vertex of result} { ... }
 * @example
 * const arr = result.toArray();
 * @example
 * const vertex = result.first();
 * @param {ResultSet} result
 * @param {Function} [rowParser]
 * @alias module:datastax/graph~GraphResultSet
 * @constructor
 */

function GraphResultSet$2(result, rowParser) {
  /**
   * Information on the execution of a successful query:
   * @member {Object}
   * @property {Number} achievedConsistency The consistency level that has been actually achieved by the query.
   * @property {String} queriedHost The Cassandra host that coordinated this query.
   * @property {Object} triedHosts Gets the associative array of host that were queried before getting a valid response,
   * being the last host the one that replied correctly.
   * @property {Uuid} traceId Identifier of the trace session.
   * @property {Array.<string>} warnings Warning messages generated by the server when executing the query.
   */
  this.info = result.info;
  var rows = result.rows;
  rowParser = rowParser || parsePlainJsonRow;
  /**
   * This property has been deprecated because it may return a lower value than the actual length of the results.
   * Use <code>toArray()</code> instead.
   * <p>Gets the length of the result.</p>
   * @deprecated Use <code>toArray()</code> instead. This property will be removed in the following major version.
   * @member {Number}
   */

  this.length = result.rowLength;
  /**
   * A string token representing the current page state of query. It can be used in the following executions to
   * continue paging and retrieve the remained of the result for the query.
   * @member {String}
   */

  this.pageState = result.pageState;
  /**
   * Returns the first element of the result or null if the result is empty.
   * @returns {Object}
   */

  this.first = function first() {
    var iterator = this.values();
    var item = iterator.next();

    if (item.done) {
      return null;
    }

    return item.value;
  };
  /**
   * Executes a provided function once per result element.
   * @param {Function} callback Function to execute for each element, taking two arguments: currentValue and index.
   * @param {Object} [thisArg] Value to use as <code>this</code> when executing callback.
   */


  this.forEach = function forEach(callback, thisArg) {
    if (!rows.length) {
      return;
    }

    var iterator = this.values();
    var item = iterator.next();
    var index = 0;

    while (!item.done) {
      callback.call(thisArg || this, item.value, index++);
      item = iterator.next();
    }
  };
  /**
   * Results an Array of graph result elements (vertex, edge, scalar).
   * @returns {Array}
   */


  this.toArray = function toArray() {
    if (!rows.length) {
      return utils$a.emptyArray;
    }

    return utils$a.iteratorToArray(this.values());
  };
  /**
   * Returns a new Iterator object that contains the values for each index in the result.
   * @returns {Iterator}
   */


  this.values = /*#__PURE__*/regeneratorRuntime.mark(function values() {
    var _iterator, _step, traverser, bulk, j;

    return regeneratorRuntime.wrap(function values$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _iterator = _createForOfIteratorHelper(this.getTraversers());
            _context.prev = 1;

            _iterator.s();

          case 3:
            if ((_step = _iterator.n()).done) {
              _context.next = 15;
              break;
            }

            traverser = _step.value;
            bulk = traverser.bulk || 1;
            j = 0;

          case 7:
            if (!(j < bulk)) {
              _context.next = 13;
              break;
            }

            _context.next = 10;
            return traverser.object;

          case 10:
            j++;
            _context.next = 7;
            break;

          case 13:
            _context.next = 3;
            break;

          case 15:
            _context.next = 20;
            break;

          case 17:
            _context.prev = 17;
            _context.t0 = _context["catch"](1);

            _iterator.e(_context.t0);

          case 20:
            _context.prev = 20;

            _iterator.f();

            return _context.finish(20);

          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, values, this, [[1, 17, 20, 23]]);
  });
  /**
   * Gets the traversers represented contained in the result set.
   * @returns {Iterator}
   */

  this.getTraversers = /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var _iterator2, _step2, row;

    return regeneratorRuntime.wrap(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _iterator2 = _createForOfIteratorHelper(rows);
            _context2.prev = 1;

            _iterator2.s();

          case 3:
            if ((_step2 = _iterator2.n()).done) {
              _context2.next = 9;
              break;
            }

            row = _step2.value;
            _context2.next = 7;
            return rowParser(row);

          case 7:
            _context2.next = 3;
            break;

          case 9:
            _context2.next = 14;
            break;

          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2["catch"](1);

            _iterator2.e(_context2.t0);

          case 14:
            _context2.prev = 14;

            _iterator2.f();

            return _context2.finish(14);

          case 17:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee, null, [[1, 11, 14, 17]]);
  });
}

if (typeof Symbol !== 'undefined' && _typeof(Symbol.iterator) === 'symbol') {
  // Make iterable
  GraphResultSet$2.prototype[Symbol.iterator] = function getIterator() {
    return this.values();
  };
}
/**
 * @param {Row} row
 * @private
 */


function parsePlainJsonRow(row) {
  var parsed = JSON.parse(row['gremlin']);
  return {
    object: parsed.result,
    bulk: parsed.bulk || 1
  };
}

var resultSet = GraphResultSet$2;

var types$6 = types$u;
var dataTypes$3 = types$6.dataTypes;
/**
 * Internal representation of a value with additional type information.
 * @internal
 * @ignore
 */

var GraphTypeWrapper$3 = /*#__PURE__*/_createClass(function GraphTypeWrapper(value, typeInfo) {
  _classCallCheck(this, GraphTypeWrapper);

  this.value = value;
  this.typeInfo = typeof typeInfo === 'number' ? {
    code: typeInfo
  } : typeInfo;
});
/**
 * Internal representation of user-defined type with the metadata.
 * @internal
 * @ignore
 */


var UdtGraphWrapper$3 = /*#__PURE__*/_createClass(function UdtGraphWrapper(value, udtInfo) {
  _classCallCheck(this, UdtGraphWrapper);

  this.value = value;

  if (!udtInfo || !udtInfo.name || !udtInfo.keyspace || !udtInfo.fields) {
    throw new TypeError("udtInfo must be an object with name, keyspace and field properties defined");
  }

  this.udtInfo = udtInfo;
});
/**
 * Wraps a number or null value to hint the client driver that the data type of the value is an int
 * @memberOf module:datastax/graph
 */


function asInt$1(value) {
  return new GraphTypeWrapper$3(value, dataTypes$3["int"]);
}
/**
 * Wraps a number or null value to hint the client driver that the data type of the value is a double
 * @memberOf module:datastax/graph
 */


function asDouble$1(value) {
  return new GraphTypeWrapper$3(value, dataTypes$3["double"]);
}
/**
 * Wraps a number or null value to hint the client driver that the data type of the value is a double
 * @memberOf module:datastax/graph
 */


function asFloat$1(value) {
  return new GraphTypeWrapper$3(value, dataTypes$3["float"]);
}
/**
 * Wraps a Date or null value to hint the client driver that the data type of the value is a timestamp
 * @memberOf module:datastax/graph
 */


function asTimestamp$1(value) {
  return new GraphTypeWrapper$3(value, dataTypes$3.timestamp);
}
/**
 * Wraps an Object or null value to hint the client driver that the data type of the value is a user-defined type.
 * @memberOf module:datastax/graph
 * @param {object} value The object representing the UDT.
 * @param {{name: string, keyspace: string, fields: Array}} udtInfo The UDT metadata as defined by the driver.
 */


function asUdt$1(value, udtInfo) {
  return new UdtGraphWrapper$3(value, udtInfo);
}

var wrappers = {
  asInt: asInt$1,
  asDouble: asDouble$1,
  asFloat: asFloat$1,
  asTimestamp: asTimestamp$1,
  asUdt: asUdt$1,
  UdtGraphWrapper: UdtGraphWrapper$3,
  GraphTypeWrapper: GraphTypeWrapper$3
};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var GraphTypeWrapper$2 = wrappers.GraphTypeWrapper,
    UdtGraphWrapper$2 = wrappers.UdtGraphWrapper;
var types$5 = types$u;
var Encoder = encoder;
var dataTypes$2 = types$5.dataTypes;

function getTypeDefinitionByValue$1(value) {
  if (value instanceof types$5.Tuple) {
    return {
      'cqlType': 'tuple',
      'definition': value.elements.map(getTypeDefinitionByValue$1)
    };
  }

  if (value instanceof Map) {
    // Try to guess the types of the key and value based on the first element
    var result = {
      'cqlType': 'map'
    };

    if (value.size > 0) {
      var first = value.entries().next().value;
      result['definition'] = first.map(getTypeDefinitionByValue$1);
    }

    return result;
  }

  if (value instanceof UdtGraphWrapper$2) {
    return getUdtTypeDefinitionByValue$1(value);
  }

  var type;

  if (value instanceof GraphTypeWrapper$2) {
    type = value.typeInfo;
  } else {
    type = Encoder.guessDataType(value);
  }

  if (!type) {
    return null;
  }

  return getDefinitionByType(type);
}

function getDefinitionByType(type) {
  if (type.code === dataTypes$2.udt) {
    return getUdtTypeDefinition(type.info);
  }

  if (type.code === dataTypes$2.tuple || type.code === dataTypes$2.map) {
    return {
      'cqlType': types$5.getDataTypeNameByCode(type),
      'definition': type.info.map(getDefinitionByType)
    };
  }

  if (type.code === dataTypes$2.list || type.code === dataTypes$2.set) {
    return {
      'cqlType': type.code === dataTypes$2.list ? 'list' : 'set',
      'definition': [getDefinitionByType(type.info)]
    };
  }

  return {
    'cqlType': types$5.getDataTypeNameByCode(type)
  };
}

function getUdtTypeDefinition(udtInfo) {
  return {
    'cqlType': 'udt',
    'keyspace': udtInfo.keyspace,
    'name': udtInfo.name,
    'definition': udtInfo.fields.map(function (field) {
      return (// fieldName should be the first property serialized
        Object.assign({
          'fieldName': field.name
        }, getDefinitionByType(field.type))
      );
    })
  };
}

function getUdtTypeDefinitionByValue$1(wrappedValue) {
  return getUdtTypeDefinition(wrappedValue.udtInfo);
}

var complexTypeHelper = {
  getTypeDefinitionByValue: getTypeDefinitionByValue$1,
  getUdtTypeDefinitionByValue: getUdtTypeDefinitionByValue$1
};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util$3 = require$$0__default$1["default"];
/**
 * @classdesc
 * Represents a graph Element.
 * @param id
 * @param label
 * @abstract
 * @memberOf module:datastax/graph
 * @constructor
 */

function Element$1(id, label) {
  /**
   * Gets the element id.
   */
  this.id = id;
  /**
   * Gets the element label.
   * @type {String}
   */

  this.label = label;
}
/**
 * @classdesc
 * Represents a graph Vertex.
 * @param id
 * @param {String} label
 * @param {Object<string, Array>} properties
 * @extends {Element}
 * @memberOf module:datastax/graph
 * @constructor
 */


function Vertex$1(id, label, properties) {
  Element$1.call(this, id, label);
  /**
   * Gets the vertex properties.
   * @type {Object<string, Array>}
   */

  this.properties = properties;
}

util$3.inherits(Vertex$1, Element$1);
/**
 * @classdesc
 * Represents a graph Edge.
 * @param id
 * @param outV
 * @param {outVLabel} outVLabel
 * @param {String} label
 * @param inV
 * @param {String} inVLabel
 * @param {Object<string, Property>} properties
 * @extends {Element}
 * @memberOf module:datastax/graph
 * @constructor
 */

function Edge$2(id, outV, outVLabel, label, inV, inVLabel, properties) {
  Element$1.call(this, id, label);
  /**
   * Gets the id of outgoing vertex of the edge.
   */

  this.outV = outV;
  /**
   * Gets the label of the outgoing vertex.
   */

  this.outVLabel = outVLabel;
  /**
   * Gets the id of the incoming vertex of the edge.
   */

  this.inV = inV;
  /**
   * Gets the label of the incoming vertex.
   */

  this.inVLabel = inVLabel;
  /**
   * Gets the properties of the edge as an associative array.
   * @type {Object}
   */

  this.properties = {};

  (function adaptProperties(self) {
    if (properties) {
      var keys = Object.keys(properties);

      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        self.properties[k] = properties[k].value;
      }
    }
  })(this);
}

util$3.inherits(Edge$2, Element$1);
/**
 * @classdesc
 * Represents a graph vertex property.
 * @param id
 * @param {String} label
 * @param value
 * @param {Object} properties
 * @extends {Element}
 * @memberOf module:datastax/graph
 * @constructor
 */

function VertexProperty$1(id, label, value, properties) {
  Element$1.call(this, id, label);
  this.value = value;
  this.key = this.label;
  this.properties = properties;
}

util$3.inherits(VertexProperty$1, Element$1);
/**
 * @classdesc
 * Represents a property.
 * @param key
 * @param value
 * @memberOf module:datastax/graph
 * @constructor
 */

function Property$1(key, value) {
  this.key = key;
  this.value = value;
}
/**
 * @classdesc
 * Represents a walk through a graph as defined by a traversal.
 * @param {Array} labels
 * @param {Array} objects
 * @memberOf module:datastax/graph
 * @constructor
 */


function Path$1(labels, objects) {
  this.labels = labels;
  this.objects = objects;
}

var structure = {
  Edge: Edge$2,
  Element: Element$1,
  Path: Path$1,
  Property: Property$1,
  Vertex: Vertex$1,
  VertexProperty: VertexProperty$1
};

var _graphSONSerializerBy;

var types$4 = types$u;
var utils$9 = utils$V;
var getTypeDefinitionByValue = complexTypeHelper.getTypeDefinitionByValue,
    getUdtTypeDefinitionByValue = complexTypeHelper.getUdtTypeDefinitionByValue;
var Point = geometry$1.Point,
    Polygon = geometry$1.Polygon,
    LineString = geometry$1.LineString;
var Edge$1 = structure.Edge;
var GraphTypeWrapper$1 = wrappers.GraphTypeWrapper,
    UdtGraphWrapper$1 = wrappers.UdtGraphWrapper;
var Tuple = types$4.Tuple,
    dataTypes$1 = types$4.dataTypes;
var typeKey$1 = '@type';
var valueKey$1 = '@value';

var EdgeDeserializer = /*#__PURE__*/function () {
  function EdgeDeserializer() {
    _classCallCheck(this, EdgeDeserializer);

    this.key = 'g:Edge';
  }

  _createClass(EdgeDeserializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      var value = obj[valueKey$1];
      return new Edge$1(this.reader.read(value['id']), this.reader.read(value['outV']), value['outVLabel'], value['label'], this.reader.read(value['inV']), value['inVLabel'], this.reader.read(value['properties']));
    }
  }]);

  return EdgeDeserializer;
}();
/**
 * Uses toString() instance method and fromString() static method to serialize and deserialize the value.
 * @abstract
 * @private
 */


var StringBasedTypeSerializer = /*#__PURE__*/function () {
  /**
   * Creates a new instance of the deserializer.
   * @param {String} key
   * @param {Function} targetType
   */
  function StringBasedTypeSerializer(key, targetType) {
    _classCallCheck(this, StringBasedTypeSerializer);

    if (!key) {
      throw new Error('Deserializer must provide a type key');
    }

    if (!targetType) {
      throw new Error('Deserializer must provide a target type');
    }

    this.key = key;
    this.targetType = targetType;
  }

  _createClass(StringBasedTypeSerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      var value = obj[valueKey$1];

      if (typeof value !== 'string') {
        value = value.toString();
      }

      return this.targetType.fromString(value);
    }
  }, {
    key: "serialize",
    value: function serialize(value) {
      var _ref;

      return _ref = {}, _defineProperty(_ref, typeKey$1, this.key), _defineProperty(_ref, valueKey$1, value.toString()), _ref;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof this.targetType;
    }
  }]);

  return StringBasedTypeSerializer;
}();

var UuidSerializer = /*#__PURE__*/function (_StringBasedTypeSeria) {
  _inherits(UuidSerializer, _StringBasedTypeSeria);

  var _super = _createSuper(UuidSerializer);

  function UuidSerializer() {
    _classCallCheck(this, UuidSerializer);

    return _super.call(this, 'g:UUID', types$4.Uuid);
  }

  return _createClass(UuidSerializer);
}(StringBasedTypeSerializer);

var LongSerializer$1 = /*#__PURE__*/function (_StringBasedTypeSeria2) {
  _inherits(LongSerializer, _StringBasedTypeSeria2);

  var _super2 = _createSuper(LongSerializer);

  function LongSerializer() {
    _classCallCheck(this, LongSerializer);

    return _super2.call(this, 'g:Int64', types$4.Long);
  }

  return _createClass(LongSerializer);
}(StringBasedTypeSerializer);

var BigDecimalSerializer = /*#__PURE__*/function (_StringBasedTypeSeria3) {
  _inherits(BigDecimalSerializer, _StringBasedTypeSeria3);

  var _super3 = _createSuper(BigDecimalSerializer);

  function BigDecimalSerializer() {
    _classCallCheck(this, BigDecimalSerializer);

    return _super3.call(this, 'gx:BigDecimal', types$4.BigDecimal);
  }

  return _createClass(BigDecimalSerializer);
}(StringBasedTypeSerializer);

var BigIntegerSerializer = /*#__PURE__*/function (_StringBasedTypeSeria4) {
  _inherits(BigIntegerSerializer, _StringBasedTypeSeria4);

  var _super4 = _createSuper(BigIntegerSerializer);

  function BigIntegerSerializer() {
    _classCallCheck(this, BigIntegerSerializer);

    return _super4.call(this, 'gx:BigInteger', types$4.Integer);
  }

  return _createClass(BigIntegerSerializer);
}(StringBasedTypeSerializer);

var InetAddressSerializer = /*#__PURE__*/function (_StringBasedTypeSeria5) {
  _inherits(InetAddressSerializer, _StringBasedTypeSeria5);

  var _super5 = _createSuper(InetAddressSerializer);

  function InetAddressSerializer() {
    _classCallCheck(this, InetAddressSerializer);

    return _super5.call(this, 'gx:InetAddress', types$4.InetAddress);
  }

  return _createClass(InetAddressSerializer);
}(StringBasedTypeSerializer);

var LocalDateSerializer = /*#__PURE__*/function (_StringBasedTypeSeria6) {
  _inherits(LocalDateSerializer, _StringBasedTypeSeria6);

  var _super6 = _createSuper(LocalDateSerializer);

  function LocalDateSerializer() {
    _classCallCheck(this, LocalDateSerializer);

    return _super6.call(this, 'gx:LocalDate', types$4.LocalDate);
  }

  return _createClass(LocalDateSerializer);
}(StringBasedTypeSerializer);

var LocalTimeSerializer = /*#__PURE__*/function (_StringBasedTypeSeria7) {
  _inherits(LocalTimeSerializer, _StringBasedTypeSeria7);

  var _super7 = _createSuper(LocalTimeSerializer);

  function LocalTimeSerializer() {
    _classCallCheck(this, LocalTimeSerializer);

    return _super7.call(this, 'gx:LocalTime', types$4.LocalTime);
  }

  return _createClass(LocalTimeSerializer);
}(StringBasedTypeSerializer);

var InstantSerializer = /*#__PURE__*/function (_StringBasedTypeSeria8) {
  _inherits(InstantSerializer, _StringBasedTypeSeria8);

  var _super8 = _createSuper(InstantSerializer);

  function InstantSerializer() {
    _classCallCheck(this, InstantSerializer);

    return _super8.call(this, 'gx:Instant', Date);
  }

  _createClass(InstantSerializer, [{
    key: "serialize",
    value: function serialize(item) {
      var _ref2;

      return _ref2 = {}, _defineProperty(_ref2, typeKey$1, this.key), _defineProperty(_ref2, valueKey$1, item.toISOString()), _ref2;
    }
  }, {
    key: "deserialize",
    value: function deserialize(obj) {
      return new Date(obj[valueKey$1]);
    }
  }]);

  return InstantSerializer;
}(StringBasedTypeSerializer);

var BlobSerializer = /*#__PURE__*/function (_StringBasedTypeSeria9) {
  _inherits(BlobSerializer, _StringBasedTypeSeria9);

  var _super9 = _createSuper(BlobSerializer);

  function BlobSerializer() {
    _classCallCheck(this, BlobSerializer);

    return _super9.call(this, 'dse:Blob', Buffer);
  }

  _createClass(BlobSerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      return utils$9.allocBufferFromString(obj[valueKey$1], 'base64');
    }
  }, {
    key: "serialize",
    value: function serialize(item) {
      var _ref3;

      return _ref3 = {}, _defineProperty(_ref3, typeKey$1, this.key), _defineProperty(_ref3, valueKey$1, item.toString('base64')), _ref3;
    }
  }]);

  return BlobSerializer;
}(StringBasedTypeSerializer);

var PointSerializer = /*#__PURE__*/function (_StringBasedTypeSeria10) {
  _inherits(PointSerializer, _StringBasedTypeSeria10);

  var _super10 = _createSuper(PointSerializer);

  function PointSerializer() {
    _classCallCheck(this, PointSerializer);

    return _super10.call(this, 'dse:Point', Point);
  }

  return _createClass(PointSerializer);
}(StringBasedTypeSerializer);

var LineStringSerializer = /*#__PURE__*/function (_StringBasedTypeSeria11) {
  _inherits(LineStringSerializer, _StringBasedTypeSeria11);

  var _super11 = _createSuper(LineStringSerializer);

  function LineStringSerializer() {
    _classCallCheck(this, LineStringSerializer);

    return _super11.call(this, 'dse:LineString', LineString);
  }

  return _createClass(LineStringSerializer);
}(StringBasedTypeSerializer);

var PolygonSerializer = /*#__PURE__*/function (_StringBasedTypeSeria12) {
  _inherits(PolygonSerializer, _StringBasedTypeSeria12);

  var _super12 = _createSuper(PolygonSerializer);

  function PolygonSerializer() {
    _classCallCheck(this, PolygonSerializer);

    return _super12.call(this, 'dse:Polygon', Polygon);
  }

  return _createClass(PolygonSerializer);
}(StringBasedTypeSerializer);

var TupleSerializer = /*#__PURE__*/function () {
  function TupleSerializer() {
    _classCallCheck(this, TupleSerializer);

    this.key = 'dse:Tuple';
  }

  _createClass(TupleSerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      // Skip definitions and go to the value
      var value = obj[valueKey$1]['value'];

      if (!Array.isArray(value)) {
        throw new Error('Expected Array, obtained: ' + value);
      }

      var result = [];

      var _iterator = _createForOfIteratorHelper(value),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var element = _step.value;
          result.push(this.reader.read(element));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return Tuple.fromArray(result);
    }
    /** @param {Tuple} tuple */

  }, {
    key: "serialize",
    value: function serialize(tuple) {
      var _this = this,
          _ref4;

      var result = {
        'cqlType': 'tuple',
        'definition': tuple.elements.map(getTypeDefinitionByValue),
        'value': tuple.elements.map(function (e) {
          return _this.writer.adaptObject(e);
        })
      };
      return _ref4 = {}, _defineProperty(_ref4, typeKey$1, this.key), _defineProperty(_ref4, valueKey$1, result), _ref4;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof Tuple;
    }
  }]);

  return TupleSerializer;
}();

var DurationSerializer = /*#__PURE__*/function () {
  function DurationSerializer() {
    _classCallCheck(this, DurationSerializer);

    this.key = 'dse:Duration';
  }

  _createClass(DurationSerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      // Skip definitions and go to the value
      var value = obj[valueKey$1];
      return new types$4.Duration(this.reader.read(value['months']), this.reader.read(value['days']), this.reader.read(value['nanos']));
    }
    /** @param {Duration} value */

  }, {
    key: "serialize",
    value: function serialize(value) {
      var _ref5;

      return _ref5 = {}, _defineProperty(_ref5, typeKey$1, this.key), _defineProperty(_ref5, valueKey$1, {
        'months': value['months'],
        'days': value['days'],
        'nanos': value['nanoseconds']
      }), _ref5;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof types$4.Duration;
    }
  }]);

  return DurationSerializer;
}();

var UdtSerializer = /*#__PURE__*/function () {
  function UdtSerializer() {
    _classCallCheck(this, UdtSerializer);

    this.key = 'dse:UDT';
  }

  _createClass(UdtSerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      var _this2 = this;

      // Skip definitions and go to the value
      var valueRoot = obj[valueKey$1];
      var result = {};
      var value = valueRoot['value'];
      valueRoot['definition'].forEach(function (definition, index) {
        result[definition.fieldName] = _this2.reader.read(value[index]);
      });
      return result;
    }
  }, {
    key: "serialize",
    value: function serialize(udtWrapper) {
      var _this3 = this,
          _ref8;

      var serializedValue = getUdtTypeDefinitionByValue(udtWrapper); // New properties can be added to the existing object without need to clone
      // as getTypeDefinition() returns a new object each time

      serializedValue['value'] = Object.entries(udtWrapper.value).map(function (_ref6) {
        var _ref7 = _slicedToArray(_ref6, 2);
            _ref7[0];
            var v = _ref7[1];

        return _this3.writer.adaptObject(v);
      });
      return _ref8 = {}, _defineProperty(_ref8, typeKey$1, this.key), _defineProperty(_ref8, valueKey$1, serializedValue), _ref8;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof UdtGraphWrapper$1;
    }
  }]);

  return UdtSerializer;
}();

var InternalSerializer = /*#__PURE__*/function () {
  function InternalSerializer(name, transformFn) {
    _classCallCheck(this, InternalSerializer);

    this._name = name;

    this._transformFn = transformFn || function (x) {
      return x;
    };
  }

  _createClass(InternalSerializer, [{
    key: "serialize",
    value: function serialize(item) {
      var _ref9;

      return _ref9 = {}, _defineProperty(_ref9, typeKey$1, this._name), _defineProperty(_ref9, valueKey$1, this._transformFn(item)), _ref9;
    }
  }]);

  return InternalSerializer;
}(); // Associative array of graph type name by CQL type code, used by the type wrapper


var graphSONSerializerByCqlType = (_graphSONSerializerBy = {}, _defineProperty(_graphSONSerializerBy, dataTypes$1["int"], new InternalSerializer('g:Int32')), _defineProperty(_graphSONSerializerBy, dataTypes$1.bigint, new InternalSerializer('g:Int64')), _defineProperty(_graphSONSerializerBy, dataTypes$1["double"], new InternalSerializer('g:Double')), _defineProperty(_graphSONSerializerBy, dataTypes$1["float"], new InternalSerializer('g:Float')), _defineProperty(_graphSONSerializerBy, dataTypes$1.timestamp, new InternalSerializer('g:Timestamp', function (x) {
  return x.getTime();
})), _graphSONSerializerBy);

var GraphTypeWrapperSerializer = /*#__PURE__*/function () {
  function GraphTypeWrapperSerializer() {
    _classCallCheck(this, GraphTypeWrapperSerializer);

    // Use a fixed name that doesn't conflict with TinkerPop and DS Graph
    this.key = 'client:wrapper';
  }

  _createClass(GraphTypeWrapperSerializer, [{
    key: "serialize",
    value: function serialize(wrappedValue) {
      var s = graphSONSerializerByCqlType[wrappedValue.typeInfo.code];

      if (!s) {
        throw new Error("No serializer found for wrapped value ".concat(wrappedValue));
      }

      return s.serialize(wrappedValue.value);
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof GraphTypeWrapper$1;
    }
  }]);

  return GraphTypeWrapperSerializer;
}();

var serializersArray = [EdgeDeserializer, UuidSerializer, LongSerializer$1, BigDecimalSerializer, BigIntegerSerializer, InetAddressSerializer, LocalDateSerializer, LocalTimeSerializer, InstantSerializer, BlobSerializer, PointSerializer, LineStringSerializer, PolygonSerializer, TupleSerializer, UdtSerializer, GraphTypeWrapperSerializer, DurationSerializer];

function getCustomSerializers() {
  var customSerializers = {};
  serializersArray.forEach(function (sConstructor) {
    var instance = new sConstructor();

    if (!instance.key) {
      throw new TypeError("Key for ".concat(sConstructor, " instance not set"));
    }

    customSerializers[instance.key] = instance;
  });
  return customSerializers;
}

var customTypeSerializers = getCustomSerializers;

/**
 * Graph module.
 * @module datastax/graph
 */


var GraphResultSet$1 = resultSet;
var getCustomTypeSerializers$1 = customTypeSerializers;
var asInt = wrappers.asInt,
    asDouble = wrappers.asDouble,
    asFloat = wrappers.asFloat,
    asTimestamp = wrappers.asTimestamp,
    asUdt = wrappers.asUdt,
    UdtGraphWrapper = wrappers.UdtGraphWrapper,
    GraphTypeWrapper = wrappers.GraphTypeWrapper;
var Edge = structure.Edge,
    Element = structure.Element,
    Path = structure.Path,
    Property = structure.Property,
    Vertex = structure.Vertex,
    VertexProperty = structure.VertexProperty;

var EnumValue = /*#__PURE__*/function () {
  function EnumValue(typeName, elementName) {
    _classCallCheck(this, EnumValue);

    this.typeName = typeName;
    this.elementName = elementName;
  }

  _createClass(EnumValue, [{
    key: "toString",
    value: function toString() {
      return this.elementName;
    }
  }]);

  return EnumValue;
}();
/**
 * Represents a collection of tokens for more concise Traversal definitions.
 */


var t$1 = {
  id: new EnumValue('T', 'id'),
  key: new EnumValue('T', 'key'),
  label: new EnumValue('T', 'label'),
  value: new EnumValue('T', 'value')
};
/**
 * Represents the edge direction.
 */

var direction = {
  'both': new EnumValue('Direction', 'BOTH'),
  'in': new EnumValue('Direction', 'IN'),
  'out': new EnumValue('Direction', 'OUT')
}; // `in` is a reserved keyword depending on the context
// TinkerPop JavaScript GLV only exposes `in` but it can lead to issues for TypeScript users and others.
// Expose an extra property to represent `Direction.IN`.

direction.in_ = direction["in"];
var graph = {
  Edge: Edge,
  Element: Element,
  Path: Path,
  Property: Property,
  Vertex: Vertex,
  VertexProperty: VertexProperty,
  asInt: asInt,
  asDouble: asDouble,
  asFloat: asFloat,
  asTimestamp: asTimestamp,
  asUdt: asUdt,
  direction: direction,
  getCustomTypeSerializers: getCustomTypeSerializers$1,
  GraphResultSet: GraphResultSet$1,
  GraphTypeWrapper: GraphTypeWrapper,
  t: t$1,
  UdtGraphWrapper: UdtGraphWrapper
};

var t = {
  P: UnsupportedType,
  TextP: UnsupportedType,
  Traversal: UnsupportedType,
  Traverser: UnsupportedType,
  EnumValue: UnsupportedType
};
var ts = {
  TraversalStrategy: UnsupportedType
};
var Bytecode = UnsupportedType;
var g = graph;
var utils$8 = {
  Long: UnsupportedType
};
t.t = g.t;
t.direction = g.direction;

function UnsupportedType() {}

var valueKey = '@value';
var typeKey = '@type';
/**
 * @abstract
 */

var TypeSerializer = /*#__PURE__*/function () {
  function TypeSerializer() {
    _classCallCheck(this, TypeSerializer);
  }

  _createClass(TypeSerializer, [{
    key: "serialize",
    value: function serialize() {
      throw new Error('serialize() method not implemented for ' + this.constructor.name);
    }
  }, {
    key: "deserialize",
    value: function deserialize() {
      throw new Error('deserialize() method not implemented for ' + this.constructor.name);
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor() {
      throw new Error('canBeUsedFor() method not implemented for ' + this.constructor.name);
    }
  }]);

  return TypeSerializer;
}();

var NumberSerializer = /*#__PURE__*/function (_TypeSerializer) {
  _inherits(NumberSerializer, _TypeSerializer);

  var _super = _createSuper(NumberSerializer);

  function NumberSerializer() {
    _classCallCheck(this, NumberSerializer);

    return _super.apply(this, arguments);
  }

  _createClass(NumberSerializer, [{
    key: "serialize",
    value: function serialize(item) {
      if (isNaN(item)) {
        var _ref;

        return _ref = {}, _defineProperty(_ref, typeKey, 'g:Double'), _defineProperty(_ref, valueKey, 'NaN'), _ref;
      } else if (item === Number.POSITIVE_INFINITY) {
        var _ref2;

        return _ref2 = {}, _defineProperty(_ref2, typeKey, 'g:Double'), _defineProperty(_ref2, valueKey, 'Infinity'), _ref2;
      } else if (item === Number.NEGATIVE_INFINITY) {
        var _ref3;

        return _ref3 = {}, _defineProperty(_ref3, typeKey, 'g:Double'), _defineProperty(_ref3, valueKey, '-Infinity'), _ref3;
      } else {
        return item;
      }
    }
  }, {
    key: "deserialize",
    value: function deserialize(obj) {
      var val = obj[valueKey];

      if (val === 'NaN') {
        return NaN;
      } else if (val === 'Infinity') {
        return Number.POSITIVE_INFINITY;
      } else if (val === '-Infinity') {
        return Number.NEGATIVE_INFINITY;
      } else {
        return parseFloat(val);
      }
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return typeof value === 'number';
    }
  }]);

  return NumberSerializer;
}(TypeSerializer);

var DateSerializer = /*#__PURE__*/function (_TypeSerializer2) {
  _inherits(DateSerializer, _TypeSerializer2);

  var _super2 = _createSuper(DateSerializer);

  function DateSerializer() {
    _classCallCheck(this, DateSerializer);

    return _super2.apply(this, arguments);
  }

  _createClass(DateSerializer, [{
    key: "serialize",
    value: function serialize(item) {
      var _ref4;

      return _ref4 = {}, _defineProperty(_ref4, typeKey, 'g:Date'), _defineProperty(_ref4, valueKey, item.getTime()), _ref4;
    }
  }, {
    key: "deserialize",
    value: function deserialize(obj) {
      return new Date(obj[valueKey]);
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof Date;
    }
  }]);

  return DateSerializer;
}(TypeSerializer);

var LongSerializer = /*#__PURE__*/function (_TypeSerializer3) {
  _inherits(LongSerializer, _TypeSerializer3);

  var _super3 = _createSuper(LongSerializer);

  function LongSerializer() {
    _classCallCheck(this, LongSerializer);

    return _super3.apply(this, arguments);
  }

  _createClass(LongSerializer, [{
    key: "serialize",
    value: function serialize(item) {
      var _ref5;

      return _ref5 = {}, _defineProperty(_ref5, typeKey, 'g:Int64'), _defineProperty(_ref5, valueKey, item.value), _ref5;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof utils$8.Long;
    }
  }]);

  return LongSerializer;
}(TypeSerializer);

var BytecodeSerializer = /*#__PURE__*/function (_TypeSerializer4) {
  _inherits(BytecodeSerializer, _TypeSerializer4);

  var _super4 = _createSuper(BytecodeSerializer);

  function BytecodeSerializer() {
    _classCallCheck(this, BytecodeSerializer);

    return _super4.apply(this, arguments);
  }

  _createClass(BytecodeSerializer, [{
    key: "serialize",
    value: function serialize(item) {
      var bytecode = item;

      if (item instanceof t.Traversal) {
        bytecode = item.getBytecode();
      }

      var result = {};
      result[typeKey] = 'g:Bytecode';
      var resultValue = result[valueKey] = {};

      var sources = this._serializeInstructions(bytecode.sourceInstructions);

      if (sources) {
        resultValue['source'] = sources;
      }

      var steps = this._serializeInstructions(bytecode.stepInstructions);

      if (steps) {
        resultValue['step'] = steps;
      }

      return result;
    }
  }, {
    key: "_serializeInstructions",
    value: function _serializeInstructions(instructions) {
      var _this = this;

      if (instructions.length === 0) {
        return null;
      }

      var result = new Array(instructions.length);
      result[0] = instructions[0];

      for (var i = 0; i < instructions.length; i++) {
        result[i] = instructions[i].map(function (item) {
          return _this.writer.adaptObject(item);
        });
      }

      return result;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof Bytecode || value instanceof t.Traversal;
    }
  }]);

  return BytecodeSerializer;
}(TypeSerializer);

var PSerializer = /*#__PURE__*/function (_TypeSerializer5) {
  _inherits(PSerializer, _TypeSerializer5);

  var _super5 = _createSuper(PSerializer);

  function PSerializer() {
    _classCallCheck(this, PSerializer);

    return _super5.apply(this, arguments);
  }

  _createClass(PSerializer, [{
    key: "serialize",
    value:
    /** @param {P} item */
    function serialize(item) {
      var result = {};
      result[typeKey] = 'g:P';
      var resultValue = result[valueKey] = {
        'predicate': item.operator
      };

      if (item.other === undefined || item.other === null) {
        resultValue['value'] = this.writer.adaptObject(item.value);
      } else {
        resultValue['value'] = [this.writer.adaptObject(item.value), this.writer.adaptObject(item.other)];
      }

      return result;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof t.P;
    }
  }]);

  return PSerializer;
}(TypeSerializer);

var TextPSerializer = /*#__PURE__*/function (_TypeSerializer6) {
  _inherits(TextPSerializer, _TypeSerializer6);

  var _super6 = _createSuper(TextPSerializer);

  function TextPSerializer() {
    _classCallCheck(this, TextPSerializer);

    return _super6.apply(this, arguments);
  }

  _createClass(TextPSerializer, [{
    key: "serialize",
    value:
    /** @param {TextP} item */
    function serialize(item) {
      var result = {};
      result[typeKey] = 'g:TextP';
      var resultValue = result[valueKey] = {
        'predicate': item.operator
      };

      if (item.other === undefined || item.other === null) {
        resultValue['value'] = this.writer.adaptObject(item.value);
      } else {
        resultValue['value'] = [this.writer.adaptObject(item.value), this.writer.adaptObject(item.other)];
      }

      return result;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof t.TextP;
    }
  }]);

  return TextPSerializer;
}(TypeSerializer);

var LambdaSerializer = /*#__PURE__*/function (_TypeSerializer7) {
  _inherits(LambdaSerializer, _TypeSerializer7);

  var _super7 = _createSuper(LambdaSerializer);

  function LambdaSerializer() {
    _classCallCheck(this, LambdaSerializer);

    return _super7.apply(this, arguments);
  }

  _createClass(LambdaSerializer, [{
    key: "serialize",
    value:
    /** @param {Function} item */
    function serialize(item) {
      var _ref6;

      return _ref6 = {}, _defineProperty(_ref6, typeKey, 'g:Lambda'), _defineProperty(_ref6, valueKey, {
        'arguments': item.length,
        'language': 'gremlin-javascript',
        'script': item.toString()
      }), _ref6;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return typeof value === 'function';
    }
  }]);

  return LambdaSerializer;
}(TypeSerializer);

var EnumSerializer = /*#__PURE__*/function (_TypeSerializer8) {
  _inherits(EnumSerializer, _TypeSerializer8);

  var _super8 = _createSuper(EnumSerializer);

  function EnumSerializer() {
    _classCallCheck(this, EnumSerializer);

    return _super8.apply(this, arguments);
  }

  _createClass(EnumSerializer, [{
    key: "serialize",
    value:
    /** @param {EnumValue} item */
    function serialize(item) {
      var _ref7;

      return _ref7 = {}, _defineProperty(_ref7, typeKey, 'g:' + item.typeName), _defineProperty(_ref7, valueKey, item.elementName), _ref7;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value && value.typeName && value instanceof t.EnumValue;
    }
  }]);

  return EnumSerializer;
}(TypeSerializer);

var TraverserSerializer = /*#__PURE__*/function (_TypeSerializer9) {
  _inherits(TraverserSerializer, _TypeSerializer9);

  var _super9 = _createSuper(TraverserSerializer);

  function TraverserSerializer() {
    _classCallCheck(this, TraverserSerializer);

    return _super9.apply(this, arguments);
  }

  _createClass(TraverserSerializer, [{
    key: "serialize",
    value:
    /** @param {Traverser} item */
    function serialize(item) {
      var _ref8;

      return _ref8 = {}, _defineProperty(_ref8, typeKey, 'g:Traverser'), _defineProperty(_ref8, valueKey, {
        'value': this.writer.adaptObject(item.object),
        'bulk': this.writer.adaptObject(item.bulk)
      }), _ref8;
    }
  }, {
    key: "deserialize",
    value: function deserialize(obj) {
      var value = obj[valueKey];
      return new t.Traverser(this.reader.read(value['value']), this.reader.read(value['bulk']));
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof t.Traverser;
    }
  }]);

  return TraverserSerializer;
}(TypeSerializer);

var TraversalStrategySerializer = /*#__PURE__*/function (_TypeSerializer10) {
  _inherits(TraversalStrategySerializer, _TypeSerializer10);

  var _super10 = _createSuper(TraversalStrategySerializer);

  function TraversalStrategySerializer() {
    _classCallCheck(this, TraversalStrategySerializer);

    return _super10.apply(this, arguments);
  }

  _createClass(TraversalStrategySerializer, [{
    key: "serialize",
    value:
    /** @param {TraversalStrategy} item */
    function serialize(item) {
      var _ref9;

      return _ref9 = {}, _defineProperty(_ref9, typeKey, 'g:' + item.constructor.name), _defineProperty(_ref9, valueKey, item.configuration), _ref9;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof ts.TraversalStrategy;
    }
  }]);

  return TraversalStrategySerializer;
}(TypeSerializer);

var VertexSerializer = /*#__PURE__*/function (_TypeSerializer11) {
  _inherits(VertexSerializer, _TypeSerializer11);

  var _super11 = _createSuper(VertexSerializer);

  function VertexSerializer() {
    _classCallCheck(this, VertexSerializer);

    return _super11.apply(this, arguments);
  }

  _createClass(VertexSerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      var value = obj[valueKey];
      return new g.Vertex(this.reader.read(value['id']), value['label'], this.reader.read(value['properties']));
    }
    /** @param {Vertex} item */

  }, {
    key: "serialize",
    value: function serialize(item) {
      var _ref10;

      return _ref10 = {}, _defineProperty(_ref10, typeKey, 'g:Vertex'), _defineProperty(_ref10, valueKey, {
        'id': this.writer.adaptObject(item.id),
        'label': item.label
      }), _ref10;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof g.Vertex;
    }
  }]);

  return VertexSerializer;
}(TypeSerializer);

var VertexPropertySerializer = /*#__PURE__*/function (_TypeSerializer12) {
  _inherits(VertexPropertySerializer, _TypeSerializer12);

  var _super12 = _createSuper(VertexPropertySerializer);

  function VertexPropertySerializer() {
    _classCallCheck(this, VertexPropertySerializer);

    return _super12.apply(this, arguments);
  }

  _createClass(VertexPropertySerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      var value = obj[valueKey];
      return new g.VertexProperty(this.reader.read(value['id']), value['label'], this.reader.read(value['value']), this.reader.read(value['properties']));
    }
  }]);

  return VertexPropertySerializer;
}(TypeSerializer);

var PropertySerializer = /*#__PURE__*/function (_TypeSerializer13) {
  _inherits(PropertySerializer, _TypeSerializer13);

  var _super13 = _createSuper(PropertySerializer);

  function PropertySerializer() {
    _classCallCheck(this, PropertySerializer);

    return _super13.apply(this, arguments);
  }

  _createClass(PropertySerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      var value = obj[valueKey];
      return new g.Property(value['key'], this.reader.read(value['value']));
    }
  }]);

  return PropertySerializer;
}(TypeSerializer);

var EdgeSerializer = /*#__PURE__*/function (_TypeSerializer14) {
  _inherits(EdgeSerializer, _TypeSerializer14);

  var _super14 = _createSuper(EdgeSerializer);

  function EdgeSerializer() {
    _classCallCheck(this, EdgeSerializer);

    return _super14.apply(this, arguments);
  }

  _createClass(EdgeSerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      var value = obj[valueKey];
      return new g.Edge(this.reader.read(value['id']), new g.Vertex(this.reader.read(value['outV']), this.reader.read(value['outVLabel'])), value['label'], new g.Vertex(this.reader.read(value['inV']), this.reader.read(value['inVLabel'])), this.reader.read(value['properties']));
    }
    /** @param {Edge} item */

  }, {
    key: "serialize",
    value: function serialize(item) {
      var _ref11;

      return _ref11 = {}, _defineProperty(_ref11, typeKey, 'g:Edge'), _defineProperty(_ref11, valueKey, {
        'id': this.writer.adaptObject(item.id),
        'label': item.label,
        'outV': this.writer.adaptObject(item.outV.id),
        'outVLabel': item.outV.label,
        'inV': this.writer.adaptObject(item.inV.id),
        'inVLabel': item.inV.label
      }), _ref11;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof g.Edge;
    }
  }]);

  return EdgeSerializer;
}(TypeSerializer);

var PathSerializer = /*#__PURE__*/function (_TypeSerializer15) {
  _inherits(PathSerializer, _TypeSerializer15);

  var _super15 = _createSuper(PathSerializer);

  function PathSerializer() {
    _classCallCheck(this, PathSerializer);

    return _super15.apply(this, arguments);
  }

  _createClass(PathSerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      var _this2 = this;

      var value = obj[valueKey];
      var objects = value['objects'].map(function (o) {
        return _this2.reader.read(o);
      });
      return new g.Path(this.reader.read(value['labels']), objects);
    }
  }]);

  return PathSerializer;
}(TypeSerializer);

var Path3Serializer = /*#__PURE__*/function (_TypeSerializer16) {
  _inherits(Path3Serializer, _TypeSerializer16);

  var _super16 = _createSuper(Path3Serializer);

  function Path3Serializer() {
    _classCallCheck(this, Path3Serializer);

    return _super16.apply(this, arguments);
  }

  _createClass(Path3Serializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      var value = obj[valueKey];
      return new g.Path(this.reader.read(value['labels']), this.reader.read(value['objects']));
    }
  }]);

  return Path3Serializer;
}(TypeSerializer);

var TSerializer = /*#__PURE__*/function (_TypeSerializer17) {
  _inherits(TSerializer, _TypeSerializer17);

  var _super17 = _createSuper(TSerializer);

  function TSerializer() {
    _classCallCheck(this, TSerializer);

    return _super17.apply(this, arguments);
  }

  _createClass(TSerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      return t.t[obj[valueKey]];
    }
  }]);

  return TSerializer;
}(TypeSerializer);

var DirectionSerializer = /*#__PURE__*/function (_TypeSerializer18) {
  _inherits(DirectionSerializer, _TypeSerializer18);

  var _super18 = _createSuper(DirectionSerializer);

  function DirectionSerializer() {
    _classCallCheck(this, DirectionSerializer);

    return _super18.apply(this, arguments);
  }

  _createClass(DirectionSerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      return t.direction[obj[valueKey].toLowerCase()];
    }
  }]);

  return DirectionSerializer;
}(TypeSerializer);

var ArraySerializer = /*#__PURE__*/function (_TypeSerializer19) {
  _inherits(ArraySerializer, _TypeSerializer19);

  var _super19 = _createSuper(ArraySerializer);

  function ArraySerializer(typeKey) {
    var _this3;

    _classCallCheck(this, ArraySerializer);

    _this3 = _super19.call(this);
    _this3.typeKey = typeKey;
    return _this3;
  }

  _createClass(ArraySerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      var _this4 = this;

      var value = obj[valueKey];

      if (!Array.isArray(value)) {
        throw new Error('Expected Array, obtained: ' + value);
      }

      return value.map(function (x) {
        return _this4.reader.read(x);
      });
    }
    /** @param {Array} item */

  }, {
    key: "serialize",
    value: function serialize(item) {
      var _this5 = this,
          _ref12;

      return _ref12 = {}, _defineProperty(_ref12, typeKey, this.typeKey), _defineProperty(_ref12, valueKey, item.map(function (x) {
        return _this5.writer.adaptObject(x);
      })), _ref12;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return Array.isArray(value);
    }
  }]);

  return ArraySerializer;
}(TypeSerializer);

var BulkSetSerializer = /*#__PURE__*/function (_TypeSerializer20) {
  _inherits(BulkSetSerializer, _TypeSerializer20);

  var _super20 = _createSuper(BulkSetSerializer);

  function BulkSetSerializer() {
    _classCallCheck(this, BulkSetSerializer);

    return _super20.apply(this, arguments);
  }

  _createClass(BulkSetSerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      var value = obj[valueKey];

      if (!Array.isArray(value)) {
        throw new Error('Expected Array, obtained: ' + value);
      } // coerce the BulkSet to List. if the bulk exceeds the int space then we can't coerce to List anyway,
      // so this query will be trouble. we'd need a legit BulkSet implementation here in js. this current
      // implementation is here to replicate the previous functionality that existed on the server side in
      // previous versions.


      var result = [];

      for (var ix = 0, iy = value.length; ix < iy; ix += 2) {
        var pair = value.slice(ix, ix + 2);
        result = result.concat(Array(this.reader.read(pair[1])).fill(this.reader.read(pair[0])));
      }

      return result;
    }
  }]);

  return BulkSetSerializer;
}(TypeSerializer);

var MapSerializer = /*#__PURE__*/function (_TypeSerializer21) {
  _inherits(MapSerializer, _TypeSerializer21);

  var _super21 = _createSuper(MapSerializer);

  function MapSerializer() {
    _classCallCheck(this, MapSerializer);

    return _super21.apply(this, arguments);
  }

  _createClass(MapSerializer, [{
    key: "deserialize",
    value: function deserialize(obj) {
      var value = obj[valueKey];

      if (!Array.isArray(value)) {
        throw new Error('Expected Array, obtained: ' + value);
      }

      var result = new Map();

      for (var i = 0; i < value.length; i += 2) {
        result.set(this.reader.read(value[i]), this.reader.read(value[i + 1]));
      }

      return result;
    }
    /** @param {Map} map */

  }, {
    key: "serialize",
    value: function serialize(map) {
      var _this6 = this,
          _ref13;

      var arr = [];
      map.forEach(function (v, k) {
        arr.push(_this6.writer.adaptObject(k));
        arr.push(_this6.writer.adaptObject(v));
      });
      return _ref13 = {}, _defineProperty(_ref13, typeKey, 'g:Map'), _defineProperty(_ref13, valueKey, arr), _ref13;
    }
  }, {
    key: "canBeUsedFor",
    value: function canBeUsedFor(value) {
      return value instanceof Map;
    }
  }]);

  return MapSerializer;
}(TypeSerializer);

var ListSerializer = /*#__PURE__*/function (_ArraySerializer) {
  _inherits(ListSerializer, _ArraySerializer);

  var _super22 = _createSuper(ListSerializer);

  function ListSerializer() {
    _classCallCheck(this, ListSerializer);

    return _super22.call(this, 'g:List');
  }

  return _createClass(ListSerializer);
}(ArraySerializer);

var SetSerializer = /*#__PURE__*/function (_ArraySerializer2) {
  _inherits(SetSerializer, _ArraySerializer2);

  var _super23 = _createSuper(SetSerializer);

  function SetSerializer() {
    _classCallCheck(this, SetSerializer);

    return _super23.call(this, 'g:Set');
  }

  return _createClass(SetSerializer);
}(ArraySerializer);

var typeSerializers$1 = {
  BulkSetSerializer: BulkSetSerializer,
  BytecodeSerializer: BytecodeSerializer,
  DateSerializer: DateSerializer,
  DirectionSerializer: DirectionSerializer,
  EdgeSerializer: EdgeSerializer,
  EnumSerializer: EnumSerializer,
  LambdaSerializer: LambdaSerializer,
  ListSerializer: ListSerializer,
  LongSerializer: LongSerializer,
  MapSerializer: MapSerializer,
  NumberSerializer: NumberSerializer,
  Path3Serializer: Path3Serializer,
  PathSerializer: PathSerializer,
  PropertySerializer: PropertySerializer,
  PSerializer: PSerializer,
  TextPSerializer: TextPSerializer,
  SetSerializer: SetSerializer,
  TSerializer: TSerializer,
  TraverserSerializer: TraverserSerializer,
  TraversalStrategySerializer: TraversalStrategySerializer,
  typeKey: typeKey,
  valueKey: valueKey,
  VertexPropertySerializer: VertexPropertySerializer,
  VertexSerializer: VertexSerializer
};

var typeSerializers = typeSerializers$1;
/**
 * GraphSON2 writer.
 */

var GraphSON2Writer$1 = /*#__PURE__*/function () {
  /**
   * @param {Object} [options]
   * @param {Object} [options.serializers] An object used as an associative array with GraphSON 2 type name as keys and
   * serializer instances as values, ie: { 'g:Int64': longSerializer }.
   * @constructor
   */
  function GraphSON2Writer(options) {
    var _this = this;

    _classCallCheck(this, GraphSON2Writer);

    this._options = options || {}; // Create instance of the default serializers

    this._serializers = this.getDefaultSerializers().map(function (serializerConstructor) {
      var s = new serializerConstructor();
      s.writer = _this;
      return s;
    });
    var customSerializers = this._options.serializers || {};
    Object.keys(customSerializers).forEach(function (key) {
      var s = customSerializers[key];

      if (!s.serialize) {
        return;
      }

      s.writer = _this; // Insert custom serializers first

      _this._serializers.unshift(s);
    });
  }
  /**
   * Gets the default serializers to be used.
   * @returns {Array}
   */


  _createClass(GraphSON2Writer, [{
    key: "getDefaultSerializers",
    value: function getDefaultSerializers() {
      return graphSON2Serializers;
    }
  }, {
    key: "adaptObject",
    value: function adaptObject(value) {
      var _this2 = this;

      var s;

      for (var i = 0; i < this._serializers.length; i++) {
        var currentSerializer = this._serializers[i];

        if (currentSerializer.canBeUsedFor && currentSerializer.canBeUsedFor(value)) {
          s = currentSerializer;
          break;
        }
      }

      if (s) {
        return s.serialize(value);
      }

      if (Array.isArray(value)) {
        // We need to handle arrays when there is no serializer
        // for older versions of GraphSON
        return value.map(function (item) {
          return _this2.adaptObject(item);
        });
      } // Default (strings / objects / ...)


      return value;
    }
    /**
     * Returns the GraphSON representation of the provided object instance.
     * @param {Object} obj
     * @returns {String}
     */

  }, {
    key: "write",
    value: function write(obj) {
      return JSON.stringify(this.adaptObject(obj));
    }
  }]);

  return GraphSON2Writer;
}();
/**
 * GraphSON3 writer.
 */


var GraphSON3Writer$1 = /*#__PURE__*/function (_GraphSON2Writer) {
  _inherits(GraphSON3Writer, _GraphSON2Writer);

  var _super = _createSuper(GraphSON3Writer);

  function GraphSON3Writer() {
    _classCallCheck(this, GraphSON3Writer);

    return _super.apply(this, arguments);
  }

  _createClass(GraphSON3Writer, [{
    key: "getDefaultSerializers",
    value: function getDefaultSerializers() {
      return graphSON3Serializers;
    }
  }]);

  return GraphSON3Writer;
}(GraphSON2Writer$1);
/**
 * GraphSON2 reader.
 */


var GraphSON2Reader$1 = /*#__PURE__*/function () {
  /**
   * GraphSON Reader
   * @param {Object} [options]
   * @param {Object} [options.serializers] An object used as an associative array with GraphSON 2 type name as keys and
   * deserializer instances as values, ie: { 'g:Int64': longSerializer }.
   * @constructor
   */
  function GraphSON2Reader(options) {
    var _this3 = this;

    _classCallCheck(this, GraphSON2Reader);

    this._options = options || {};
    this._deserializers = {};
    var defaultDeserializers = this.getDefaultDeserializers();
    Object.keys(defaultDeserializers).forEach(function (typeName) {
      var serializerConstructor = defaultDeserializers[typeName];
      var s = new serializerConstructor();
      s.reader = _this3;
      _this3._deserializers[typeName] = s;
    });

    if (this._options.serializers) {
      var customSerializers = this._options.serializers || {};
      Object.keys(customSerializers).forEach(function (key) {
        var s = customSerializers[key];

        if (!s.deserialize) {
          return;
        }

        s.reader = _this3;
        _this3._deserializers[key] = s;
      });
    }
  }
  /**
   * Gets the default deserializers as an associative array.
   * @returns {Object}
   */


  _createClass(GraphSON2Reader, [{
    key: "getDefaultDeserializers",
    value: function getDefaultDeserializers() {
      return graphSON2Deserializers;
    }
  }, {
    key: "read",
    value: function read(obj) {
      var _this4 = this;

      if (obj === undefined) {
        return undefined;
      }

      if (obj === null) {
        return null;
      }

      if (Array.isArray(obj)) {
        return obj.map(function (item) {
          return _this4.read(item);
        });
      }

      var type = obj[typeSerializers.typeKey];

      if (type) {
        var d = this._deserializers[type];

        if (d) {
          // Use type serializer
          return d.deserialize(obj);
        }

        return obj[typeSerializers.valueKey];
      }

      if (obj && _typeof(obj) === 'object' && obj.constructor === Object) {
        return this._deserializeObject(obj);
      } // Default (for boolean, number and other scalars)


      return obj;
    }
  }, {
    key: "_deserializeObject",
    value: function _deserializeObject(obj) {
      var keys = Object.keys(obj);
      var result = {};

      for (var i = 0; i < keys.length; i++) {
        result[keys[i]] = this.read(obj[keys[i]]);
      }

      return result;
    }
  }]);

  return GraphSON2Reader;
}();
/**
 * GraphSON3 reader.
 */


var GraphSON3Reader$1 = /*#__PURE__*/function (_GraphSON2Reader) {
  _inherits(GraphSON3Reader, _GraphSON2Reader);

  var _super2 = _createSuper(GraphSON3Reader);

  function GraphSON3Reader() {
    _classCallCheck(this, GraphSON3Reader);

    return _super2.apply(this, arguments);
  }

  _createClass(GraphSON3Reader, [{
    key: "getDefaultDeserializers",
    value: function getDefaultDeserializers() {
      return graphSON3Deserializers;
    }
  }]);

  return GraphSON3Reader;
}(GraphSON2Reader$1);

var graphSON2Deserializers = {
  'g:Traverser': typeSerializers.TraverserSerializer,
  'g:TraversalStrategy': typeSerializers.TraversalStrategySerializer,
  'g:Int32': typeSerializers.NumberSerializer,
  'g:Int64': typeSerializers.NumberSerializer,
  'g:Float': typeSerializers.NumberSerializer,
  'g:Double': typeSerializers.NumberSerializer,
  'g:Date': typeSerializers.DateSerializer,
  'g:Direction': typeSerializers.DirectionSerializer,
  'g:Vertex': typeSerializers.VertexSerializer,
  'g:Edge': typeSerializers.EdgeSerializer,
  'g:VertexProperty': typeSerializers.VertexPropertySerializer,
  'g:Property': typeSerializers.PropertySerializer,
  'g:Path': typeSerializers.Path3Serializer,
  'g:TextP': typeSerializers.TextPSerializer,
  'g:T': typeSerializers.TSerializer,
  'g:BulkSet': typeSerializers.BulkSetSerializer
};
var graphSON3Deserializers = Object.assign({}, graphSON2Deserializers, {
  'g:List': typeSerializers.ListSerializer,
  'g:Set': typeSerializers.SetSerializer,
  'g:Map': typeSerializers.MapSerializer
});
var graphSON2Serializers = [typeSerializers.NumberSerializer, typeSerializers.DateSerializer, typeSerializers.BytecodeSerializer, typeSerializers.TraverserSerializer, typeSerializers.TraversalStrategySerializer, typeSerializers.PSerializer, typeSerializers.TextPSerializer, typeSerializers.LambdaSerializer, typeSerializers.EnumSerializer, typeSerializers.VertexSerializer, typeSerializers.EdgeSerializer, typeSerializers.LongSerializer];
var graphSON3Serializers = graphSON2Serializers.concat([typeSerializers.ListSerializer, typeSerializers.SetSerializer, typeSerializers.MapSerializer]);
var graphSerializer = {
  GraphSON3Writer: GraphSON3Writer$1,
  GraphSON3Reader: GraphSON3Reader$1,
  GraphSON2Writer: GraphSON2Writer$1,
  GraphSON2Reader: GraphSON2Reader$1,
  GraphSONWriter: GraphSON3Writer$1,
  GraphSONReader: GraphSON3Reader$1
};

var util$2 = require$$0__default$1["default"];
var types$3 = types$u;
var utils$7 = utils$V;
var DefaultExecutionOptions$1 = executionOptions.DefaultExecutionOptions,
    proxyExecuteKey = executionOptions.proxyExecuteKey;
var Long = types$3.Long;
var consistencyNames;
var graphProtocol$1 = Object.freeze({
  graphson1: 'graphson-1.0',
  graphson2: 'graphson-2.0',
  graphson3: 'graphson-3.0'
});
var payloadKeys = Object.freeze({
  language: 'graph-language',
  source: 'graph-source',
  name: 'graph-name',
  results: 'graph-results',
  writeConsistency: 'graph-write-consistency',
  readConsistency: 'graph-read-consistency',
  timeout: 'request-timeout'
});
/**
 * Graph options that extends {@link QueryOptions}.
 * <p>
 *   Consider using [execution profiles]{@link ExecutionProfile} if you plan to reuse options across different
 *   query executions.
 * </p>
 * @typedef {QueryOptions} module:datastax/graph~GraphQueryOptions
 * @property {String} [graphLanguage] The graph language to use in graph queries.
 * @property {String} [graphResults] The protocol to use for serializing and deserializing graph results.
 * <p>
 *   Note that this value should rarely be set by users and will otherwise be unset. When unset the server resolves
 *   the protocol based on the <code>graphLanguage</code> specified.
 * </p>
 * @property {String} [graphName] The graph name to be used in the query. You can use <code>null</code> to clear the
 * value from the <code>DseClientOptions</code> and execute a query without a default graph.
 * @property {Number} [graphReadConsistency] Specifies the
 * [consistency level]{@link module:types~consistencies}
 * to be used for the graph read queries in this execution.
 * <p>
 *   When defined, it overrides the consistency level only for the READ part of the graph query.
 * </p>
 * @property {String} [graphSource] The graph traversal source name to use in graph queries.
 * @property {Number} [graphWriteConsistency] Specifies the [consistency level]{@link module:types~consistencies} to
 * be used for the graph write queries in this execution.
 * <p>
 *   When defined, it overrides the consistency level only for the WRITE part of the graph query.
 * </p>
 * @property {RetryPolicy} [retry] Sets the retry policy to be used for the graph query execution.
 * <p>
 *   When not specified in the {@link GraphQueryOptions} or in the {@link ExecutionProfile}, it will use by default
 *   a retry policy that does not retry graph executions.
 * </p>
 */

/**
 * Gets the default options with the custom payload for a given profile.
 * @param {ProfileManager} profileManager
 * @param baseOptions
 * @param {RetryPolicy|null} defaultRetryPolicy
 * @param {ExecutionProfile} profile
 * @returns {DseClientOptions}
 * @private
 */

function getDefaultGraphOptions(profileManager, baseOptions, defaultRetryPolicy, profile) {
  return profileManager.getOrCreateGraphOptions(profile, function createDefaultOptions() {
    var _customPayload;

    var profileOptions = profile.graphOptions || utils$7.emptyObject;
    var defaultProfile = profileManager.getDefault();
    var options = {
      customPayload: (_customPayload = {}, _defineProperty(_customPayload, payloadKeys.language, utils$7.allocBufferFromString(profileOptions.language || baseOptions.language)), _defineProperty(_customPayload, payloadKeys.source, utils$7.allocBufferFromString(profileOptions.source || baseOptions.source)), _customPayload),
      graphLanguage: profileOptions.language || baseOptions.language,
      graphResults: profileOptions.results || baseOptions.results,
      graphSource: profileOptions.source || baseOptions.source,
      graphName: utils$7.ifUndefined(profileOptions.name, baseOptions.name)
    };

    if (profile !== defaultProfile) {
      options.retry = profile.retry || baseOptions.retry;
    } else {
      // Based on an implementation detail of the execution profiles, the retry policy for the default profile is
      // always loaded (required), but that doesn't mean that it was specified by the user.
      // If it wasn't specified by the user, use the default retry policy for graph statements.
      options.retry = defaultRetryPolicy || baseOptions.retry;
    }

    if (baseOptions.executeAs) {
      options.customPayload[proxyExecuteKey] = utils$7.allocBufferFromString(baseOptions.executeAs);
    }

    if (options.graphName) {
      options.customPayload[payloadKeys.name] = utils$7.allocBufferFromString(options.graphName);
    }

    var graphResults = utils$7.ifUndefined(profileOptions.results, baseOptions.graphResults);

    if (graphResults !== undefined) {
      options.customPayload[payloadKeys.results] = utils$7.allocBufferFromString(graphResults);
    }

    var readConsistency = utils$7.ifUndefined(profileOptions.readConsistency, baseOptions.readConsistency);

    if (readConsistency !== undefined) {
      options.customPayload[payloadKeys.readConsistency] = utils$7.allocBufferFromString(getConsistencyName(readConsistency));
    }

    var writeConsistency = utils$7.ifUndefined(profileOptions.writeConsistency, baseOptions.writeConsistency);

    if (writeConsistency !== undefined) {
      options.customPayload[payloadKeys.writeConsistency] = utils$7.allocBufferFromString(getConsistencyName(writeConsistency));
    }

    options.readTimeout = utils$7.ifUndefined3(profile.readTimeout, defaultProfile.readTimeout, baseOptions.readTimeout);

    if (options.readTimeout > 0) {
      // Write the graph read timeout payload
      options.customPayload[payloadKeys.timeout] = longBuffer(options.readTimeout);
    }

    return options;
  });
}
/**
 * Sets the payload key. If the value is not provided, it uses the value from the default profile options.
 * @param {Object} payload
 * @param {QueryOptions} profileOptions
 * @param {String} key
 * @param {String|Number|null} value
 * @param {Function} [converter]
 * @private
 */


function setPayloadKey(payload, profileOptions, key, value, converter) {
  converter = converter || utils$7.allocBufferFromString;

  if (value === null) {
    // Use null to avoid set payload for a key
    return;
  }

  if (value !== undefined) {
    payload[key] = converter(value);
    return;
  }

  if (profileOptions.customPayload[key]) {
    payload[key] = profileOptions.customPayload[key];
  }
}

function longBuffer(value) {
  value = Long.fromNumber(value);
  return Long.toBuffer(value);
}
/**
 * Gets the name in upper case of the consistency level.
 * @param {Number} consistency
 * @private
 */


function getConsistencyName(consistency) {
  // eslint-disable-next-line
  if (consistency == undefined) {
    //null or undefined => undefined
    return undefined;
  }

  loadConsistencyNames();
  var name = consistencyNames[consistency];

  if (!name) {
    throw new Error(util$2.format('Consistency %s not found, use values defined as properties in types.consistencies object', consistency));
  }

  return name;
}

function loadConsistencyNames() {
  if (consistencyNames) {
    return;
  }

  consistencyNames = {};
  var propertyNames = Object.keys(types$3.consistencies);

  for (var i = 0; i < propertyNames.length; i++) {
    var name = propertyNames[i];
    consistencyNames[types$3.consistencies[name]] = name.toUpperCase();
  } //Using java constants naming conventions


  consistencyNames[types$3.consistencies.localQuorum] = 'LOCAL_QUORUM';
  consistencyNames[types$3.consistencies.eachQuorum] = 'EACH_QUORUM';
  consistencyNames[types$3.consistencies.localSerial] = 'LOCAL_SERIAL';
  consistencyNames[types$3.consistencies.localOne] = 'LOCAL_ONE';
}
/**
 * Represents a wrapper around the options related to a graph execution.
 * @internal
 * @ignore
 */


var GraphExecutionOptions$1 = /*#__PURE__*/function (_DefaultExecutionOpti) {
  _inherits(GraphExecutionOptions, _DefaultExecutionOpti);

  var _super = _createSuper(GraphExecutionOptions);

  /**
   * Creates a new instance of GraphExecutionOptions.
   * @param {GraphQueryOptions} queryOptions The user provided query options.
   * @param {Client} client the client instance.
   * @param graphBaseOptions The default graph base options.
   * @param {RetryPolicy} defaultProfileRetryPolicy
   */
  function GraphExecutionOptions(queryOptions, client, graphBaseOptions, defaultProfileRetryPolicy) {
    var _this;

    _classCallCheck(this, GraphExecutionOptions);

    queryOptions = queryOptions || utils$7.emptyObject;
    _this = _super.call(this, queryOptions, client, null);
    _this._defaultGraphOptions = getDefaultGraphOptions(client.profileManager, graphBaseOptions, defaultProfileRetryPolicy, _this.getProfile());
    _this._preferredHost = null;
    _this._graphSubProtocol = queryOptions.graphResults || _this._defaultGraphOptions.graphResults;
    _this._graphLanguage = queryOptions.graphLanguage || _this._defaultGraphOptions.graphLanguage;
    return _this;
  }

  _createClass(GraphExecutionOptions, [{
    key: "setPreferredHost",
    value: function setPreferredHost(host) {
      this._preferredHost = host;
    }
  }, {
    key: "getPreferredHost",
    value: function getPreferredHost() {
      return this._preferredHost;
    }
  }, {
    key: "getGraphSource",
    value: function getGraphSource() {
      return this.getRawQueryOptions().graphSource || this._defaultGraphOptions.graphSource;
    }
  }, {
    key: "getGraphLanguage",
    value: function getGraphLanguage() {
      return this._graphLanguage;
    }
  }, {
    key: "setGraphLanguage",
    value: function setGraphLanguage(value) {
      this._graphLanguage = value;
    }
  }, {
    key: "getGraphName",
    value: function getGraphName() {
      return utils$7.ifUndefined(this.getRawQueryOptions().graphName, this._defaultGraphOptions.graphName);
    }
  }, {
    key: "getGraphSubProtocol",
    value: function getGraphSubProtocol() {
      return this._graphSubProtocol;
    }
  }, {
    key: "setGraphSubProtocol",
    value: function setGraphSubProtocol(protocol) {
      this._graphSubProtocol = protocol;
    }
    /** Graph executions have a specific default read timeout */

  }, {
    key: "getReadTimeout",
    value: function getReadTimeout() {
      return this.getRawQueryOptions().readTimeout || this._defaultGraphOptions.readTimeout;
    }
    /** Graph executions have a specific default retry policy */

  }, {
    key: "getRetryPolicy",
    value: function getRetryPolicy() {
      return this.getRawQueryOptions().retry || this._defaultGraphOptions.retry;
    }
  }, {
    key: "getRowParser",
    value: function getRowParser() {
      var factory = this.getRawQueryOptions().rowParserFactory;

      if (!factory) {
        return null;
      }

      return factory(this.getGraphSubProtocol());
    }
  }, {
    key: "getQueryWriter",
    value: function getQueryWriter() {
      var factory = this.getRawQueryOptions().queryWriterFactory;

      if (!factory) {
        return null;
      }

      return factory(this.getGraphSubProtocol());
    }
  }, {
    key: "setGraphPayload",
    value: function setGraphPayload() {
      var options = this.getRawQueryOptions();
      var defaultOptions = this._defaultGraphOptions; // Clone the existing custom payload (if any)

      var payload = Object.assign({}, this.getCustomPayload()); // Override the payload for DSE Graph exclusive options

      setPayloadKey(payload, defaultOptions, payloadKeys.language, this.getGraphLanguage() !== this._defaultGraphOptions.graphLanguage ? this.getGraphLanguage() : undefined);
      setPayloadKey(payload, defaultOptions, payloadKeys.source, options.graphSource);
      setPayloadKey(payload, defaultOptions, payloadKeys.name, options.graphName);
      setPayloadKey(payload, defaultOptions, payloadKeys.readConsistency, getConsistencyName(options.graphReadConsistency));
      setPayloadKey(payload, defaultOptions, payloadKeys.writeConsistency, getConsistencyName(options.graphWriteConsistency)); // Use the read timeout defined by the user or the one default to graph executions

      setPayloadKey(payload, defaultOptions, payloadKeys.timeout, this.getReadTimeout() > 0 ? this.getReadTimeout() : null, longBuffer); // Graph result is always set

      payload[payloadKeys.results] = defaultOptions.graphResults === this.getGraphSubProtocol() ? defaultOptions.customPayload[payloadKeys.results] : utils$7.allocBufferFromString(this.getGraphSubProtocol());
      this.setCustomPayload(payload);
    }
  }]);

  return GraphExecutionOptions;
}(DefaultExecutionOptions$1);

var options = {
  GraphExecutionOptions: GraphExecutionOptions$1,
  graphProtocol: graphProtocol$1,
  payloadKeys: payloadKeys
};

var utils$6 = utils$V;
var policies = policies$2;
var GraphResultSet = resultSet;
var GraphSON2Reader = graphSerializer.GraphSON2Reader,
    GraphSON2Writer = graphSerializer.GraphSON2Writer,
    GraphSON3Reader = graphSerializer.GraphSON3Reader,
    GraphSON3Writer = graphSerializer.GraphSON3Writer;
var getCustomTypeSerializers = customTypeSerializers;
var GraphExecutionOptions = options.GraphExecutionOptions,
    graphProtocol = options.graphProtocol;
var graphLanguageGroovyString = 'gremlin-groovy';
var graphEngineCore = 'Core';
var graphSON2Reader = new GraphSON2Reader({
  serializers: getCustomTypeSerializers()
});
var graphSON2Writer = new GraphSON2Writer({
  serializers: getCustomTypeSerializers()
});
var graphSON3Reader = new GraphSON3Reader({
  serializers: getCustomTypeSerializers()
});
var graphSON3Writer = new GraphSON3Writer({
  serializers: getCustomTypeSerializers()
});
var rowParsers = new Map([[graphProtocol.graphson2, getRowParser(graphSON2Reader)], [graphProtocol.graphson3, getRowParser(graphSON3Reader)]]);
var defaultWriters = new Map([[graphProtocol.graphson1, function (x) {
  return JSON.stringify(x);
}], [graphProtocol.graphson2, getDefaultWriter(graphSON2Writer)], [graphProtocol.graphson3, getDefaultWriter(graphSON3Writer)]]);
/**
 * Internal class that contains the logic for executing a graph traversal.
 * @ignore
 */

var GraphExecutor$1 = /*#__PURE__*/function () {
  /**
   * Creates a new instance of GraphExecutor.
   * @param {Client} client
   * @param {ClientOptions} rawOptions
   * @param {Function} handler
   */
  function GraphExecutor(client, rawOptions, handler) {
    _classCallCheck(this, GraphExecutor);

    this._client = client;
    this._handler = handler; // Retrieve the retry policy for the default profile to determine if it was specified

    this._defaultProfileRetryPolicy = client.profileManager.getDefaultConfiguredRetryPolicy(); // Use graphBaseOptions as a way to gather all defaults that affect graph executions

    this._graphBaseOptions = utils$6.extend({
      executeAs: client.options.queryOptions.executeAs,
      language: graphLanguageGroovyString,
      source: 'g',
      readTimeout: 0,
      // As the default retry policy might retry non-idempotent queries
      // we should use default retry policy for all graph queries that does not retry
      retry: new policies.retry.FallthroughRetryPolicy()
    }, rawOptions.graphOptions, client.profileManager.getDefault().graphOptions);

    if (this._graphBaseOptions.readTimeout === null) {
      this._graphBaseOptions.readTimeout = client.options.socketOptions.readTimeout;
    }
  }
  /**
   * Executes the graph traversal.
   * @param {String|Object} query
   * @param {Object} parameters
   * @param {GraphQueryOptions} options
   */


  _createClass(GraphExecutor, [{
    key: "send",
    value: function () {
      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(query, parameters, options) {
        var execOptions, host, isQueryObject, queryWriter;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!Array.isArray(parameters)) {
                  _context.next = 2;
                  break;
                }

                throw new TypeError('Parameters must be a Object instance as an associative array');

              case 2:
                if (query) {
                  _context.next = 4;
                  break;
                }

                throw new TypeError('Query must be defined');

              case 4:
                execOptions = new GraphExecutionOptions(options, this._client, this._graphBaseOptions, this._defaultProfileRetryPolicy);

                if (!(execOptions.getGraphSource() === 'a')) {
                  _context.next = 10;
                  break;
                }

                _context.next = 8;
                return this._getAnalyticsMaster();

              case 8:
                host = _context.sent;
                execOptions.setPreferredHost(host);

              case 10:
                // A query object that allows to plugin any executable thing
                isQueryObject = _typeof(query) === 'object' && query.graphLanguage && query.value && query.queryWriterFactory;

                if (isQueryObject) {
                  // Use the provided graph language to override the current
                  execOptions.setGraphLanguage(query.graphLanguage);
                }

                this._setGraphProtocol(execOptions);

                execOptions.setGraphPayload();
                parameters = GraphExecutor._buildGraphParameters(parameters, execOptions.getGraphSubProtocol());

                if (typeof query !== 'string') {
                  // Its a traversal that needs to be converted
                  // Transforming the provided query into a traversal requires the protocol to be set first.
                  // Query writer factory can be defined in the options or in the query object
                  queryWriter = execOptions.getQueryWriter();

                  if (isQueryObject) {
                    queryWriter = query.queryWriterFactory(execOptions.getGraphSubProtocol());
                  } else if (!queryWriter) {
                    queryWriter = GraphExecutor._writerFactory(execOptions.getGraphSubProtocol());
                  }

                  query = queryWriter(!isQueryObject ? query : query.value);
                }

                _context.next = 18;
                return this._executeGraphQuery(query, parameters, execOptions);

              case 18:
                return _context.abrupt("return", _context.sent);

              case 19:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function send(_x, _x2, _x3) {
        return _send.apply(this, arguments);
      }

      return send;
    }()
    /**
     * Sends the graph traversal.
     * @param {string} query
     * @param {object} parameters
     * @param {GraphExecutionOptions} execOptions
     * @returns {Promise<GraphResultSet>}
     * @private
     */

  }, {
    key: "_executeGraphQuery",
    value: function () {
      var _executeGraphQuery2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(query, parameters, execOptions) {
        var result, rowParser;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._handler.call(this._client, query, parameters, execOptions);

              case 2:
                result = _context2.sent;
                // Instances of rowParser transform Row instances into Traverser instances.
                // Traverser instance is an object with the following form { object: any, bulk: number }
                rowParser = execOptions.getRowParser() || GraphExecutor._rowParserFactory(execOptions.getGraphSubProtocol());
                return _context2.abrupt("return", new GraphResultSet(result, rowParser));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _executeGraphQuery(_x4, _x5, _x6) {
        return _executeGraphQuery2.apply(this, arguments);
      }

      return _executeGraphQuery;
    }()
    /**
     * Uses the RPC call to obtain the analytics master host.
     * @returns {Promise<Host|null>}
     * @private
     */

  }, {
    key: "_getAnalyticsMaster",
    value: function () {
      var _getAnalyticsMaster2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _this = this;

        var result, resultField, hostName, addressTranslator;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                _context3.next = 3;
                return this._client.execute('CALL DseClientTool.getAnalyticsGraphServer()', utils$6.emptyArray);

              case 3:
                result = _context3.sent;

                if (!(result.rows.length === 0)) {
                  _context3.next = 7;
                  break;
                }

                this._client.log('verbose', 'Empty response querying graph analytics server, query will not be routed optimally');

                return _context3.abrupt("return", null);

              case 7:
                resultField = result.rows[0]['result'];

                if (!(!resultField || !resultField['location'])) {
                  _context3.next = 11;
                  break;
                }

                this._client.log('verbose', 'Unexpected response querying graph analytics server, query will not be routed optimally', result.rows[0]);

                return _context3.abrupt("return", null);

              case 11:
                hostName = resultField['location'].substr(0, resultField['location'].lastIndexOf(':'));
                addressTranslator = this._client.options.policies.addressResolution;
                _context3.next = 15;
                return new Promise(function (resolve) {
                  addressTranslator.translate(hostName, _this._client.options.protocolOptions.port, function (endpoint) {
                    return resolve(_this._client.hosts.get(endpoint));
                  });
                });

              case 15:
                return _context3.abrupt("return", _context3.sent);

              case 18:
                _context3.prev = 18;
                _context3.t0 = _context3["catch"](0);

                this._client.log('verbose', 'Error querying graph analytics server, query will not be routed optimally', _context3.t0);

                return _context3.abrupt("return", null);

              case 22:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 18]]);
      }));

      function _getAnalyticsMaster() {
        return _getAnalyticsMaster2.apply(this, arguments);
      }

      return _getAnalyticsMaster;
    }()
    /**
     * Resolves what protocol should be used for decoding graph results for the given execution.
     *
     * <p>Resolution is done in the following manner if graphResults is not set:</p>
     *
     * <ul>
     *   <li>If graph name is set, and associated keyspace's graph engine is set to "Core", use {@link
      *       graphProtocol#graphson3}.
     *   <li>Else, if the graph language is not 'gremlin-groovy', use {@link graphProtocol#graphson2}
     *   <li>Otherwise, use {@link graphProtocol#graphson1}
     * </ul>
     * @param {GraphExecutionOptions} execOptions
     */

  }, {
    key: "_setGraphProtocol",
    value: function _setGraphProtocol(execOptions) {
      var protocol = execOptions.getGraphSubProtocol();

      if (protocol) {
        return;
      }

      if (execOptions.getGraphName()) {
        var keyspace = this._client.metadata.keyspaces[execOptions.getGraphName()];

        if (keyspace && keyspace.graphEngine === graphEngineCore) {
          protocol = graphProtocol.graphson3;
        }
      }

      if (!protocol) {
        // Decide the minimal version supported by the graph language
        if (execOptions.getGraphLanguage() === graphLanguageGroovyString) {
          protocol = graphProtocol.graphson1;
        } else {
          protocol = graphProtocol.graphson2;
        }
      }

      execOptions.setGraphSubProtocol(protocol);
    }
    /**
     * Only GraphSON1 parameters are supported.
     * @param {Array|function|null} parameters
     * @param {string} protocol
     * @returns {string[]|null}
     * @private
     */

  }], [{
    key: "_buildGraphParameters",
    value: function _buildGraphParameters(parameters, protocol) {
      if (!parameters || _typeof(parameters) !== 'object') {
        return null;
      }

      var queryWriter = GraphExecutor._writerFactory(protocol);

      return [protocol !== graphProtocol.graphson1 && protocol !== graphProtocol.graphson2 ? queryWriter(new Map(Object.entries(parameters))) : queryWriter(parameters)];
    }
  }, {
    key: "_rowParserFactory",
    value: function _rowParserFactory(protocol) {
      var handler = rowParsers.get(protocol);

      if (!handler) {
        // Default to no row parser
        return null;
      }

      return handler;
    }
  }, {
    key: "_writerFactory",
    value: function _writerFactory(protocol) {
      var handler = defaultWriters.get(protocol);

      if (!handler) {
        throw new Error("No writer defined for protocol ".concat(protocol));
      }

      return handler;
    }
  }]);

  return GraphExecutor;
}();

function getRowParser(reader) {
  return function (row) {
    var item = reader.read(JSON.parse(row['gremlin']));
    return {
      object: item['result'],
      bulk: item['bulk'] || 1
    };
  };
}

function getDefaultWriter(writer) {
  return function (value) {
    return writer.write(value);
  };
}

var graphExecutor = GraphExecutor$1;

var events = require$$0__default$2["default"];
var util$1 = require$$0__default$1["default"];
var utils$5 = utils$V;
var errors$3 = errors$s;
var types$2 = types$u;
var ProfileManager = executionProfile.ProfileManager;
var requests = requests$7;
var clientOptions = clientOptions$3;
var ClientState = clientState;
var description = require$$17.description;
var version = require$$17.version;
var DefaultExecutionOptions = executionOptions.DefaultExecutionOptions;
var ControlConnection = controlConnection;
var RequestHandler = requestHandler;
var PrepareHandler = prepareHandler;
var InsightsClient = insightsClient;
var cloud = cloud$1;
var GraphExecutor = graphExecutor;
var promiseUtils = promiseUtils$e;
/**
 * Max amount of pools being warmup in parallel, when warmup is enabled
 * @private
 */

var warmupLimit = 32;
/**
 * Client options.
 * <p>While the driver provides lots of extensibility points and configurability, few client options are required.</p>
 * <p>Default values for all settings are designed to be suitable for the majority of use cases, you should avoid
 * fine tuning it when not needed.</p>
 * <p>See [Client constructor]{@link Client} documentation for recommended options.</p>
 * @typedef {Object} ClientOptions
 * @property {Array.<string>} contactPoints
 * Array of addresses or host names of the nodes to add as contact points.
 * <p>
 *  Contact points are addresses of Cassandra nodes that the driver uses to discover the cluster topology.
 * </p>
 * <p>
 *  Only one contact point is required (the driver will retrieve the address of the other nodes automatically),
 *  but it is usually a good idea to provide more than one contact point, because if that single contact point is
 *  unavailable, the driver will not be able to initialize correctly.
 * </p>
 * @property {String} [localDataCenter] The local data center to use.
 * <p>
 *   If using DCAwareRoundRobinPolicy (default), this option is required and only hosts from this data center are
 *   connected to and used in query plans.
 * </p>
 * @property {String} [keyspace] The logged keyspace for all the connections created within the {@link Client} instance.
 * @property {Object} [credentials] An object containing the username and password for plain-text authentication.
 * It configures the authentication provider to be used against Apache Cassandra's PasswordAuthenticator or DSE's
 * DseAuthenticator, when default auth scheme is plain-text.
 * <p>
 *   Note that you should configure either <code>credentials</code> or <code>authProvider</code> to connect to an
 *   auth-enabled cluster, but not both.
 * </p>
 * @property {String} [credentials.username] The username to use for plain-text authentication.
 * @property {String} [credentials.password] The password to use for plain-text authentication.
 * @property {Uuid} [id] A unique identifier assigned to a {@link Client} object, that will be communicated to the
 * server (DSE 6.0+) to identify the client instance created with this options. When not defined, the driver will
 * generate a random identifier.
 * @property {String} [applicationName] An optional setting identifying the name of the application using
 * the {@link Client} instance.
 * <p>This value is passed to DSE and is useful as metadata for describing a client connection on the server side.</p>
 * @property {String} [applicationVersion] An optional setting identifying the version of the application using
 * the {@link Client} instance.
 * <p>This value is passed to DSE and is useful as metadata for describing a client connection on the server side.</p>
 * @property {Object} [monitorReporting] Options for reporting mechanism from the client to the DSE server, for
 * versions that support it.
 * @property {Boolean} [monitorReporting.enabled=true] Determines whether the reporting mechanism is enabled.
 * Defaults to <code>true</code>.
 * @property {Object} [cloud] The options to connect to a cloud instance.
 * @property {String|URL} cloud.secureConnectBundle Determines the file path for the credentials file bundle.
 * @property {Number} [refreshSchemaDelay] The default window size in milliseconds used to debounce node list and schema
 * refresh metadata requests. Default: 1000.
 * @property {Boolean} [isMetadataSyncEnabled] Determines whether client-side schema metadata retrieval and update is
 * enabled.
 * <p>Setting this value to <code>false</code> will cause keyspace information not to be automatically loaded, affecting
 * replica calculation per token in the different keyspaces. When disabling metadata synchronization, use
 * [Metadata.refreshKeyspaces()]{@link module:metadata~Metadata#refreshKeyspaces} to keep keyspace information up to
 * date or token-awareness will not work correctly.</p>
 * Default: <code>true</code>.
 * @property {Boolean} [prepareOnAllHosts] Determines if the driver should prepare queries on all hosts in the cluster.
 * Default: <code>true</code>.
 * @property {Boolean} [rePrepareOnUp] Determines if the driver should re-prepare all cached prepared queries on a
 * host when it marks it back up.
 * Default: <code>true</code>.
 * @property {Number} [maxPrepared] Determines the maximum amount of different prepared queries before evicting items
 * from the internal cache. Reaching a high threshold hints that the queries are not being reused, like when
 * hard-coding parameter values inside the queries.
 * Default: <code>500</code>.
 * @property {Object} [policies]
 * @property {LoadBalancingPolicy} [policies.loadBalancing] The load balancing policy instance to be used to determine
 * the coordinator per query.
 * @property {RetryPolicy} [policies.retry] The retry policy.
 * @property {ReconnectionPolicy} [policies.reconnection] The reconnection policy to be used.
 * @property {AddressTranslator} [policies.addressResolution] The address resolution policy.
 * @property {SpeculativeExecutionPolicy} [policies.speculativeExecution] The <code>SpeculativeExecutionPolicy</code>
 * instance to be used to determine if the client should send speculative queries when the selected host takes more
 * time than expected.
 * <p>
 *   Default: <code>[NoSpeculativeExecutionPolicy]{@link
  *   module:policies/speculativeExecution~NoSpeculativeExecutionPolicy}</code>
 * </p>
 * @property {TimestampGenerator} [policies.timestampGeneration] The client-side
 * [query timestamp generator]{@link module:policies/timestampGeneration~TimestampGenerator}.
 * <p>
 *   Default: <code>[MonotonicTimestampGenerator]{@link module:policies/timestampGeneration~MonotonicTimestampGenerator}
 *   </code>
 * </p>
 * <p>Use <code>null</code> to disable client-side timestamp generation.</p>
 * @property {QueryOptions} [queryOptions] Default options for all queries.
 * @property {Object} [pooling] Pooling options.
 * @property {Number} [pooling.heartBeatInterval] The amount of idle time in milliseconds that has to pass before the
 * driver issues a request on an active connection to avoid idle time disconnections. Default: 30000.
 * @property {Object} [pooling.coreConnectionsPerHost] Associative array containing amount of connections per host
 * distance.
 * @property {Number} [pooling.maxRequestsPerConnection] The maximum number of requests per connection. The default
 * value is:
 * <ul>
 *   <li>For modern protocol versions (v3 and above): 2048</li>
 *   <li>For older protocol versions (v1 and v2): 128</li>
 * </ul>
 * @property {Boolean} [pooling.warmup] Determines if all connections to hosts in the local datacenter must be opened on
 * connect. Default: true.
 * @property {Object} [protocolOptions]
 * @property {Number} [protocolOptions.port] The port to use to connect to the Cassandra host. If not set through this
 * method, the default port (9042) will be used instead.
 * @property {Number} [protocolOptions.maxSchemaAgreementWaitSeconds] The maximum time in seconds to wait for schema
 * agreement between nodes before returning from a DDL query. Default: 10.
 * @property {Number} [protocolOptions.maxVersion] When set, it limits the maximum protocol version used to connect to
 * the nodes.
 * Useful for using the driver against a cluster that contains nodes with different major/minor versions of Cassandra.
 * @property {Boolean} [protocolOptions.noCompact] When set to true, enables the NO_COMPACT startup option.
 * <p>
 * When this option is supplied <code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>BATCH</code>
 * statements on <code>COMPACT STORAGE</code> tables function in "compatibility" mode which allows seeing these tables
 * as if they were "regular" CQL tables.
 * </p>
 * <p>
 * This option only effects interactions with interactions with tables using <code>COMPACT STORAGE</code> and is only
 * supported by C* 3.0.16+, 3.11.2+, 4.0+ and DSE 6.0+.
 * </p>
 * @property {Object} [socketOptions]
 * @property {Number} [socketOptions.connectTimeout] Connection timeout in milliseconds. Default: 5000.
 * @property {Number} [socketOptions.defunctReadTimeoutThreshold] Determines the amount of requests that simultaneously
 * have to timeout before closing the connection. Default: 64.
 * @property {Boolean} [socketOptions.keepAlive] Whether to enable TCP keep-alive on the socket. Default: true.
 * @property {Number} [socketOptions.keepAliveDelay] TCP keep-alive delay in milliseconds. Default: 0.
 * @property {Number} [socketOptions.readTimeout] Per-host read timeout in milliseconds.
 * <p>
 *   Please note that this is not the maximum time a call to {@link Client#execute} may have to wait;
 *   this is the maximum time that call will wait for one particular Cassandra host, but other hosts will be tried if
 *   one of them timeout. In other words, a {@link Client#execute} call may theoretically wait up to
 *   <code>readTimeout * number_of_cassandra_hosts</code> (though the total number of hosts tried for a given query also
 *   depends on the LoadBalancingPolicy in use).
 * <p>When setting this value, keep in mind the following:</p>
 * <ul>
 *   <li>the timeout settings used on the Cassandra side (*_request_timeout_in_ms in cassandra.yaml) should be taken
 *   into account when picking a value for this read timeout. You should pick a value a couple of seconds greater than
 *   the Cassandra timeout settings.
 *   </li>
 *   <li>
 *     the read timeout is only approximate and only control the timeout to one Cassandra host, not the full query.
 *   </li>
 * </ul>
 * Setting a value of 0 disables read timeouts. Default: <code>12000</code>.
 * @property {Boolean} [socketOptions.tcpNoDelay] When set to true, it disables the Nagle algorithm. Default: true.
 * @property {Number} [socketOptions.coalescingThreshold] Buffer length in bytes use by the write queue before flushing
 * the frames. Default: 8000.
 * @property {AuthProvider} [authProvider] Provider to be used to authenticate to an auth-enabled cluster.
 * @property {RequestTracker} [requestTracker] The instance of RequestTracker used to monitor or log requests executed
 * with this instance.
 * @property {Object} [sslOptions] Client-to-node ssl options. When set the driver will use the secure layer.
 * You can specify cert, ca, ... options named after the Node.js <code>tls.connect()</code> options.
 * <p>
 *   It uses the same default values as Node.js <code>tls.connect()</code> except for <code>rejectUnauthorized</code>
 *   which is set to <code>false</code> by default (for historical reasons). This setting is likely to change
 *   in upcoming versions to enable validation by default.
 * </p>
 * @property {Object} [encoding] Encoding options.
 * @property {Function} [encoding.map] Map constructor to use for Cassandra map<k,v> type encoding and decoding.
 * If not set, it will default to Javascript Object with map keys as property names.
 * @property {Function} [encoding.set] Set constructor to use for Cassandra set<k> type encoding and decoding.
 * If not set, it will default to Javascript Array.
 * @property {Boolean} [encoding.copyBuffer] Determines if the network buffer should be copied for buffer based data
 * types (blob, uuid, timeuuid and inet).
 * <p>
 *   Setting it to true will cause that the network buffer is copied for each row value of those types,
 *   causing additional allocations but freeing the network buffer to be reused.
 *   Setting it to true is a good choice for cases where the Row and ResultSet returned by the queries are long-lived
 *   objects.
 * </p>
 * <p>
 *  Setting it to false will cause less overhead and the reference of the network buffer to be maintained until the row
 *  / result set are de-referenced.
 *  Default: true.
 * </p>
 * @property {Boolean} [encoding.useUndefinedAsUnset] Valid for Cassandra 2.2 and above. Determines that, if a parameter
 * is set to
 * <code>undefined</code> it should be encoded as <code>unset</code>.
 * <p>
 *  By default, ECMAScript <code>undefined</code> is encoded as <code>null</code> in the driver. Cassandra 2.2
 *  introduced the concept of unset.
 *  At driver level, you can set a parameter to unset using the field <code>types.unset</code>. Setting this flag to
 *  true allows you to use ECMAScript undefined as Cassandra <code>unset</code>.
 * </p>
 * <p>
 *   Default: true.
 * </p>
 * @property {Boolean} [encoding.useBigIntAsLong] Use [BigInt ECMAScript type](https://tc39.github.io/proposal-bigint/)
 * to represent CQL bigint and counter data types.
 * @property {Boolean} [encoding.useBigIntAsVarint] Use [BigInt ECMAScript
 * type](https://tc39.github.io/proposal-bigint/) to represent CQL varint data type.
 * @property {Array.<ExecutionProfile>} [profiles] The array of [execution profiles]{@link ExecutionProfile}.
 * @property {Function} [promiseFactory] Function to be used to create a <code>Promise</code> from a
 * callback-style function.
 * <p>
 *   Promise libraries often provide different methods to create a promise. For example, you can use Bluebird's
 *   <code>Promise.fromCallback()</code> method.
 * </p>
 * <p>
 *   By default, the driver will use the
 *   [Promise constructor]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise}.
 * </p>
 */

/**
 * Query options
 * @typedef {Object} QueryOptions
 * @property {Boolean} [autoPage] Determines if the driver must retrieve the following result pages automatically.
 * <p>
 *   This setting is only considered by the [Client#eachRow()]{@link Client#eachRow} method. For more information,
 *   check the
 *   [paging results documentation]{@link https://docs.datastax.com/en/developer/nodejs-driver/latest/features/paging/}.
 * </p>
 * @property {Boolean} [captureStackTrace] Determines if the stack trace before the query execution should be
 * maintained.
 * <p>
 *   Useful for debugging purposes, it should be set to <code>false</code> under production environment as it adds an
 *   unnecessary overhead to each execution.
 * </p>
 * Default: false.
 * @property {Number} [consistency] [Consistency level]{@link module:types~consistencies}.
 * <p>
 *   Defaults to <code>localOne</code> for Apache Cassandra and DSE deployments.
 *   For DataStax Astra, it defaults to <code>localQuorum</code>.
 * </p>
 * @property {Object} [customPayload] Key-value payload to be passed to the server. On the Cassandra side,
 * implementations of QueryHandler can use this data.
 * @property {String} [executeAs] The user or role name to act as when executing this statement.
 * <p>When set, it executes as a different user/role than the one currently authenticated (a.k.a. proxy execution).</p>
 * <p>This feature is only available in DSE 5.1+.</p>
 * @property {String|ExecutionProfile} [executionProfile] Name or instance of the [profile]{@link ExecutionProfile} to
 * be used for this execution. If not set, it will the use "default" execution profile.
 * @property {Number} [fetchSize] Amount of rows to retrieve per page.
 * @property {Array|Array<Array>} [hints] Type hints for parameters given in the query, ordered as for the parameters.
 * <p>For batch queries, an array of such arrays, ordered as with the queries in the batch.</p>
 * @property {Host} [host] The host that should handle the query.
 * <p>
 *   Use of this option is <em>heavily discouraged</em> and should only be used in the following cases:
 * </p>
 * <ol>
 *   <li>
 *     Querying node-local tables, such as tables in the <code>system</code> and <code>system_views</code>
 *     keyspaces.
 *   </li>
 *   <li>
 *     Applying a series of schema changes, where it may be advantageous to execute schema changes in sequence on the
 *     same node.
 *   </li>
 * </ol>
 * <p>
 *   Configuring a specific host causes the configured
 *   [LoadBalancingPolicy]{@link module:policies/loadBalancing~LoadBalancingPolicy} to be completely bypassed.
 *   However, if the load balancing policy dictates that the host is at a
 *   [distance of ignored]{@link module:types~distance} or there is no active connectivity to the host, the request will
 *   fail with a [NoHostAvailableError]{@link module:errors~NoHostAvailableError}.
 * </p>
 * @property {Boolean} [isIdempotent] Defines whether the query can be applied multiple times without changing the result
 * beyond the initial application.
 * <p>
 *   The query execution idempotence can be used at [RetryPolicy]{@link module:policies/retry~RetryPolicy} level to
 *   determine if an statement can be retried in case of request error or write timeout.
 * </p>
 * <p>Default: <code>false</code>.</p>
 * @property {String} [keyspace] Specifies the keyspace for the query. It is used for the following:
 * <ol>
 * <li>To indicate what keyspace the statement is applicable to (protocol V5+ only).  This is useful when the
 * query does not provide an explicit keyspace and you want to override the current {@link Client#keyspace}.</li>
 * <li>For query routing when the query operates on a different keyspace than the current {@link Client#keyspace}.</li>
 * </ol>
 * @property {Boolean} [logged] Determines if the batch should be written to the batchlog. Only valid for
 * [Client#batch()]{@link Client#batch}, it will be ignored by other methods. Default: true.
 * @property {Boolean} [counter] Determines if its a counter batch. Only valid for
 * [Client#batch()]{@link Client#batch}, it will be ignored by other methods. Default: false.
 * @property {Buffer|String} [pageState] Buffer or string token representing the paging state.
 * <p>Useful for manual paging, if provided, the query will be executed starting from a given paging state.</p>
 * @property {Boolean} [prepare] Determines if the query must be executed as a prepared statement.
 * @property {Number} [readTimeout] When defined, it overrides the default read timeout
 * (<code>socketOptions.readTimeout</code>) in milliseconds for this execution per coordinator.
 * <p>
 *   Suitable for statements for which the coordinator may allow a longer server-side timeout, for example aggregation
 *   queries.
 * </p>
 * <p>
 *   A value of <code>0</code> disables client side read timeout for the execution. Default: <code>undefined</code>.
 * </p>
 * @property {RetryPolicy} [retry] Retry policy for the query.
 * <p>
 *   This property can be used to specify a different [retry policy]{@link module:policies/retry} to the one specified
 *   in the {@link ClientOptions}.policies.
 * </p>
 * @property {Array} [routingIndexes] Index of the parameters that are part of the partition key to determine
 * the routing.
 * @property {Buffer|Array} [routingKey] Partition key(s) to determine which coordinator should be used for the query.
 * @property {Array} [routingNames] Array of the parameters names that are part of the partition key to determine the
 * routing. Only valid for non-prepared requests, it's recommended that you use the prepare flag instead.
 * @property {Number} [serialConsistency] Serial consistency is the consistency level for the serial phase of
 * conditional updates.
 * This option will be ignored for anything else that a conditional update/insert.
 * @property {Number|Long} [timestamp] The default timestamp for the query in microseconds from the unix epoch
 * (00:00:00, January 1st, 1970).
 * <p>If provided, this will replace the server side assigned timestamp as default timestamp.</p>
 * <p>Use [generateTimestamp()]{@link module:types~generateTimestamp} utility method to generate a valid timestamp
 * based on a Date and microseconds parts.</p>
 * @property {Boolean} [traceQuery] Enable query tracing for the execution. Use query tracing to diagnose performance
 * problems related to query executions. Default: false.
 * <p>To retrieve trace, you can call [Metadata.getTrace()]{@link module:metadata~Metadata#getTrace} method.</p>
 * @property {Object} [graphOptions] Default options for graph query executions.
 * <p>
 *   These options are meant to provide defaults for all graph query executions. Consider using
 *   [execution profiles]{@link ExecutionProfile} if you plan to reuse different set of options across different
 *   query executions.
 * </p>
 * @property {String} [graphOptions.language] The graph language to use in graph queries. Default:
 * <code>'gremlin-groovy'</code>.
 * @property {String} [graphOptions.name] The graph name to be used in all graph queries.
 * <p>
 * This property is required but there is no default value for it. This value can be overridden at query level.
 * </p>
 * @property {Number} [graphOptions.readConsistency] Overrides the
 * [consistency level]{@link module:types~consistencies}
 * defined in the query options for graph read queries.
 * @property {Number} [graphOptions.readTimeout] Overrides the default per-host read timeout (in milliseconds) for all
 * graph queries. Default: <code>0</code>.
 * <p>
 *   Use <code>null</code> to reset the value and use the default on <code>socketOptions.readTimeout</code> .
 * </p>
 * @property {String} [graphOptions.source] The graph traversal source name to use in graph queries. Default:
 * <code>'g'</code>.
 * @property {Number} [graphOptions.writeConsistency] Overrides the [consistency
 * level]{@link module:types~consistencies} defined in the query options for graph write queries.
 */

/**
 * Creates a new instance of {@link Client}.
 * @classdesc
 * Represents a database client that maintains multiple connections to the cluster nodes, providing methods to
 * execute CQL statements.
 * <p>
 * The <code>Client</code> uses [policies]{@link module:policies} to decide which nodes to connect to, which node
 * to use per each query execution, when it should retry failed or timed-out executions and how reconnection to down
 * nodes should be made.
 * </p>
 * @extends EventEmitter
 * @param {ClientOptions} options The options for this instance.
 * @example <caption>Creating a new client instance</caption>
 * const client = new Client({
 *   contactPoints: ['10.0.1.101', '10.0.1.102'],
 *   localDataCenter: 'datacenter1'
 * });
 * @example <caption>Executing a query</caption>
 * const result = await client.connect();
 * console.log(`Connected to ${client.hosts.length} nodes in the cluster: ${client.hosts.keys().join(', ')}`);
 * @example <caption>Executing a query</caption>
 * const result = await client.execute('SELECT key FROM system.local');
 * const row = result.first();
 * console.log(row['key']);
 * @constructor
 */

function Client(options) {
  events.EventEmitter.call(this);
  this.options = clientOptions.extend({
    logEmitter: this.emit.bind(this),
    id: types$2.Uuid.random()
  }, options);
  Object.defineProperty(this, 'profileManager', {
    value: new ProfileManager(this.options)
  });
  Object.defineProperty(this, 'controlConnection', {
    value: new ControlConnection(this.options, this.profileManager),
    writable: true
  });
  Object.defineProperty(this, 'insightsClient', {
    value: new InsightsClient(this)
  }); //Unlimited amount of listeners for internal event queues by default

  this.setMaxListeners(0);
  this.connected = false;
  this.isShuttingDown = false;
  /**
   * Gets the name of the active keyspace.
   * @type {String}
   */

  this.keyspace = options.keyspace;
  /**
   * Gets the schema and cluster metadata information.
   * @type {Metadata}
   */

  this.metadata = this.controlConnection.metadata;
  /**
   * Gets an associative array of cluster hosts.
   * @type {HostMap}
   */

  this.hosts = this.controlConnection.hosts;
  /**
   * The [ClientMetrics]{@link module:metrics~ClientMetrics} instance used to expose measurements of its internal
   * behavior and of the server as seen from the driver side.
   * <p>By default, a [DefaultMetrics]{@link module:metrics~DefaultMetrics} instance is used.</p>
   * @type {ClientMetrics}
   */

  this.metrics = this.options.metrics;
  this._graphExecutor = new GraphExecutor(this, options, this._execute);
}

util$1.inherits(Client, events.EventEmitter);
/**
 * Emitted when a new host is added to the cluster.
 * <ul>
 *   <li>{@link Host} The host being added.</li>
 * </ul>
 * @event Client#hostAdd
 */

/**
 * Emitted when a host is removed from the cluster
 * <ul>
 *   <li>{@link Host} The host being removed.</li>
 * </ul>
 * @event Client#hostRemove
 */

/**
 * Emitted when a host in the cluster changed status from down to up.
 * <ul>
 *   <li>{@link Host host} The host that changed the status.</li>
 * </ul>
 * @event Client#hostUp
 */

/**
 * Emitted when a host in the cluster changed status from up to down.
 * <ul>
 *   <li>{@link Host host} The host that changed the status.</li>
 * </ul>
 * @event Client#hostDown
 */

/**
 * Attempts to connect to one of the [contactPoints]{@link ClientOptions} and discovers the rest the nodes of the
 * cluster.
 * <p>When the {@link Client} is already connected, it resolves immediately.</p>
 * <p>It returns a <code>Promise</code> when a <code>callback</code> is not provided.</p>
 * @param {function} [callback] The optional callback that is invoked when the pool is connected or it failed to
 * connect.
 * @example <caption>Usage example</caption>
 * await client.connect();
 */

Client.prototype.connect = function (callback) {
  if (this.connected && callback) {
    // Avoid creating Promise to immediately resolve them
    return callback();
  }

  return promiseUtils.optionalCallback(this._connect(), callback);
};
/**
 * Async-only version of {@link Client#connect()}.
 * @private
 */


Client.prototype._connect = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
  return regeneratorRuntime.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!this.connected) {
            _context.next = 2;
            break;
          }

          return _context.abrupt("return");

        case 2:
          if (!this.isShuttingDown) {
            _context.next = 4;
            break;
          }

          throw new errors$3.NoHostAvailableError(null, 'Connecting after shutdown is not supported');

        case 4:
          if (!this.connecting) {
            _context.next = 6;
            break;
          }

          return _context.abrupt("return", promiseUtils.fromEvent(this, 'connected'));

        case 6:
          this.connecting = true;
          this.log('info', util$1.format("Connecting to cluster using '%s' version %s", description, version));
          _context.prev = 8;
          _context.next = 11;
          return cloud.init(this.options);

        case 11:
          _context.next = 13;
          return this.controlConnection.init();

        case 13:
          this.hosts = this.controlConnection.hosts;
          _context.next = 16;
          return this.profileManager.init(this, this.hosts);

        case 16:
          if (!this.keyspace) {
            _context.next = 19;
            break;
          }

          _context.next = 19;
          return RequestHandler.setKeyspace(this);

        case 19:
          clientOptions.setMetadataDependent(this);
          _context.next = 22;
          return this._warmup();

        case 22:
          _context.next = 32;
          break;

        case 24:
          _context.prev = 24;
          _context.t0 = _context["catch"](8);
          _context.next = 28;
          return this.controlConnection.reset();

        case 28:
          this.connected = false;
          this.connecting = false;
          this.emit('connected', _context.t0);
          throw _context.t0;

        case 32:
          this._setHostListeners(); // Set the distance of the control connection host relatively to this instance


          this.profileManager.getDistance(this.controlConnection.host);
          this.insightsClient.init();
          this.connected = true;
          this.connecting = false;
          this.emit('connected');

        case 38:
        case "end":
          return _context.stop();
      }
    }
  }, _callee, this, [[8, 24]]);
}));
/**
 * Executes a query on an available connection.
 * <p>The query can be prepared (recommended) or not depending on the [prepare]{@linkcode QueryOptions} flag.</p>
 * <p>
 *   Some execution failures can be handled transparently by the driver, according to the
 *   [RetryPolicy]{@linkcode module:policies/retry~RetryPolicy} or the
 *   [SpeculativeExecutionPolicy]{@linkcode module:policies/speculativeExecution} used.
 * </p>
 * <p>It returns a <code>Promise</code> when a <code>callback</code> is not provided.</p>
 * @param {String} query The query to execute.
 * @param {Array|Object} [params] Array of parameter values or an associative array (object) containing parameter names
 * as keys and its value.
 * @param {QueryOptions} [options] The query options for the execution.
 * @param {ResultCallback} [callback] Executes callback(err, result) when execution completed. When not defined, the
 * method will return a promise.
 * @example <caption>Promise-based API, using async/await</caption>
 * const query = 'SELECT name, email FROM users WHERE id = ?';
 * const result = await client.execute(query, [ id ], { prepare: true });
 * const row = result.first();
 * console.log('%s: %s', row['name'], row['email']);
 * @example <caption>Callback-based API</caption>
 * const query = 'SELECT name, email FROM users WHERE id = ?';
 * client.execute(query, [ id ], { prepare: true }, function (err, result) {
 *   assert.ifError(err);
 *   const row = result.first();
 *   console.log('%s: %s', row['name'], row['email']);
 * });
 * @see {@link ExecutionProfile} to reuse a set of options across different query executions.
 */

Client.prototype.execute = function (query, params, options, callback) {
  // This method acts as a wrapper for the async method _execute()
  if (!callback) {
    // Set default argument values for optional parameters
    if (typeof options === 'function') {
      callback = options;
      options = null;
    } else if (typeof params === 'function') {
      callback = params;
      params = null;
    }
  }

  try {
    var execOptions = DefaultExecutionOptions.create(options, this);
    return promiseUtils.optionalCallback(this._execute(query, params, execOptions), callback);
  } catch (err) {
    // There was an error when parsing the user options
    if (callback) {
      return callback(err);
    }

    return Promise.reject(err);
  }
};
/**
 * Executes a graph query.
 * <p>It returns a <code>Promise</code> when a <code>callback</code> is not provided.</p>
 * @param {String} query The gremlin query.
 * @param {Object|null} [parameters] An associative array containing the key and values of the parameters.
 * @param {GraphQueryOptions|null} [options] The graph query options.
 * @param {Function} [callback] Function to execute when the response is retrieved, taking two arguments:
 * <code>err</code> and <code>result</code>. When not defined, the method will return a promise.
 * @example <caption>Promise-based API, using async/await</caption>
 * const result = await client.executeGraph('g.V()');
 * // Get the first item (vertex, edge, scalar value, ...)
 * const vertex = result.first();
 * console.log(vertex.label);
 * @example <caption>Callback-based API</caption>
 * client.executeGraph('g.V()', (err, result) => {
 *   const vertex = result.first();
 *   console.log(vertex.label);
 * });
 * @example <caption>Iterating through the results</caption>
 * const result = await client.executeGraph('g.E()');
 * for (let edge of result) {
 *   console.log(edge.label); // created
 * });
 * @example <caption>Using result.forEach()</caption>
 * const result = await client.executeGraph('g.V().hasLabel("person")');
 * result.forEach(function(vertex) {
 *   console.log(vertex.type); // vertex
 *   console.log(vertex.label); // person
 * });
 * @see {@link ExecutionProfile} to reuse a set of options across different query executions.
 */


Client.prototype.executeGraph = function (query, parameters, options, callback) {
  callback = callback || (options ? options : parameters);

  if (typeof callback === 'function') {
    parameters = typeof parameters !== 'function' ? parameters : null;
    return promiseUtils.toCallback(this._graphExecutor.send(query, parameters, options), callback);
  }

  return this._graphExecutor.send(query, parameters, options);
};
/**
 * Executes the query and calls <code>rowCallback</code> for each row as soon as they are received. Calls the final
 * <code>callback</code> after all rows have been sent, or when there is an error.
 * <p>
 *   The query can be prepared (recommended) or not depending on the [prepare]{@linkcode QueryOptions} flag.
 * </p>
 * @param {String} query The query to execute
 * @param {Array|Object} [params] Array of parameter values or an associative array (object) containing parameter names
 * as keys and its value.
 * @param {QueryOptions} [options] The query options.
 * @param {function} rowCallback Executes <code>rowCallback(n, row)</code> per each row received, where n is the row
 * index and row is the current Row.
 * @param {function} [callback] Executes <code>callback(err, result)</code> after all rows have been received.
 * <p>
 *   When dealing with paged results, [ResultSet#nextPage()]{@link module:types~ResultSet#nextPage} method can be used
 *   to retrieve the following page. In that case, <code>rowCallback()</code> will be again called for each row and
 *   the final callback will be invoked when all rows in the following page has been retrieved.
 * </p>
 * @example <caption>Using per-row callback and arrow functions</caption>
 * client.eachRow(query, params, { prepare: true }, (n, row) => console.log(n, row), err => console.error(err));
 * @example <caption>Overloads</caption>
 * client.eachRow(query, rowCallback);
 * client.eachRow(query, params, rowCallback);
 * client.eachRow(query, params, options, rowCallback);
 * client.eachRow(query, params, rowCallback, callback);
 * client.eachRow(query, params, options, rowCallback, callback);
 */


Client.prototype.eachRow = function (query, params, options, rowCallback, callback) {
  var _this = this;

  if (!callback && rowCallback && typeof options === 'function') {
    callback = utils$5.validateFn(rowCallback, 'rowCallback');
    rowCallback = options;
  } else {
    callback = callback || utils$5.noop;
    rowCallback = utils$5.validateFn(rowCallback || options || params, 'rowCallback');
  }

  params = typeof params !== 'function' ? params : null;
  var execOptions;

  try {
    execOptions = DefaultExecutionOptions.create(options, this, rowCallback);
  } catch (e) {
    return callback(e);
  }

  var rowLength = 0;

  var nextPage = function nextPage() {
    return promiseUtils.toCallback(_this._execute(query, params, execOptions), pageCallback);
  };

  function pageCallback(err, result) {
    if (err) {
      return callback(err);
    } // Next requests in case paging (auto or explicit) is used


    rowLength += result.rowLength;

    if (result.rawPageState !== undefined) {
      // Use new page state as next request page state
      execOptions.setPageState(result.rawPageState);

      if (execOptions.isAutoPage()) {
        // Issue next request for the next page
        return nextPage();
      } // Allows for explicit (manual) paging, in case the caller needs it


      result.nextPage = nextPage;
    } // Finished auto-paging


    result.rowLength = rowLength;
    callback(null, result);
  }

  promiseUtils.toCallback(this._execute(query, params, execOptions), pageCallback);
};
/**
 * Executes the query and pushes the rows to the result stream as soon as they received.
 * <p>
 * The stream is a [ReadableStream]{@linkcode https://nodejs.org/api/stream.html#stream_class_stream_readable} object
 *  that emits rows.
 *  It can be piped downstream and provides automatic pause/resume logic (it buffers when not read).
 * </p>
 * <p>
 *   The query can be prepared (recommended) or not depending on {@link QueryOptions}.prepare flag. Retries on multiple
 *   hosts if needed.
 * </p>
 * @param {String} query The query to prepare and execute.
 * @param {Array|Object} [params] Array of parameter values or an associative array (object) containing parameter names
 * as keys and its value
 * @param {QueryOptions} [options] The query options.
 * @param {function} [callback] executes callback(err) after all rows have been received or if there is an error
 * @returns {ResultStream}
 */


Client.prototype.stream = function (query, params, options, callback) {
  callback = callback || utils$5.noop; // NOTE: the nodejs stream maintains yet another internal buffer
  // we rely on the default stream implementation to keep memory
  // usage reasonable.

  var resultStream = new types$2.ResultStream({
    objectMode: 1
  });

  function onFinish(err, result) {
    if (err) {
      resultStream.emit('error', err);
    }

    if (result && result.nextPage) {
      // allows for throttling as per the
      // default nodejs stream implementation
      resultStream._valve(function pageValve() {
        try {
          result.nextPage();
        } catch (ex) {
          resultStream.emit('error', ex);
        }
      });

      return;
    } // Explicitly dropping the valve (closure)


    resultStream._valve(null);

    resultStream.add(null);
    callback(err);
  }

  var sync = true;
  this.eachRow(query, params, options, function rowCallback(n, row) {
    resultStream.add(row);
  }, function eachRowFinished(err, result) {
    if (sync) {
      // Prevent sync callback
      return setImmediate(function eachRowFinishedImmediate() {
        onFinish(err, result);
      });
    }

    onFinish(err, result);
  });
  sync = false;
  return resultStream;
};
/**
 * Executes batch of queries on an available connection to a host.
 * <p>It returns a <code>Promise</code> when a <code>callback</code> is not provided.</p>
 * @param {Array.<string>|Array.<{query, params}>} queries The queries to execute as an Array of strings or as an array
 * of object containing the query and params
 * @param {QueryOptions} [options] The query options.
 * @param {ResultCallback} [callback] Executes callback(err, result) when the batch was executed
 */


Client.prototype.batch = function (queries, options, callback) {
  if (!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  return promiseUtils.optionalCallback(this._batch(queries, options), callback);
};
/**
 * Async-only version of {@link Client#batch()} .
 * @param {Array.<string>|Array.<{query, params}>}queries
 * @param {QueryOptions} options
 * @returns {Promise<ResultSet>}
 * @private
 */


Client.prototype._batch = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(queries, options) {
    var execOptions, queryItems, _version, queryKeyspace, i, item, query, request;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (Array.isArray(queries)) {
              _context2.next = 2;
              break;
            }

            throw new errors$3.ArgumentError('Queries should be an Array');

          case 2:
            if (!(queries.length === 0)) {
              _context2.next = 4;
              break;
            }

            throw new errors$3.ArgumentError('Queries array should not be empty');

          case 4:
            _context2.next = 6;
            return this._connect();

          case 6:
            execOptions = DefaultExecutionOptions.create(options, this);

            if (!execOptions.isPrepared()) {
              _context2.next = 15;
              break;
            }

            // use keyspace from query options if protocol supports per-query keyspace, otherwise use connection keyspace.
            _version = this.controlConnection.protocolVersion;
            queryKeyspace = types$2.protocolVersion.supportsKeyspaceInRequest(_version) && options.keyspace || this.keyspace;
            _context2.next = 12;
            return PrepareHandler.getPreparedMultiple(this, execOptions.getLoadBalancingPolicy(), queries, queryKeyspace);

          case 12:
            queryItems = _context2.sent;
            _context2.next = 28;
            break;

          case 15:
            queryItems = new Array(queries.length);
            i = 0;

          case 17:
            if (!(i < queries.length)) {
              _context2.next = 28;
              break;
            }

            item = queries[i];

            if (item) {
              _context2.next = 21;
              break;
            }

            throw new errors$3.ArgumentError("Invalid query at index ".concat(i));

          case 21:
            query = typeof item === 'string' ? item : item.query;

            if (query) {
              _context2.next = 24;
              break;
            }

            throw new errors$3.ArgumentError("Invalid query at index ".concat(i));

          case 24:
            queryItems[i] = {
              query: query,
              params: item.params
            };

          case 25:
            i++;
            _context2.next = 17;
            break;

          case 28:
            _context2.next = 30;
            return this._createBatchRequest(queryItems, execOptions);

          case 30:
            request = _context2.sent;
            _context2.next = 33;
            return RequestHandler.send(request, execOptions, this);

          case 33:
            return _context2.abrupt("return", _context2.sent);

          case 34:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function (_x, _x2) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Gets the host that are replicas of a given token.
 * @param {String} keyspace
 * @param {Buffer} token
 * @returns {Array<Host>}
 */


Client.prototype.getReplicas = function (keyspace, token) {
  return this.metadata.getReplicas(keyspace, token);
};
/**
 * Gets a snapshot containing information on the connections pools held by this Client at the current time.
 * <p>
 *   The information provided in the returned object only represents the state at the moment this method was called and
 *   it's not maintained in sync with the driver metadata.
 * </p>
 * @returns {ClientState} A [ClientState]{@linkcode module:metadata~ClientState} instance.
 */


Client.prototype.getState = function () {
  return ClientState.from(this);
};

Client.prototype.log = utils$5.log;
/**
 * Closes all connections to all hosts.
 * <p>It returns a <code>Promise</code> when a <code>callback</code> is not provided.</p>
 * @param {Function} [callback] Optional callback to be invoked when finished closing all connections.
 */

Client.prototype.shutdown = function (callback) {
  return promiseUtils.optionalCallback(this._shutdown(), callback);
};
/** @private */


Client.prototype._shutdown = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
  var hosts;
  return regeneratorRuntime.wrap(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          this.log('info', 'Shutting down');

          if (!(!this.hosts || !this.connected)) {
            _context3.next = 4;
            break;
          }

          // not initialized
          this.connected = false;
          return _context3.abrupt("return");

        case 4:
          if (!this.connecting) {
            _context3.next = 8;
            break;
          }

          this.log('warning', 'Shutting down while connecting'); // wait until finish connecting for easier troubleshooting

          _context3.next = 8;
          return promiseUtils.fromEvent(this, 'connected');

        case 8:
          this.connected = false;
          this.isShuttingDown = true;
          hosts = this.hosts.values();
          this.insightsClient.shutdown(); // Shutdown the ControlConnection before shutting down the pools

          this.controlConnection.shutdown();
          this.options.policies.speculativeExecution.shutdown();

          if (this.options.requestTracker) {
            this.options.requestTracker.shutdown();
          } // go through all the host and shut down their pools


          _context3.next = 17;
          return Promise.all(hosts.map(function (h) {
            return h.shutdown(false);
          }));

        case 17:
        case "end":
          return _context3.stop();
      }
    }
  }, _callee3, this);
}));
/**
 * Waits until that the schema version in all nodes is the same or the waiting time passed.
 * @param {Connection} connection
 * @returns {Promise<boolean>}
 * @ignore
 */

Client.prototype._waitForSchemaAgreement = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(connection) {
    var start, maxWaitSeconds, versionsMatch;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(this.hosts.length === 1)) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return", true);

          case 2:
            start = process.hrtime();
            maxWaitSeconds = this.options.protocolOptions.maxSchemaAgreementWaitSeconds;
            this.log('info', 'Waiting for schema agreement');

          case 5:
            if (!(!versionsMatch && process.hrtime(start)[0] < maxWaitSeconds)) {
              _context4.next = 16;
              break;
            }

            _context4.next = 8;
            return this.metadata.compareSchemaVersions(connection);

          case 8:
            versionsMatch = _context4.sent;

            if (!versionsMatch) {
              _context4.next = 12;
              break;
            }

            this.log('info', 'Schema versions match');
            return _context4.abrupt("break", 16);

          case 12:
            _context4.next = 14;
            return promiseUtils.delay(500);

          case 14:
            _context4.next = 5;
            break;

          case 16:
            return _context4.abrupt("return", versionsMatch);

          case 17:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));

  return function (_x3) {
    return _ref4.apply(this, arguments);
  };
}();
/**
 * Waits for schema agreements and schedules schema metadata refresh.
 * @param {Connection} connection
 * @param event
 * @returns {Promise<boolean>}
 * @ignore
 * @internal
 */


Client.prototype.handleSchemaAgreementAndRefresh = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(connection, event) {
    var agreement;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            agreement = false;
            _context5.prev = 1;
            _context5.next = 4;
            return this._waitForSchemaAgreement(connection);

          case 4:
            agreement = _context5.sent;
            _context5.next = 10;
            break;

          case 7:
            _context5.prev = 7;
            _context5.t0 = _context5["catch"](1);
            //we issue a warning but we continue with the normal flow
            this.log('warning', 'There was an error while waiting for the schema agreement between nodes', _context5.t0);

          case 10:
            if (this.options.isMetadataSyncEnabled) {
              _context5.next = 12;
              break;
            }

            return _context5.abrupt("return", agreement);

          case 12:
            _context5.prev = 12;
            _context5.next = 15;
            return this.controlConnection.handleSchemaChange(event, true);

          case 15:
            _context5.next = 20;
            break;

          case 17:
            _context5.prev = 17;
            _context5.t1 = _context5["catch"](12);
            this.log('warning', 'There was an error while handling schema change', _context5.t1);

          case 20:
            return _context5.abrupt("return", agreement);

          case 21:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this, [[1, 7], [12, 17]]);
  }));

  return function (_x4, _x5) {
    return _ref5.apply(this, arguments);
  };
}();
/**
 * Connects and handles the execution of prepared and simple statements.
 * @param {string} query
 * @param {Array} params
 * @param {ExecutionOptions} execOptions
 * @returns {Promise<ResultSet>}
 * @private
 */


Client.prototype._execute = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(query, params, execOptions) {
    var version, request, lbp, queryKeyspace, _yield$PrepareHandler, queryId, meta;

    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            version = this.controlConnection.protocolVersion;

            if (!(!execOptions.isPrepared() && params && !Array.isArray(params) && !types$2.protocolVersion.supportsNamedParameters(version))) {
              _context6.next = 3;
              break;
            }

            throw new errors$3.ArgumentError('Named parameters for simple statements are not supported, use prepare flag');

          case 3:
            if (this.connected) {
              _context6.next = 6;
              break;
            }

            _context6.next = 6;
            return this._connect();

          case 6:
            if (execOptions.isPrepared()) {
              _context6.next = 12;
              break;
            }

            _context6.next = 9;
            return this._createQueryRequest(query, execOptions, params);

          case 9:
            request = _context6.sent;
            _context6.next = 22;
            break;

          case 12:
            lbp = execOptions.getLoadBalancingPolicy(); // Use keyspace from query options if protocol supports per-query keyspace, otherwise use connection keyspace.

            queryKeyspace = types$2.protocolVersion.supportsKeyspaceInRequest(version) && execOptions.getKeyspace() || this.keyspace;
            _context6.next = 16;
            return PrepareHandler.getPrepared(this, lbp, query, queryKeyspace);

          case 16:
            _yield$PrepareHandler = _context6.sent;
            queryId = _yield$PrepareHandler.queryId;
            meta = _yield$PrepareHandler.meta;
            _context6.next = 21;
            return this._createExecuteRequest(query, queryId, execOptions, params, meta);

          case 21:
            request = _context6.sent;

          case 22:
            _context6.next = 24;
            return RequestHandler.send(request, execOptions, this);

          case 24:
            return _context6.abrupt("return", _context6.sent);

          case 25:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));

  return function (_x6, _x7, _x8) {
    return _ref6.apply(this, arguments);
  };
}();
/**
 * Sets the listeners for the nodes.
 * @private
 */


Client.prototype._setHostListeners = function () {
  function getHostUpListener(emitter, h) {
    return function () {
      return emitter.emit('hostUp', h);
    };
  }

  function getHostDownListener(emitter, h) {
    return function () {
      return emitter.emit('hostDown', h);
    };
  }

  var self = this; // Add status listeners when new nodes are added and emit hostAdd

  this.hosts.on('add', function hostAddedListener(h) {
    h.on('up', getHostUpListener(self, h));
    h.on('down', getHostDownListener(self, h));
    self.emit('hostAdd', h);
  }); // Remove all listeners and emit hostRemove

  this.hosts.on('remove', function hostRemovedListener(h) {
    h.removeAllListeners();
    self.emit('hostRemove', h);
  }); // Add status listeners for existing hosts

  this.hosts.forEach(function (h) {
    h.on('up', getHostUpListener(self, h));
    h.on('down', getHostDownListener(self, h));
  });
};
/**
 * Sets the distance to each host and when warmup is true, creates all connections to local hosts.
 * @returns {Promise}
 * @private
 */


Client.prototype._warmup = function () {
  var _this2 = this;

  var hosts = this.hosts.values();
  return promiseUtils.times(hosts.length, warmupLimit, /*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(index) {
      var h, distance;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              h = hosts[index];
              distance = _this2.profileManager.getDistance(h);

              if (!(distance === types$2.distance.ignored)) {
                _context7.next = 4;
                break;
              }

              return _context7.abrupt("return");

            case 4:
              if (!(_this2.options.pooling.warmup && distance === types$2.distance.local)) {
                _context7.next = 15;
                break;
              }

              _context7.prev = 5;
              _context7.next = 8;
              return h.warmupPool(_this2.keyspace);

            case 8:
              _context7.next = 13;
              break;

            case 10:
              _context7.prev = 10;
              _context7.t0 = _context7["catch"](5);

              // An error while trying to create a connection to one of the hosts.
              // Warn the user and move on.
              _this2.log('warning', "Connection pool to host ".concat(h.address, " could not be created: ").concat(_context7.t0), _context7.t0);

            case 13:
              _context7.next = 16;
              break;

            case 15:
              h.initializePool();

            case 16:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, null, [[5, 10]]);
    }));

    return function (_x9) {
      return _ref7.apply(this, arguments);
    };
  }());
};
/**
 * @returns {Encoder}
 * @private
 */


Client.prototype._getEncoder = function () {
  var encoder = this.controlConnection.getEncoder();

  if (!encoder) {
    throw new errors$3.DriverInternalError('Encoder is not defined');
  }

  return encoder;
};
/**
 * Returns a BatchRequest instance and fills the routing key information in the provided options.
 * @private
 */


Client.prototype._createBatchRequest = /*#__PURE__*/function () {
  var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(queryItems, info) {
    var firstQuery;
    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            firstQuery = queryItems[0];

            if (firstQuery.meta) {
              _context8.next = 3;
              break;
            }

            return _context8.abrupt("return", new requests.BatchRequest(queryItems, info));

          case 3:
            _context8.next = 5;
            return this._setRoutingInfo(info, firstQuery.params, firstQuery.meta);

          case 5:
            return _context8.abrupt("return", new requests.BatchRequest(queryItems, info));

          case 6:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this);
  }));

  return function (_x10, _x11) {
    return _ref8.apply(this, arguments);
  };
}();
/**
 * Returns an ExecuteRequest instance and fills the routing key information in the provided options.
 * @private
 */


Client.prototype._createExecuteRequest = /*#__PURE__*/function () {
  var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(query, queryId, info, params, meta) {
    return regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            params = utils$5.adaptNamedParamsPrepared(params, meta.columns);
            _context9.next = 3;
            return this._setRoutingInfo(info, params, meta);

          case 3:
            return _context9.abrupt("return", new requests.ExecuteRequest(query, queryId, params, info, meta));

          case 4:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, this);
  }));

  return function (_x12, _x13, _x14, _x15, _x16) {
    return _ref9.apply(this, arguments);
  };
}();
/**
 * Returns a QueryRequest instance and fills the routing key information in the provided options.
 * @private
 */


Client.prototype._createQueryRequest = /*#__PURE__*/function () {
  var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(query, execOptions, params) {
    var paramsInfo;
    return regeneratorRuntime.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return this.metadata.adaptUserHints(this.keyspace, execOptions.getHints());

          case 2:
            paramsInfo = utils$5.adaptNamedParamsWithHints(params, execOptions);

            this._getEncoder().setRoutingKeyFromUser(paramsInfo.params, execOptions, paramsInfo.keyIndexes);

            return _context10.abrupt("return", new requests.QueryRequest(query, paramsInfo.params, execOptions, paramsInfo.namedParameters));

          case 5:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10, this);
  }));

  return function (_x17, _x18, _x19) {
    return _ref10.apply(this, arguments);
  };
}();
/**
 * Sets the routing key based on the parameter values or the provided routing key components.
 * @param {ExecutionOptions} execOptions
 * @param {Array} params
 * @param meta
 * @private
 */


Client.prototype._setRoutingInfo = /*#__PURE__*/function () {
  var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(execOptions, params, meta) {
    var encoder, tableInfo;
    return regeneratorRuntime.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            encoder = this._getEncoder();

            if (!execOptions.getKeyspace() && meta.keyspace) {
              execOptions.setKeyspace(meta.keyspace);
            }

            if (!execOptions.getRoutingKey()) {
              _context11.next = 4;
              break;
            }

            return _context11.abrupt("return", encoder.setRoutingKeyFromUser(params, execOptions));

          case 4:
            if (!Array.isArray(meta.partitionKeys)) {
              _context11.next = 7;
              break;
            }

            // The partition keys are provided as part of the metadata for modern protocol versions
            execOptions.setRoutingIndexes(meta.partitionKeys);
            return _context11.abrupt("return", encoder.setRoutingKeyFromMeta(meta, params, execOptions));

          case 7:
            _context11.prev = 7;
            _context11.next = 10;
            return this.metadata.getTable(meta.keyspace, meta.table);

          case 10:
            tableInfo = _context11.sent;

            if (tableInfo) {
              _context11.next = 13;
              break;
            }

            return _context11.abrupt("return");

          case 13:
            execOptions.setRoutingIndexes(tableInfo.partitionKeys.map(function (c) {
              return meta.columnsByName[c.name];
            })); // Skip parsing metadata next time

            meta.partitionKeys = execOptions.getRoutingIndexes();
            encoder.setRoutingKeyFromMeta(meta, params, execOptions);
            _context11.next = 21;
            break;

          case 18:
            _context11.prev = 18;
            _context11.t0 = _context11["catch"](7);
            this.log('warning', util$1.format('Table %s.%s metadata could not be retrieved', meta.keyspace, meta.table));

          case 21:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11, this, [[7, 18]]);
  }));

  return function (_x20, _x21, _x22) {
    return _ref11.apply(this, arguments);
  };
}();

var mapping = {};

var EventEmitter = require$$0__default$2["default"];
/**
 * Represents a tree node where the key is composed by 1 or more strings.
 * @ignore
 */

var Node = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Node, _EventEmitter);

  var _super = _createSuper(Node);

  /**
   * Creates a new instance of {@link Node}.
   * @param {Array<String>} key
   * @param {Object} value
   * @param {Array} [edges]
   */
  function Node(key, value, edges) {
    var _this;

    _classCallCheck(this, Node);

    _this = _super.call(this);
    _this.key = key;
    _this.value = value;
    _this.edges = edges || [];
    return _this;
  }

  return _createClass(Node);
}(EventEmitter);
/**
 * A radix tree where each node contains a key, a value and edges.
 * @ignore
 */


var Tree$2 = /*#__PURE__*/function (_Node) {
  _inherits(Tree, _Node);

  var _super2 = _createSuper(Tree);

  function Tree() {
    var _this2;

    _classCallCheck(this, Tree);

    _this2 = _super2.call(this, [], null);
    _this2.length = 0;
    return _this2;
  }
  /**
   * Gets the existing item in the tree or creates a new one with the value provided by valueHandler
   * @param {Iterator} keyIterator
   * @param {Function} valueHandler
   * @return {Object}
   */


  _createClass(Tree, [{
    key: "getOrCreate",
    value: function getOrCreate(keyIterator, valueHandler) {
      if (typeof keyIterator.next !== 'function') {
        keyIterator = keyIterator[Symbol.iterator]();
      }

      var node = this;
      var isMatch = false;
      var item = keyIterator.next();

      while (true) {
        var newBranch = void 0; // Check node keys at position 1 and above

        for (var i = 1; i < node.key.length; i++) {
          if (item.done || node.key[i] !== item.value) {
            // We should branch out
            newBranch = this._createBranch(node, i, item.done, valueHandler);
            break;
          }

          item = keyIterator.next();
        }

        if (item.done) {
          isMatch = true;
          break;
        }

        if (newBranch !== undefined) {
          break;
        }

        var edges = node.edges;
        var nextNode = void 0;

        for (var _i = 0; _i < edges.length; _i++) {
          var e = edges[_i];

          if (e.key[0] === item.value) {
            // its a match
            nextNode = e;
            item = keyIterator.next();
            break;
          }
        }

        if (nextNode === undefined) {
          // Current node is the root for a new leaf
          break;
        } else {
          node = nextNode;
        }
      }

      if (!isMatch) {
        // Create using "node" as the root
        var value = valueHandler();
        node.edges.push(new Node(iteratorToArray(item.value, keyIterator), value));

        this._onItemAdded();

        return value;
      }

      return node.value;
    }
  }, {
    key: "_createBranch",
    value: function _createBranch(node, index, useNewValue, valueHandler) {
      var newBranch = new Node(node.key.slice(index), node.value, node.edges);
      node.key = node.key.slice(0, index);
      node.edges = [newBranch];

      if (useNewValue) {
        // The previous node value has moved to a leaf
        // The node containing the new leaf should use the new value
        node.value = valueHandler();

        this._onItemAdded();
      } else {
        // Clear the value as it was copied in the branch
        node.value = null;
      }

      return newBranch;
    }
  }, {
    key: "_onItemAdded",
    value: function _onItemAdded() {
      this.length++;
      this.emit('add', this.length);
    }
  }]);

  return Tree;
}(Node);

function iteratorToArray(value, iterator) {
  var values = [value];
  var item = iterator.next();

  while (!item.done) {
    values.push(item.value);
    item = iterator.next();
  }

  return values;
}

var tree = Tree$2;

var q$1 = {};

var errors$2 = errors$s;
/**
 * Represents a CQL query operator, like >=, IN, <, ...
 * @ignore
 */

var QueryOperator$2 = /*#__PURE__*/_createClass(
/**
 * Creates a new instance of <code>QueryOperator</code>.
 * @param {String} key
 * @param value
 * @param [hasChildValues]
 * @param [isInOperator]
 */
function QueryOperator(key, value, hasChildValues, isInOperator) {
  _classCallCheck(this, QueryOperator);

  /**
   * The CQL key representing the operator
   * @type {string}
   */
  this.key = key;
  /**
   * The value to be used as parameter.
   */

  this.value = value;
  /**
   * Determines whether a query operator can have child values or operators (AND, OR)
   */

  this.hasChildValues = hasChildValues;
  /**
   * Determines whether this instance represents CQL "IN" operator.
   */

  this.isInOperator = isInOperator;
});
/**
 * Represents a CQL assignment operation, like col = col + x.
 * @ignore
 */


var QueryAssignment$2 = /*#__PURE__*/_createClass(function QueryAssignment(sign, value, inverted) {
  _classCallCheck(this, QueryAssignment);

  /**
   * Gets the sign of the assignment operation.
   */
  this.sign = sign;
  /**
   * Gets the value to be assigned.
   */

  this.value = value;
  /**
   * Determines whether the assignment should be inverted (prepends), e.g: col = x + col
   * @type {boolean}
   */

  this.inverted = !!inverted;
});
/**
 * Contains functions that represents operators in a query.
 * @alias module:mapping~q
 * @type {Object}
 * @property {function} in_ Represents the CQL operator "IN".
 * @property {function} gt Represents the CQL operator greater than ">".
 * @property {function} gte Represents the CQL operator greater than or equals to ">=" .
 * @property {function} lt Represents the CQL operator less than "<" .
 * @property {function} lte Represents the CQL operator less than or equals to "<=" .
 * @property {function} notEq Represents the CQL operator not equals to "!=" .
 * @property {function} and When applied to a property, it represents two CQL conditions on the same column separated
 * by the logical AND operator, e.g: "col1 >= x col < y"
 * @property {function} incr Represents the CQL increment assignment used for counters, e.g: "col = col + x"
 * @property {function} decr Represents the CQL decrement assignment used for counters, e.g: "col = col - x"
 * @property {function} append Represents the CQL append assignment used for collections, e.g: "col = col + x"
 * @property {function} prepend Represents the CQL prepend assignment used for lists, e.g: "col = x + col"
 * @property {function} remove Represents the CQL remove assignment used for collections, e.g: "col = col - x"
 */


var q = {
  in_: function in_(arr) {
    if (!Array.isArray(arr)) {
      throw new errors$2.ArgumentError('IN operator supports only Array values');
    }

    return new QueryOperator$2('IN', arr, false, true);
  },
  gt: function gt(value) {
    return new QueryOperator$2('>', value);
  },
  gte: function gte(value) {
    return new QueryOperator$2('>=', value);
  },
  lt: function lt(value) {
    return new QueryOperator$2('<', value);
  },
  lte: function lte(value) {
    return new QueryOperator$2('<=', value);
  },
  notEq: function notEq(value) {
    return new QueryOperator$2('!=', value);
  },
  and: function and(condition1, condition2) {
    return new QueryOperator$2('AND', [condition1, condition2], true);
  },
  incr: function incr(value) {
    return new QueryAssignment$2('+', value);
  },
  decr: function decr(value) {
    return new QueryAssignment$2('-', value);
  },
  append: function append(value) {
    return new QueryAssignment$2('+', value);
  },
  prepend: function prepend(value) {
    return new QueryAssignment$2('+', value, true);
  },
  remove: function remove(value) {
    return new QueryAssignment$2('-', value);
  }
};
q$1.q = q;
q$1.QueryAssignment = QueryAssignment$2;
q$1.QueryOperator = QueryOperator$2;

var qModule$1 = q$1;
var QueryOperator$1 = qModule$1.QueryOperator;
var QueryAssignment$1 = qModule$1.QueryAssignment;
/**
 * Provides utility methods for obtaining a caching keys based on the specifics of the Mapper methods.
 * @ignore
 */

var Cache$2 = /*#__PURE__*/function () {
  function Cache() {
    _classCallCheck(this, Cache);
  }

  _createClass(Cache, null, [{
    key: "getSelectKey",
    value:
    /*#__PURE__*/

    /**
     * Gets an iterator of keys to uniquely identify a document shape for a select query.
     * @param {Array<String>} docKeys
     * @param {Object} doc
     * @param {{fields, limit, orderBy}} docInfo
     * @returns {Iterator}
     */
    regeneratorRuntime.mark(function getSelectKey(docKeys, doc, docInfo) {
      return regeneratorRuntime.wrap(function getSelectKey$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(Cache._yieldKeyAndOperators(docKeys, doc), "t0", 1);

            case 1:
              return _context.delegateYield(Cache._getSelectDocInfo(docInfo), "t1", 2);

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, getSelectKey);
    })
    /**
     * Gets an iterator of keys to uniquely identify a shape for a select all query.
     * @param {{fields, limit, orderBy}} docInfo
     * @returns {Iterator}
     */

  }, {
    key: "getSelectAllKey",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function getSelectAllKey(docInfo) {
      return regeneratorRuntime.wrap(function getSelectAllKey$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return 'root';

            case 2:
              return _context2.delegateYield(Cache._getSelectDocInfo(docInfo), "t0", 3);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, getSelectAllKey);
    })
    /**
     * Gets the parts of the key for a select query related to the docInfo.
     * @param {{fields, limit, orderBy}} docInfo
     * @private
     */

  }, {
    key: "_getSelectDocInfo",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function _getSelectDocInfo(docInfo) {
      var keys, i, key;
      return regeneratorRuntime.wrap(function _getSelectDocInfo$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!docInfo) {
                _context3.next = 22;
                break;
              }

              if (!(docInfo.fields && docInfo.fields.length > 0)) {
                _context3.next = 5;
                break;
              }

              _context3.next = 4;
              return '|f|';

            case 4:
              return _context3.delegateYield(docInfo.fields, "t0", 5);

            case 5:
              if (!(typeof docInfo.limit === 'number')) {
                _context3.next = 8;
                break;
              }

              _context3.next = 8;
              return '|l|';

            case 8:
              if (!docInfo.orderBy) {
                _context3.next = 22;
                break;
              }

              _context3.next = 11;
              return '|o|';

            case 11:
              // orderBy is uses property names as keys and 'asc'/'desc' as values
              keys = Object.keys(docInfo.orderBy);
              i = 0;

            case 13:
              if (!(i < keys.length)) {
                _context3.next = 22;
                break;
              }

              key = keys[i];
              _context3.next = 17;
              return key;

            case 17:
              _context3.next = 19;
              return docInfo.orderBy[key];

            case 19:
              i++;
              _context3.next = 13;
              break;

            case 22:
            case "end":
              return _context3.stop();
          }
        }
      }, _getSelectDocInfo);
    })
    /**
     * Gets an iterator of keys to uniquely identify a document shape for an insert query.
     * @param {Array<String>} docKeys
     * @param {{ifNotExists, ttl, fields}} docInfo
     * @returns {Iterator}
     */

  }, {
    key: "getInsertKey",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function getInsertKey(docKeys, docInfo) {
      return regeneratorRuntime.wrap(function getInsertKey$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.delegateYield(docKeys, "t0", 1);

            case 1:
              if (!docInfo) {
                _context4.next = 12;
                break;
              }

              if (!(docInfo.fields && docInfo.fields.length > 0)) {
                _context4.next = 6;
                break;
              }

              _context4.next = 5;
              return '|f|';

            case 5:
              return _context4.delegateYield(docInfo.fields, "t1", 6);

            case 6:
              if (!(typeof docInfo.ttl === 'number')) {
                _context4.next = 9;
                break;
              }

              _context4.next = 9;
              return '|t|';

            case 9:
              if (!docInfo.ifNotExists) {
                _context4.next = 12;
                break;
              }

              _context4.next = 12;
              return '|e|';

            case 12:
            case "end":
              return _context4.stop();
          }
        }
      }, getInsertKey);
    })
    /**
     * Gets an iterator of keys to uniquely identify a document shape for an UPDATE query.
     * @param {Array<String>} docKeys
     * @param {Object} doc
     * @param {{ifExists, when, ttl, fields}} docInfo
     */

  }, {
    key: "getUpdateKey",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function getUpdateKey(docKeys, doc, docInfo) {
      return regeneratorRuntime.wrap(function getUpdateKey$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.delegateYield(Cache._yieldKeyAndAllQs(docKeys, doc), "t0", 1);

            case 1:
              if (!docInfo) {
                _context5.next = 14;
                break;
              }

              if (!(docInfo.fields && docInfo.fields.length > 0)) {
                _context5.next = 6;
                break;
              }

              _context5.next = 5;
              return '|f|';

            case 5:
              return _context5.delegateYield(docInfo.fields, "t1", 6);

            case 6:
              if (!(typeof docInfo.ttl === 'number')) {
                _context5.next = 9;
                break;
              }

              _context5.next = 9;
              return '|t|';

            case 9:
              if (!docInfo.ifExists) {
                _context5.next = 12;
                break;
              }

              _context5.next = 12;
              return '|e|';

            case 12:
              if (!docInfo.when) {
                _context5.next = 14;
                break;
              }

              return _context5.delegateYield(Cache._yieldKeyAndOperators(Object.keys(docInfo.when), docInfo.when), "t2", 14);

            case 14:
            case "end":
              return _context5.stop();
          }
        }
      }, getUpdateKey);
    })
    /**
     * Gets an iterator of keys to uniquely identify a document shape for a DELETE query.
     * @param {Array<String>} docKeys
     * @param {Object} doc
     * @param {{ifExists, when, fields, deleteOnlyColumns}} docInfo
     * @returns {Iterator}
     */

  }, {
    key: "getRemoveKey",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function getRemoveKey(docKeys, doc, docInfo) {
      return regeneratorRuntime.wrap(function getRemoveKey$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.delegateYield(Cache._yieldKeyAndOperators(docKeys, doc), "t0", 1);

            case 1:
              if (!docInfo) {
                _context6.next = 14;
                break;
              }

              if (!(docInfo.fields && docInfo.fields.length > 0)) {
                _context6.next = 6;
                break;
              }

              _context6.next = 5;
              return '|f|';

            case 5:
              return _context6.delegateYield(docInfo.fields, "t1", 6);

            case 6:
              if (!docInfo.ifExists) {
                _context6.next = 9;
                break;
              }

              _context6.next = 9;
              return '|e|';

            case 9:
              if (!docInfo.deleteOnlyColumns) {
                _context6.next = 12;
                break;
              }

              _context6.next = 12;
              return '|dc|';

            case 12:
              if (!docInfo.when) {
                _context6.next = 14;
                break;
              }

              return _context6.delegateYield(Cache._yieldKeyAndOperators(Object.keys(docInfo.when), docInfo.when), "t2", 14);

            case 14:
            case "end":
              return _context6.stop();
          }
        }
      }, getRemoveKey);
    })
  }, {
    key: "_yieldKeyAndOperators",
    value: /*#__PURE__*/regeneratorRuntime.mark(function _yieldKeyAndOperators(keys, obj) {
      var i, key;
      return regeneratorRuntime.wrap(function _yieldKeyAndOperators$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              i = 0;

            case 1:
              if (!(i < keys.length)) {
                _context7.next = 9;
                break;
              }

              key = keys[i];
              _context7.next = 5;
              return key;

            case 5:
              return _context7.delegateYield(Cache._yieldOperators(obj[key]), "t0", 6);

            case 6:
              i++;
              _context7.next = 1;
              break;

            case 9:
            case "end":
              return _context7.stop();
          }
        }
      }, _yieldKeyAndOperators);
    })
  }, {
    key: "_yieldOperators",
    value: /*#__PURE__*/regeneratorRuntime.mark(function _yieldOperators(value) {
      return regeneratorRuntime.wrap(function _yieldOperators$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (!(value !== null && value !== undefined && value instanceof QueryOperator$1)) {
                _context8.next = 8;
                break;
              }

              _context8.next = 3;
              return value.key;

            case 3:
              if (!value.hasChildValues) {
                _context8.next = 8;
                break;
              }

              return _context8.delegateYield(Cache._yieldOperators(value.value[0]), "t0", 5);

            case 5:
              _context8.next = 7;
              return '|/|';

            case 7:
              return _context8.delegateYield(Cache._yieldOperators(value.value[1]), "t1", 8);

            case 8:
            case "end":
              return _context8.stop();
          }
        }
      }, _yieldOperators);
    })
  }, {
    key: "_yieldKeyAndAllQs",
    value: /*#__PURE__*/regeneratorRuntime.mark(function _yieldKeyAndAllQs(keys, obj) {
      var i, key, value;
      return regeneratorRuntime.wrap(function _yieldKeyAndAllQs$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              i = 0;

            case 1:
              if (!(i < keys.length)) {
                _context9.next = 19;
                break;
              }

              key = keys[i];
              _context9.next = 5;
              return key;

            case 5:
              value = obj[key];

              if (!(value !== null && value !== undefined)) {
                _context9.next = 16;
                break;
              }

              if (!(value instanceof QueryOperator$1)) {
                _context9.next = 11;
                break;
              }

              return _context9.delegateYield(Cache._yieldOperators(value), "t0", 9);

            case 9:
              _context9.next = 16;
              break;

            case 11:
              if (!(value instanceof QueryAssignment$1)) {
                _context9.next = 16;
                break;
              }

              _context9.next = 14;
              return value.sign;

            case 14:
              _context9.next = 16;
              return value.inverted;

            case 16:
              i++;
              _context9.next = 1;
              break;

            case 19:
            case "end":
              return _context9.stop();
          }
        }
      }, _yieldKeyAndAllQs);
    })
  }]);

  return Cache;
}();

var cache = Cache$2;

var Cache$1 = cache;
/**
 * Represents a query or a set of queries used to perform a mutation in a batch.
 * @alias module:mapping~ModelBatchItem
 */

var ModelBatchItem$1 = /*#__PURE__*/function () {
  /**
   * @param {Object} doc
   * @param {Object} docInfo
   * @param {MappingHandler} handler
   * @param {Tree} cache
   */
  function ModelBatchItem(doc, docInfo, handler, cache) {
    _classCallCheck(this, ModelBatchItem);

    this.doc = doc;
    this.docInfo = docInfo;
    this.handler = handler;
    this.cache = cache;
  }
  /**
   * @ignore
   * @returns <Promise<Array>>
   */


  _createClass(ModelBatchItem, [{
    key: "getQueries",
    value: function getQueries() {
      var docKeys = Object.keys(this.doc);
      var cacheItem = this.cache.getOrCreate(this.getCacheKey(docKeys), function () {
        return {
          queries: null
        };
      });

      if (cacheItem.queries === null) {
        cacheItem.queries = this.createQueries(docKeys);
      }

      return cacheItem.queries;
    }
    /**
     * Gets the cache key for this item.
     * @abstract
     * @param {Array} docKeys
     * @returns {Iterator}
     */

  }, {
    key: "getCacheKey",
    value: function getCacheKey(docKeys) {
      throw new Error('getCacheKey must be implemented');
    }
    /**
     * Gets the Promise to create the queries.
     * @abstract
     * @param {Array} docKeys
     * @returns {Promise<Array>}
     */

  }, {
    key: "createQueries",
    value: function createQueries(docKeys) {
      throw new Error('getCacheKey must be implemented');
    }
    /**
     * Pushes the queries and parameters represented by this instance to the provided array.
     * @internal
     * @ignore
     * @param {Array} arr
     * @return {Promise<{isIdempotent, isCounter}>}
     */

  }, {
    key: "pushQueries",
    value: function pushQueries(arr) {
      var _this = this;

      var isIdempotent = true;
      var isCounter;
      return this.getQueries().then(function (queries) {
        queries.forEach(function (q) {
          // It's idempotent if all the queries contained are idempotent
          isIdempotent = isIdempotent && q.isIdempotent; // Either all queries are counter mutation or we let it fail at server level

          isCounter = q.isCounter;
          arr.push({
            query: q.query,
            params: q.paramsGetter(_this.doc, _this.docInfo, _this.getMappingInfo())
          });
        });
        return {
          isIdempotent: isIdempotent,
          isCounter: isCounter
        };
      });
    }
    /**
     * Gets the mapping information for this batch item.
     * @internal
     * @ignore
     */

  }, {
    key: "getMappingInfo",
    value: function getMappingInfo() {
      return this.handler.info;
    }
  }]);

  return ModelBatchItem;
}();
/**
 * Represents a single or a set of INSERT queries in a batch.
 * @ignore
 * @internal
 */


var InsertModelBatchItem$1 = /*#__PURE__*/function (_ModelBatchItem) {
  _inherits(InsertModelBatchItem, _ModelBatchItem);

  var _super = _createSuper(InsertModelBatchItem);

  /**
   * @param {Object} doc
   * @param {Object} docInfo
   * @param {MappingHandler} handler
   * @param {Tree} cache
   */
  function InsertModelBatchItem(doc, docInfo, handler, cache) {
    _classCallCheck(this, InsertModelBatchItem);

    return _super.call(this, doc, docInfo, handler, cache);
  }
  /** @override */


  _createClass(InsertModelBatchItem, [{
    key: "getCacheKey",
    value: function getCacheKey(docKeys) {
      return Cache$1.getInsertKey(docKeys, this.docInfo);
    }
    /** @override */

  }, {
    key: "createQueries",
    value: function createQueries(docKeys) {
      return this.handler.createInsertQueries(docKeys, this.doc, this.docInfo);
    }
  }]);

  return InsertModelBatchItem;
}(ModelBatchItem$1);
/**
 * Represents a single or a set of UPDATE queries in a batch.
 * @ignore
 * @internal
 */


var UpdateModelBatchItem$1 = /*#__PURE__*/function (_ModelBatchItem2) {
  _inherits(UpdateModelBatchItem, _ModelBatchItem2);

  var _super2 = _createSuper(UpdateModelBatchItem);

  /**
   * @param {Object} doc
   * @param {Object} docInfo
   * @param {MappingHandler} handler
   * @param {Tree} cache
   */
  function UpdateModelBatchItem(doc, docInfo, handler, cache) {
    _classCallCheck(this, UpdateModelBatchItem);

    return _super2.call(this, doc, docInfo, handler, cache);
  }
  /** @override */


  _createClass(UpdateModelBatchItem, [{
    key: "getCacheKey",
    value: function getCacheKey(docKeys) {
      return Cache$1.getUpdateKey(docKeys, this.doc, this.docInfo);
    }
    /** @override */

  }, {
    key: "createQueries",
    value: function createQueries(docKeys) {
      return this.handler.createUpdateQueries(docKeys, this.doc, this.docInfo);
    }
  }]);

  return UpdateModelBatchItem;
}(ModelBatchItem$1);
/**
 * Represents a single or a set of DELETE queries in a batch.
 * @ignore
 * @internal
 */


var RemoveModelBatchItem$1 = /*#__PURE__*/function (_ModelBatchItem3) {
  _inherits(RemoveModelBatchItem, _ModelBatchItem3);

  var _super3 = _createSuper(RemoveModelBatchItem);

  /**
   * @param {Object} doc
   * @param {Object} docInfo
   * @param {MappingHandler} handler
   * @param {Tree} cache
   */
  function RemoveModelBatchItem(doc, docInfo, handler, cache) {
    _classCallCheck(this, RemoveModelBatchItem);

    return _super3.call(this, doc, docInfo, handler, cache);
  }
  /** @override */


  _createClass(RemoveModelBatchItem, [{
    key: "getCacheKey",
    value: function getCacheKey(docKeys) {
      return Cache$1.getRemoveKey(docKeys, this.doc, this.docInfo);
    }
    /** @override */

  }, {
    key: "createQueries",
    value: function createQueries(docKeys) {
      return this.handler.createDeleteQueries(docKeys, this.doc, this.docInfo);
    }
  }]);

  return RemoveModelBatchItem;
}(ModelBatchItem$1);

var modelBatchItem = {
  ModelBatchItem: ModelBatchItem$1,
  InsertModelBatchItem: InsertModelBatchItem$1,
  UpdateModelBatchItem: UpdateModelBatchItem$1,
  RemoveModelBatchItem: RemoveModelBatchItem$1
};

var Tree$1 = tree;
var moduleBatchItemModule = modelBatchItem;
var InsertModelBatchItem = moduleBatchItemModule.InsertModelBatchItem;
var UpdateModelBatchItem = moduleBatchItemModule.UpdateModelBatchItem;
var RemoveModelBatchItem = moduleBatchItemModule.RemoveModelBatchItem;
/**
 * Provides utility methods to group multiple mutations on a single batch.
 * @alias module:mapping~ModelBatchMapper
 */

var ModelBatchMapper$1 = /*#__PURE__*/function () {
  /**
   * Creates a new instance of model batch mapper.
   * <p>
   *   An instance of this class is exposed as a singleton in the <code>batching</code> field of the
   *   [ModelMapper]{@link module:mapping~ModelMapper}. Note that new instances should not be create with this
   *   constructor.
   * </p>
   * @param {MappingHandler} handler
   * @ignore
   */
  function ModelBatchMapper(handler) {
    _classCallCheck(this, ModelBatchMapper);

    this._handler = handler;
    this._cache = {
      insert: new Tree$1(),
      update: new Tree$1(),
      remove: new Tree$1()
    };
  }
  /**
   * Gets a [ModelBatchItem]{@link module:mapping~ModelBatchItem} containing the queries for the INSERT mutation to be
   * used in a batch execution.
   * @param {Object} doc An object containing the properties to insert.
   * @param {Object} [docInfo] An object containing the additional document information.
   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
   * INSERT cql statements generated. If specified, it must include the columns to insert and the primary keys.
   * @param {Number} [docInfo.ttl] Specifies an optional Time To Live (in seconds) for the inserted values.
   * @param {Boolean} [docInfo.ifNotExists] When set, it only inserts if the row does not exist prior to the insertion.
   * <p>Please note that using IF NOT EXISTS will incur a non negligible performance cost so this should be used
   * sparingly.</p>
   * @returns {ModelBatchItem} A [ModelBatchItem]{@link module:mapping~ModelBatchItem} instance representing a query
   * or a set of queries to be included in a batch.
   */


  _createClass(ModelBatchMapper, [{
    key: "insert",
    value: function insert(doc, docInfo) {
      return new InsertModelBatchItem(doc, docInfo, this._handler, this._cache.insert);
    }
    /**
     * Gets a [ModelBatchItem]{@link module:mapping~ModelBatchItem} containing the queries for the UPDATE mutation to be
     * used in a batch execution.
     * @param {Object} doc An object containing the properties to update.
     * @param {Object} [docInfo] An object containing the additional document information.
     * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
     * UPDATE cql statements generated. If specified, it must include the columns to update and the primary keys.
     * @param {Number} [docInfo.ttl] Specifies an optional Time To Live (in seconds) for the inserted values.
     * @param {Boolean} [docInfo.ifExists] When set, it only updates if the row already exists on the server.
     * <p>
     *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
     *   should be used sparingly.
     * </p>
     * @param {Object} [docInfo.when] A document that act as the condition that has to be met for the UPDATE to occur.
     * Use this property only in the case you want to specify a conditional clause for lightweight transactions (CAS).
     * <p>
     *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
     *   should be used sparingly.
     * </p>
     * @returns {ModelBatchItem} A [ModelBatchItem]{@link module:mapping~ModelBatchItem} instance representing a query
     * or a set of queries to be included in a batch.
     */

  }, {
    key: "update",
    value: function update(doc, docInfo) {
      return new UpdateModelBatchItem(doc, docInfo, this._handler, this._cache.update);
    }
    /**
     * Gets a [ModelBatchItem]{@link module:mapping~ModelBatchItem}  containing the queries for the DELETE mutation to be
     * used in a batch execution.
     * @param {Object} doc A document containing the primary keys values of the document to delete.
     * @param {Object} [docInfo] An object containing the additional doc information.
     * @param {Object} [docInfo.when] A document that act as the condition that has to be met for the DELETE to occur.
     * Use this property only in the case you want to specify a conditional clause for lightweight transactions (CAS).
     * When the CQL query is generated, this would be used to generate the `IF` clause.
     * <p>
     *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
     *   should be used sparingly.
     * </p>
     * @param {Boolean} [docInfo.ifExists] When set, it only issues the DELETE command if the row already exists on the
     * server.
     * <p>
     *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
     *   should be used sparingly.
     * </p>
     * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
     * DELETE cql statement generated. If specified, it must include the columns to delete and the primary keys.
     * @param {Boolean} [docInfo.deleteOnlyColumns] Determines that, when more document properties are specified
     * besides the primary keys, the generated DELETE statement should be used to delete some column values but leave
     * the row. When this is enabled and more properties are specified, a DELETE statement will have the following form:
     * "DELETE col1, col2 FROM table1 WHERE pk1 = ? AND pk2 = ?"
     * @returns {ModelBatchItem} A [ModelBatchItem]{@link module:mapping~ModelBatchItem} instance representing a query
     * or a set of queries to be included in a batch.
     */

  }, {
    key: "remove",
    value: function remove(doc, docInfo) {
      return new RemoveModelBatchItem(doc, docInfo, this._handler, this._cache.update);
    }
  }]);

  return ModelBatchMapper;
}();

var modelBatchMapper = ModelBatchMapper$1;

var ModelBatchMapper = modelBatchMapper;
/**
 * Represents an object mapper for a specific model.
 * @alias module:mapping~ModelMapper
 */

var ModelMapper$1 = /*#__PURE__*/function () {
  function ModelMapper(name, handler) {
    _classCallCheck(this, ModelMapper);

    /**
     * Gets the name identifier of the model.
     * @type {String}
     */
    this.name = name;
    this._handler = handler;
    /**
     * Gets a [ModelBatchMapper]{@link module:mapping~ModelBatchMapper} instance containing utility methods to group
     * multiple doc mutations in a single batch.
     * @type {ModelBatchMapper}
     */

    this.batching = new ModelBatchMapper(this._handler);
  }
  /**
   * Gets the first document matching the provided filter or null when not found.
   * <p>
   *   Note that all partition and clustering keys must be defined in order to use this method.
   * </p>
   * @param {Object} doc The object containing the properties that map to the primary keys.
   * @param {Object} [docInfo] An object containing the additional document information.
   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
   * SELECT cql statement generated, in order to restrict the amount of columns retrieved.
   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
   * execution or a string representing the name of the execution profile.
   * @param {String} [executionOptions.executionProfile] The name of the execution profile.
   * @return {Promise<Object>}
   * @example <caption>Get a video by id</caption>
   * videoMapper.get({ id })
   * @example <caption>Get a video by id, selecting specific columns</caption>
   * videoMapper.get({ id }, fields: ['name', 'description'])
   */


  _createClass(ModelMapper, [{
    key: "get",
    value: function get(doc, docInfo, executionOptions) {
      if (executionOptions === undefined && typeof docInfo === 'string') {
        executionOptions = docInfo;
        docInfo = null;
      }

      return this._handler.getSelectExecutor(doc, docInfo, true).then(function (executor) {
        return executor(doc, docInfo, executionOptions);
      }).then(function (result) {
        return result.first();
      });
    }
    /**
     * Executes a SELECT query based on the filter and returns the result as an iterable of documents.
     * @param {Object} doc An object containing the properties that map to the primary keys to filter.
     * @param {Object} [docInfo] An object containing the additional document information.
     * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
     * SELECT cql statement generated, in order to restrict the amount of columns retrieved.
     * @param {Object<String, String>} [docInfo.orderBy] An associative array containing the column names as key and
     * the order string (asc or desc) as value used to set the order of the results server-side.
     * @param {Number} [docInfo.limit] Restricts the result of the query to a maximum number of rows on the
     * server.
     * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
     * execution or a string representing the name of the execution profile.
     * @param {String} [executionOptions.executionProfile] The name of the execution profile.
     * @param {Number} [executionOptions.fetchSize] The amount of rows to retrieve per page.
     * @param {Number} [executionOptions.pageState] A Buffer instance or a string token representing the paging state.
     * <p>When provided, the query will be executed starting from a given paging state.</p>
     * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.
     * @example <caption>Get user's videos</caption>
     * const result = await videoMapper.find({ userId });
     * for (let video of result) {
     *   console.log(video.name);
     * }
     * @example <caption>Get user's videos from a certain date</caption>
     * videoMapper.find({ userId, addedDate: q.gte(date)});
     * @example <caption>Get user's videos in reverse order</caption>
     * videoMapper.find({ userId }, { orderBy: { addedDate: 'desc' }});
     */

  }, {
    key: "find",
    value: function find(doc, docInfo, executionOptions) {
      if (executionOptions === undefined && typeof docInfo === 'string') {
        executionOptions = docInfo;
        docInfo = null;
      }

      return this._handler.getSelectExecutor(doc, docInfo, false).then(function (executor) {
        return executor(doc, docInfo, executionOptions);
      });
    }
    /**
     * Executes a SELECT query without a filter and returns the result as an iterable of documents.
     * <p>
     *   This is only recommended to be used for tables with a limited amount of results. Otherwise, breaking up the
     *   token ranges on the client side should be used.
     * </p>
     * @param {Object} [docInfo] An object containing the additional document information.
     * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
     * SELECT cql statement generated, in order to restrict the amount of columns retrieved.
     * @param {Object<String, String>} [docInfo.orderBy] An associative array containing the column names as key and
     * the order string (asc or desc) as value used to set the order of the results server-side.
     * @param {Number} [docInfo.limit] Restricts the result of the query to a maximum number of rows on the
     * server.
     * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
     * execution or a string representing the name of the execution profile.
     * @param {String} [executionOptions.executionProfile] The name of the execution profile.
     * @param {Number} [executionOptions.fetchSize] The mount of rows to retrieve per page.
     * @param {Number} [executionOptions.pageState] A Buffer instance or a string token representing the paging state.
     * <p>When provided, the query will be executed starting from a given paging state.</p>
     * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.
     */

  }, {
    key: "findAll",
    value: function findAll(docInfo, executionOptions) {
      if (executionOptions === undefined && typeof docInfo === 'string') {
        executionOptions = docInfo;
        docInfo = null;
      }

      var executor = this._handler.getSelectAllExecutor(docInfo);

      return executor(docInfo, executionOptions);
    }
    /**
     * Inserts a document.
     * <p>
     *   When the model is mapped to multiple tables, it will insert a row in each table when all the primary keys
     *   are specified.
     * </p>
     * @param {Object} doc An object containing the properties to insert.
     * @param {Object} [docInfo] An object containing the additional document information.
     * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
     * INSERT cql statements generated. If specified, it must include the columns to insert and the primary keys.
     * @param {Number} [docInfo.ttl] Specifies an optional Time To Live (in seconds) for the inserted values.
     * @param {Boolean} [docInfo.ifNotExists] When set, it only inserts if the row does not exist prior to the insertion.
     * <p>Please note that using IF NOT EXISTS will incur a non negligible performance cost so this should be used
     * sparingly.</p>
     * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
     * execution or a string representing the name of the execution profile.
     * @param {String} [executionOptions.executionProfile] The name of the execution profile.
     * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times without
     * changing the result beyond the initial application.
     * <p>
     *   By default all generated INSERT statements are considered idempotent, except in the case of lightweight
     *   transactions. Lightweight transactions at client level with transparent retries can
     *   break linearizability. If that is not an issue for your application, you can manually set this field to true.
     * </p>
     * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the
     * unix epoch (00:00:00, January 1st, 1970).
     * <p>When provided, this will replace the client generated and the server side assigned timestamp.</p>
     * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.
     * @example <caption>Insert a video</caption>
     * videoMapper.insert({ id, name });
     */

  }, {
    key: "insert",
    value: function insert(doc, docInfo, executionOptions) {
      if (executionOptions === undefined && typeof docInfo === 'string') {
        executionOptions = docInfo;
        docInfo = null;
      }

      return this._handler.getInsertExecutor(doc, docInfo).then(function (executor) {
        return executor(doc, docInfo, executionOptions);
      });
    }
    /**
     * Updates a document.
     * <p>
     *   When the model is mapped to multiple tables, it will update a row in each table when all the primary keys
     *   are specified.
     * </p>
     * @param {Object} doc An object containing the properties to update.
     * @param {Object} [docInfo] An object containing the additional document information.
     * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
     * UPDATE cql statements generated. If specified, it must include the columns to update and the primary keys.
     * @param {Number} [docInfo.ttl] Specifies an optional Time To Live (in seconds) for the inserted values.
     * @param {Boolean} [docInfo.ifExists] When set, it only updates if the row already exists on the server.
     * <p>
     *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
     *   should be used sparingly.
     * </p>
     * @param {Object} [docInfo.when] A document that act as the condition that has to be met for the UPDATE to occur.
     * Use this property only in the case you want to specify a conditional clause for lightweight transactions (CAS).
     * <p>
     *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
     *   should be used sparingly.
     * </p>
     * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
     * execution or a string representing the name of the execution profile.
     * @param {String} [executionOptions.executionProfile] The name of the execution profile.
     * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times without
     * changing the result beyond the initial application.
     * <p>
     *   The mapper uses the generated queries to determine the default value. When an UPDATE is generated with a
     *   counter column or appending/prepending to a list column, the execution is marked as not idempotent.
     * </p>
     * <p>
     *   Additionally, the mapper uses the safest approach for queries with lightweight transactions (Compare and
     *   Set) by considering them as non-idempotent. Lightweight transactions at client level with transparent retries can
     *   break linearizability. If that is not an issue for your application, you can manually set this field to true.
     * </p>
     * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the
     * unix epoch (00:00:00, January 1st, 1970).
     * <p>When provided, this will replace the client generated and the server side assigned timestamp.</p>
     * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.
     * @example <caption>Update the name of a video</caption>
     * videoMapper.update({ id, name });
     */

  }, {
    key: "update",
    value: function update(doc, docInfo, executionOptions) {
      if (executionOptions === undefined && typeof docInfo === 'string') {
        executionOptions = docInfo;
        docInfo = null;
      }

      return this._handler.getUpdateExecutor(doc, docInfo).then(function (executor) {
        return executor(doc, docInfo, executionOptions);
      });
    }
    /**
     * Deletes a document.
     * @param {Object} doc A document containing the primary keys values of the document to delete.
     * @param {Object} [docInfo] An object containing the additional doc information.
     * @param {Object} [docInfo.when] A document that act as the condition that has to be met for the DELETE to occur.
     * Use this property only in the case you want to specify a conditional clause for lightweight transactions (CAS).
     * When the CQL query is generated, this would be used to generate the `IF` clause.
     * <p>
     *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
     *   should be used sparingly.
     * </p>
     * @param {Boolean} [docInfo.ifExists] When set, it only issues the DELETE command if the row already exists on the
     * server.
     * <p>
     *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this
     *   should be used sparingly.
     * </p>
     * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the
     * DELETE cql statement generated. If specified, it must include the columns to delete and the primary keys.
     * @param {Boolean} [docInfo.deleteOnlyColumns] Determines that, when more document properties are specified
     * besides the primary keys, the generated DELETE statement should be used to delete some column values but leave
     * the row. When this is enabled and more properties are specified, a DELETE statement will have the following form:
     * "DELETE col1, col2 FROM table1 WHERE pk1 = ? AND pk2 = ?"
     * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
     * execution or a string representing the name of the execution profile.
     * @param {String} [executionOptions.executionProfile] The name of the execution profile.
     * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times without
     * changing the result beyond the initial application.
     * <p>
     *   By default all generated DELETE statements are considered idempotent, except in the case of lightweight
     *   transactions. Lightweight transactions at client level with transparent retries can
     *   break linearizability. If that is not an issue for your application, you can manually set this field to true.
     * </p>
     * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the
     * unix epoch (00:00:00, January 1st, 1970).
     * <p>When provided, this will replace the client generated and the server side assigned timestamp.</p>
     * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.
     * @example <caption>Delete a video</caption>
     * videoMapper.remove({ id });
     */

  }, {
    key: "remove",
    value: function remove(doc, docInfo, executionOptions) {
      if (executionOptions === undefined && typeof docInfo === 'string') {
        executionOptions = docInfo;
        docInfo = null;
      }

      return this._handler.getDeleteExecutor(doc, docInfo).then(function (executor) {
        return executor(doc, docInfo, executionOptions);
      });
    }
    /**
     * Uses the provided query and param getter function to execute a query and map the results.
     * Gets a function that takes the document, executes the query and returns the mapped results.
     * @param {String} query The query to execute.
     * @param {Function} paramsHandler The function to execute to extract the parameters of a document.
     * @param {Object|String} [executionOptions] When provided, the options for all executions generated with this
     * method will use the provided options and it will not consider the executionOptions per call.
     * @param {String} [executionOptions.executionProfile] The name of the execution profile.
     * @param {Number} [executionOptions.fetchSize] Amount of rows to retrieve per page.
     * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times
     * without changing the result beyond the initial application.
     * @param {Number} [executionOptions.pageState] Buffer or string token representing the paging state.
     * <p>When provided, the query will be executed starting from a given paging state.</p>
     * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the
     * unix epoch (00:00:00, January 1st, 1970).
     * <p>When provided, this will replace the client generated and the server side assigned timestamp.</p>
     * @return {Function} Returns a function that takes the document and execution options as parameters and returns a
     * Promise the resolves to a [Result]{@link module:mapping~Result} instance.
     */

  }, {
    key: "mapWithQuery",
    value: function mapWithQuery(query, paramsHandler, executionOptions) {
      return this._handler.getExecutorFromQuery(query, paramsHandler, executionOptions);
    }
  }]);

  return ModelMapper;
}();

var modelMapper = ModelMapper$1;

var vm$1 = require$$0__default$a["default"];
var qModule = q$1;
var QueryOperator = qModule.QueryOperator;
var QueryAssignment = qModule.QueryAssignment;
var types$1 = types$u;
var dataTypes = types$1.dataTypes;
var vmFileName = 'gen-param-getter.js';
/**
 * Provides methods to generate a query and parameter handlers.
 * @ignore
 */

var QueryGenerator$1 = /*#__PURE__*/function () {
  function QueryGenerator() {
    _classCallCheck(this, QueryGenerator);
  }

  _createClass(QueryGenerator, null, [{
    key: "getSelect",
    value:
    /**
     * Gets the SELECT query given the doc.
     * @param {String} tableName
     * @param {String} keyspace
     * @param {Array} propertiesInfo
     * @param {Array} fieldsInfo
     * @param {Array} orderByColumns
     * @param {Number|undefined} limit
     * @return {string}
     */
    function getSelect(tableName, keyspace, propertiesInfo, fieldsInfo, orderByColumns, limit) {
      var query = 'SELECT ';
      query += fieldsInfo.length > 0 ? fieldsInfo.map(function (p) {
        return p.columnName;
      }).join(', ') : '*';
      query += " FROM ".concat(keyspace, ".").concat(tableName);

      if (propertiesInfo.length > 0) {
        query += ' WHERE ';
        query += QueryGenerator._getConditionWithOperators(propertiesInfo);
      }

      if (orderByColumns.length > 0) {
        query += ' ORDER BY ';
        query += orderByColumns.map(function (order) {
          return order[0] + ' ' + order[1];
        }).join(', ');
      }

      if (typeof limit === 'number') {
        query += ' LIMIT ?';
      }

      return query;
    }
  }, {
    key: "selectParamsGetter",
    value: function selectParamsGetter(propertiesInfo, limit) {
      var scriptText = '(function getParametersSelect(doc, docInfo, mappingInfo) {\n';
      scriptText += '  return [';
      scriptText += QueryGenerator._valueGetterExpression(propertiesInfo);

      if (typeof limit === 'number') {
        if (propertiesInfo.length > 0) {
          scriptText += ', ';
        }

        scriptText += "docInfo['limit']";
      } // Finish return statement


      scriptText += '];\n})';
      var script = new vm$1.Script(scriptText, {
        filename: vmFileName
      });
      return script.runInThisContext();
    }
    /**
     * Gets the INSERT query and function to obtain the parameters, given the doc.
     * @param {TableMetadata} table
     * @param {String} keyspace
     * @param {Array} propertiesInfo
     * @param {Object} docInfo
     * @param {Boolean|undefined} ifNotExists
     * @return {{query: String, paramsGetter: Function, isIdempotent: Boolean}}
     */

  }, {
    key: "getInsert",
    value: function getInsert(table, keyspace, propertiesInfo, docInfo, ifNotExists) {
      var ttl = docInfo && docInfo.ttl; // Not all columns are contained in the table

      var filteredPropertiesInfo = propertiesInfo.filter(function (pInfo) {
        return table.columnsByName[pInfo.columnName] !== undefined;
      });
      return {
        query: QueryGenerator._getInsertQuery(table.name, keyspace, filteredPropertiesInfo, ifNotExists, ttl),
        paramsGetter: QueryGenerator._insertParamsGetter(filteredPropertiesInfo, docInfo),
        isIdempotent: !ifNotExists
      };
    }
    /**
     * Gets the query for an insert statement.
     * @param {String} tableName
     * @param {String} keyspace
     * @param {Array} propertiesInfo
     * @param {Boolean} ifNotExists
     * @param {Number|undefined} ttl
     * @return {String}
     */

  }, {
    key: "_getInsertQuery",
    value: function _getInsertQuery(tableName, keyspace, propertiesInfo, ifNotExists, ttl) {
      var query = "INSERT INTO ".concat(keyspace, ".").concat(tableName, " (");
      query += propertiesInfo.map(function (pInfo) {
        return pInfo.columnName;
      }).join(', ');
      query += ') VALUES (';
      query += propertiesInfo.map(function () {
        return '?';
      }).join(', ');
      query += ')';

      if (ifNotExists === true) {
        query += ' IF NOT EXISTS';
      }

      if (typeof ttl === 'number') {
        query += ' USING TTL ?';
      }

      return query;
    }
  }, {
    key: "_insertParamsGetter",
    value: function _insertParamsGetter(propertiesInfo, docInfo) {
      var scriptText = '(function getParametersInsert(doc, docInfo, mappingInfo) {\n';
      scriptText += '  return [';
      scriptText += QueryGenerator._valueGetterExpression(propertiesInfo);

      if (docInfo && typeof docInfo.ttl === 'number') {
        scriptText += ", docInfo['ttl']";
      } // Finish return statement


      scriptText += '];\n})';
      var script = new vm$1.Script(scriptText, {
        filename: vmFileName
      });
      return script.runInThisContext();
    }
    /**
     * Gets the UPDATE query and function to obtain the parameters, given the doc.
     * @param {TableMetadata} table
     * @param {String} keyspace
     * @param {Array} propertiesInfo
     * @param {Object} docInfo
     * @param {Array} when
     * @param {Boolean|undefined} ifExists
     * @return {{query: String, paramsGetter: Function, isIdempotent: Boolean, isCounter}}
     */

  }, {
    key: "getUpdate",
    value: function getUpdate(table, keyspace, propertiesInfo, docInfo, when, ifExists) {
      var ttl = docInfo && docInfo.ttl;
      var primaryKeys = new Set(table.partitionKeys.concat(table.clusteringKeys).map(function (c) {
        return c.name;
      }));
      var isIdempotent = true;
      var isCounter = false; // Not all columns are contained in the table

      var filteredPropertiesInfo = propertiesInfo.filter(function (pInfo) {
        var column = table.columnsByName[pInfo.columnName];

        if (column === undefined) {
          return false;
        }

        if (column.type.code === dataTypes.list && pInfo.value instanceof QueryAssignment) {
          // Its not idempotent when list append/prepend
          isIdempotent = false;
        } else if (column.type.code === dataTypes.counter) {
          // Any update on a counter table is not idempotent
          isIdempotent = false;
          isCounter = true;
        }

        return true;
      });
      return {
        query: QueryGenerator._getUpdateQuery(table.name, keyspace, primaryKeys, filteredPropertiesInfo, when, ifExists, ttl),
        isIdempotent: isIdempotent && when.length === 0 && !ifExists,
        paramsGetter: QueryGenerator._updateParamsGetter(primaryKeys, filteredPropertiesInfo, when, ttl),
        isCounter: isCounter
      };
    }
    /**
     * Gets the query for an UPDATE statement.
     * @param {String} tableName
     * @param {String} keyspace
     * @param {Set} primaryKeys
     * @param {Array} propertiesInfo
     * @param {Object} when
     * @param {Boolean} ifExists
     * @param {Number|undefined} ttl
     */

  }, {
    key: "_getUpdateQuery",
    value: function _getUpdateQuery(tableName, keyspace, primaryKeys, propertiesInfo, when, ifExists, ttl) {
      var query = "UPDATE ".concat(keyspace, ".").concat(tableName, " ");

      if (typeof ttl === 'number') {
        query += 'USING TTL ? ';
      }

      query += 'SET ';
      query += propertiesInfo.filter(function (p) {
        return !primaryKeys.has(p.columnName);
      }).map(function (p) {
        if (p.value instanceof QueryAssignment) {
          if (p.value.inverted) {
            // e.g: prepend "col1 = ? + col1"
            return "".concat(p.columnName, " = ? ").concat(p.value.sign, " ").concat(p.columnName);
          } // e.g: increment "col1 = col1 + ?"


          return "".concat(p.columnName, " = ").concat(p.columnName, " ").concat(p.value.sign, " ?");
        }

        return p.columnName + ' = ?';
      }).join(', ');
      query += ' WHERE ';
      query += propertiesInfo.filter(function (p) {
        return primaryKeys.has(p.columnName);
      }).map(function (p) {
        return p.columnName + ' = ?';
      }).join(' AND ');

      if (ifExists === true) {
        query += ' IF EXISTS';
      } else if (when.length > 0) {
        query += ' IF ' + QueryGenerator._getConditionWithOperators(when);
      }

      return query;
    }
    /**
     * Returns a function to obtain the parameter values from a doc for an UPDATE statement.
     * @param {Set} primaryKeys
     * @param {Array} propertiesInfo
     * @param {Array} when
     * @param {Number|undefined} ttl
     * @returns {Function}
     */

  }, {
    key: "_updateParamsGetter",
    value: function _updateParamsGetter(primaryKeys, propertiesInfo, when, ttl) {
      var scriptText = '(function getParametersUpdate(doc, docInfo, mappingInfo) {\n';
      scriptText += '  return [';

      if (typeof ttl === 'number') {
        scriptText += "docInfo['ttl'], ";
      } // Assignment clause


      scriptText += QueryGenerator._assignmentGetterExpression(propertiesInfo.filter(function (p) {
        return !primaryKeys.has(p.columnName);
      }));
      scriptText += ', '; // Where clause

      scriptText += QueryGenerator._valueGetterExpression(propertiesInfo.filter(function (p) {
        return primaryKeys.has(p.columnName);
      })); // Condition clause

      if (when.length > 0) {
        scriptText += ', ' + QueryGenerator._valueGetterExpression(when, 'docInfo.when');
      } // Finish return statement


      scriptText += '];\n})';
      var script = new vm$1.Script(scriptText, {
        filename: vmFileName
      });
      return script.runInThisContext();
    }
    /**
     * Gets the DELETE query and function to obtain the parameters, given the doc.
     * @param {TableMetadata} table
     * @param {String} keyspace
     * @param {Array} propertiesInfo
     * @param {Object} docInfo
     * @param {Array} when
     * @param {Boolean|undefined} ifExists
     * @return {{query: String, paramsGetter: Function, isIdempotent}}
     */

  }, {
    key: "getDelete",
    value: function getDelete(table, keyspace, propertiesInfo, docInfo, when, ifExists) {
      var deleteOnlyColumns = docInfo && docInfo.deleteOnlyColumns;
      var primaryKeys = new Set(table.partitionKeys.concat(table.clusteringKeys).map(function (c) {
        return c.name;
      }));
      var filteredPropertiesInfo = propertiesInfo.filter(function (pInfo) {
        return table.columnsByName[pInfo.columnName] !== undefined;
      });
      return {
        query: QueryGenerator._getDeleteQuery(table.name, keyspace, primaryKeys, filteredPropertiesInfo, when, ifExists, deleteOnlyColumns),
        paramsGetter: QueryGenerator._deleteParamsGetter(primaryKeys, filteredPropertiesInfo, when),
        isIdempotent: when.length === 0 && !ifExists
      };
    }
    /**
     * Gets the query for an UPDATE statement.
     * @param {String} tableName
     * @param {String} keyspace
     * @param {Set} primaryKeys
     * @param {Array} propertiesInfo
     * @param {Array} when
     * @param {Boolean} ifExists
     * @param {Boolean} deleteOnlyColumns
     * @private
     * @return {String}
     */

  }, {
    key: "_getDeleteQuery",
    value: function _getDeleteQuery(tableName, keyspace, primaryKeys, propertiesInfo, when, ifExists, deleteOnlyColumns) {
      var query = 'DELETE';

      if (deleteOnlyColumns) {
        var columnsToDelete = propertiesInfo.filter(function (p) {
          return !primaryKeys.has(p.columnName);
        }).map(function (p) {
          return p.columnName;
        }).join(', ');

        if (columnsToDelete !== '') {
          query += ' ' + columnsToDelete;
        }
      }

      query += " FROM ".concat(keyspace, ".").concat(tableName, " WHERE ");
      query += propertiesInfo.filter(function (p) {
        return primaryKeys.has(p.columnName);
      }).map(function (p) {
        return p.columnName + ' = ?';
      }).join(' AND ');

      if (ifExists === true) {
        query += ' IF EXISTS';
      } else if (when.length > 0) {
        query += ' IF ' + QueryGenerator._getConditionWithOperators(when);
      }

      return query;
    }
    /**
     * Returns a function to obtain the parameter values from a doc for an UPDATE statement.
     * @param {Set} primaryKeys
     * @param {Array} propertiesInfo
     * @param {Array} when
     * @returns {Function}
     */

  }, {
    key: "_deleteParamsGetter",
    value: function _deleteParamsGetter(primaryKeys, propertiesInfo, when) {
      var scriptText = '(function getParametersDelete(doc, docInfo, mappingInfo) {\n';
      scriptText += '  return ['; // Where clause

      scriptText += QueryGenerator._valueGetterExpression(propertiesInfo.filter(function (p) {
        return primaryKeys.has(p.columnName);
      })); // Condition clause

      if (when.length > 0) {
        scriptText += ', ' + QueryGenerator._valueGetterExpression(when, 'docInfo.when');
      } // Finish return statement


      scriptText += '];\n})';
      var script = new vm$1.Script(scriptText, {
        filename: vmFileName
      });
      return script.runInThisContext();
    }
    /**
     * Gets a string containing the doc properties to get.
     * @param {Array} propertiesInfo
     * @param {String} [objectName='doc']
     * @return {string}
     * @private
     */

  }, {
    key: "_valueGetterExpression",
    value: function _valueGetterExpression(propertiesInfo, objectName) {
      objectName = objectName || 'doc';
      return propertiesInfo.map(function (p) {
        return QueryGenerator._valueGetterSingle("".concat(objectName, "['").concat(p.propertyName, "']"), p.propertyName, p.value, p.fromModel);
      }).join(', ');
    }
  }, {
    key: "_valueGetterSingle",
    value: function _valueGetterSingle(prefix, propName, value, fromModelFn) {
      var valueGetter = prefix;

      if (value instanceof QueryOperator) {
        if (value.hasChildValues) {
          return "".concat(QueryGenerator._valueGetterSingle("".concat(prefix, ".value[0]"), propName, value.value[0], fromModelFn)) + ", ".concat(QueryGenerator._valueGetterSingle("".concat(prefix, ".value[1]"), propName, value.value[1], fromModelFn));
        }

        valueGetter = "".concat(prefix, ".value");

        if (value.isInOperator && fromModelFn) {
          // Transform each individual value
          return "".concat(valueGetter, ".map(v => ").concat(QueryGenerator._getMappingFunctionCall(propName, 'v'), ")");
        }
      }

      return !fromModelFn ? valueGetter : QueryGenerator._getMappingFunctionCall(propName, valueGetter);
    }
    /**
     * Gets a string containing the doc properties to SET, considering QueryAssignment instances.
     * @param {Array} propertiesInfo
     * @param {String} [prefix='doc']
     * @return {string}
     * @private
     */

  }, {
    key: "_assignmentGetterExpression",
    value: function _assignmentGetterExpression(propertiesInfo, prefix) {
      prefix = prefix || 'doc';
      return propertiesInfo.map(function (p) {
        var valueGetter = "".concat(prefix, "['").concat(p.propertyName, "']").concat(p.value instanceof QueryAssignment ? '.value' : '');

        if (p.fromModel) {
          return QueryGenerator._getMappingFunctionCall(p.propertyName, valueGetter);
        }

        return valueGetter;
      }).join(', ');
    }
  }, {
    key: "_getConditionWithOperators",
    value: function _getConditionWithOperators(propertiesInfo) {
      return propertiesInfo.map(function (p) {
        return QueryGenerator._getSingleCondition(p.columnName, p.value);
      }).join(' AND ');
    }
  }, {
    key: "_getMappingFunctionCall",
    value: function _getMappingFunctionCall(propName, valueGetter) {
      return "mappingInfo.getFromModelFn('".concat(propName, "')(").concat(valueGetter, ")");
    }
  }, {
    key: "_getSingleCondition",
    value: function _getSingleCondition(columnName, value) {
      if (value instanceof QueryOperator) {
        if (value.hasChildValues) {
          return "".concat(QueryGenerator._getSingleCondition(columnName, value.value[0])) + " ".concat(value.key, " ").concat(QueryGenerator._getSingleCondition(columnName, value.value[1]));
        }

        return "".concat(columnName, " ").concat(value.key, " ?");
      }

      return "".concat(columnName, " = ?");
    }
  }]);

  return QueryGenerator;
}();

var queryGenerator = QueryGenerator$1;

var vm = require$$0__default$a["default"];
var utils$4 = utils$V;
var types = types$u;
/**
 * @ignore
 */

var ResultMapper$2 = /*#__PURE__*/function () {
  function ResultMapper() {
    _classCallCheck(this, ResultMapper);
  }

  _createClass(ResultMapper, null, [{
    key: "getSelectAdapter",
    value:
    /**
     * Gets a generated function to adapt the row to a document.
     * @param {ModelMappingInfo} info
     * @param {ResultSet} rs
     * @returns {Function}
     */
    function getSelectAdapter(info, rs) {
      var columns = rs.columns;

      if (!columns) {
        throw new Error('Expected ROWS result obtained VOID');
      }

      var scriptText = '(function rowAdapter(row, info) {\n' + '  const item = info.newInstance();\n';

      var _iterator = _createForOfIteratorHelper(columns),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var c = _step.value;
          scriptText += "  item['".concat(info.getPropertyName(c.name), "'] = ");

          if (!info.getToModelFn(c.name)) {
            scriptText += "row['".concat(c.name, "'];\n");
          } else {
            scriptText += "info.getToModelFn('".concat(c.name, "')(row['").concat(c.name, "']);\n");
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      scriptText += '  return item;\n})';
      var script = new vm.Script(scriptText, {
        filename: 'gen-result-mapper.js'
      });
      return script.runInThisContext();
    }
    /**
     * Gets a function used to adapt VOID results or conditional updates.
     * @param {ResultSet} rs
     * @returns {Function}
     */

  }, {
    key: "getMutationAdapter",
    value: function getMutationAdapter(rs) {
      if (rs.columns === null) {
        // VOID result
        return utils$4.noop;
      }

      if (rs.columns.length === 1 && rs.columns[0].name === '[applied]' && rs.columns[0].type.code === types.dataTypes["boolean"]) {
        return utils$4.noop;
      }

      return ResultMapper._getConditionalRowAdapter(rs);
    }
  }, {
    key: "_getConditionalRowAdapter",
    value: function _getConditionalRowAdapter(rs) {
      return function conditionalRowAdapter(row, info) {
        var item = info.newInstance(); // Skip the first column ("[applied]")

        for (var i = 1; i < rs.columns.length; i++) {
          var c = rs.columns[i];
          item[info.getPropertyName(c.name)] = row[c.name];
        }

        return item;
      };
    }
    /**
     * @param {ModelMappingInfo} info
     * @param {ResultSet} rs
     * @returns {{canCache: Boolean, fn: Function}}
     */

  }, {
    key: "getCustomQueryAdapter",
    value: function getCustomQueryAdapter(info, rs) {
      if (rs.columns === null || rs.columns.length === 0) {
        // VOID result
        return {
          canCache: true,
          fn: utils$4.noop
        };
      }

      if (rs.columns[0].name === '[applied]' && rs.columns[0].type.code === types.dataTypes["boolean"]) {
        // Conditional update results adapter functions should not be cached
        return {
          canCache: false,
          fn: ResultMapper._getConditionalRowAdapter(rs)
        };
      }

      return {
        canCache: true,
        fn: ResultMapper.getSelectAdapter(info, rs)
      };
    }
  }]);

  return ResultMapper;
}();

var resultMapper = ResultMapper$2;

var util = require$$0__default$1["default"];
var utils$3 = utils$V;
var inspectMethod = util.inspect.custom || 'inspect';
/**
 * Represents the result of an execution as an iterable of objects in the Mapper.
 * @alias module:mapping~Result
 */

var Result$2 = /*#__PURE__*/function (_Symbol$iterator) {
  /**
   * Creates a new instance of Result.
   * @param {ResultSet} rs
   * @param {ModelMappingInfo} info
   * @param {Function} rowAdapter
   */
  function Result(rs, info, rowAdapter) {
    _classCallCheck(this, Result);

    this._rs = rs;
    this._info = info;
    this._rowAdapter = rowAdapter;
    /**
     * When there is a single cell containing the result of the a LWT operation, hide the result from the user.
     * @private
     */

    this._isEmptyLwt = rs.columns !== null && rs.columns.length === 1 && this._rs.rowLength === 1 && rs.columns[0].name === '[applied]';
    /**
     * Gets the amount of the documents contained in this Result instance.
     * <p>
     *   When the results are paged, it returns the length of the current paged results not the total amount of
     *   rows in the table matching the query.
     * </p>
     * @type {Number}
     */

    this.length = this._isEmptyLwt ? 0 : rs.rowLength || 0;
    /**
     * A string token representing the current page state of query.
     * <p>
     *   When provided, it can be used in the following executions to continue paging and retrieve the remained of the
     *   result for the query.
     * </p>
     * @type {String}
     * @default null
     */

    this.pageState = rs.pageState;
  }
  /**
   * When this instance is the result of a conditional update query, it returns whether it was successful.
   * Otherwise, it returns <code>true</code>.
   * <p>
   *   For consistency, this method always returns <code>true</code> for non-conditional queries (although there is
   *   no reason to call the method in that case). This is also the case for conditional DDL statements
   *   (CREATE KEYSPACE... IF NOT EXISTS, CREATE TABLE... IF NOT EXISTS), for which the server doesn't return
   *   information whether it was applied or not.
   * </p>
   */


  _createClass(Result, [{
    key: "wasApplied",
    value: function wasApplied() {
      return this._rs.wasApplied();
    }
    /**
     * Gets the first document in this result or null when the result is empty.
     */

  }, {
    key: "first",
    value: function first() {
      if (!this._rs.rowLength || this._isEmptyLwt) {
        return null;
      }

      return this._rowAdapter(this._rs.rows[0], this._info);
    }
    /**
     * Returns a new Iterator object that contains the document values.
     */

  }, {
    key: _Symbol$iterator,
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function value() {
      var i;
      return regeneratorRuntime.wrap(function value$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this._isEmptyLwt) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              i = 0;

            case 3:
              if (!(i < this._rs.rows.length)) {
                _context.next = 9;
                break;
              }

              _context.next = 6;
              return this._rowAdapter(this._rs.rows[i], this._info);

            case 6:
              i++;
              _context.next = 3;
              break;

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, value, this);
    })
    /**
     * Converts the current instance to an Array of documents.
     * @return {Array<Object>}
     */

  }, {
    key: "toArray",
    value: function toArray() {
      var _this = this;

      if (this._isEmptyLwt || !this._rs.rows) {
        return utils$3.emptyArray;
      }

      return this._rs.rows.map(function (row) {
        return _this._rowAdapter(row, _this._info);
      });
    }
    /**
     * Executes a provided function once per result element.
     * @param {Function} callback Function to execute for each element, taking two arguments: currentValue and index.
     * @param {Object} [thisArg] Value to use as <code>this</code> when executing callback.
     */

  }, {
    key: "forEach",
    value: function forEach(callback, thisArg) {
      var index = 0;
      thisArg = thisArg || this;

      var _iterator = _createForOfIteratorHelper(this),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var doc = _step.value;
          callback.call(thisArg, doc, index++);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: inspectMethod,
    value: function value() {
      return this.toArray();
    }
  }]);

  return Result;
}(Symbol.iterator);

var result = Result$2;

var keyMatches = {
  all: 1,
  none: 0,
  some: -1
};
/**
 * Provides utility methods to choose the correct tables and views that should be included in a statement.
 * @ignore
 */

var ObjectSelector$1 = /*#__PURE__*/function () {
  function ObjectSelector() {
    _classCallCheck(this, ObjectSelector);
  }

  _createClass(ObjectSelector, null, [{
    key: "getForSelect",
    value:
    /**
     * Gets the table/view that should be used to execute the SELECT query.
     * @param {Client} client
     * @param {ModelMappingInfo} info
     * @param {Boolean} allPKsDefined
     * @param {Array} propertiesInfo
     * @param {Array} fieldsInfo
     * @param {Array<Array<String>>} orderByColumns
     * @return {Promise<String>} A promise that resolves to a table names.
     */
    function getForSelect(client, info, allPKsDefined, propertiesInfo, fieldsInfo, orderByColumns) {
      return Promise.all(info.tables.map(function (t) {
        if (t.isView) {
          return client.metadata.getMaterializedView(info.keyspace, t.name);
        }

        return client.metadata.getTable(info.keyspace, t.name);
      })).then(function (tables) {
        var _loop = function _loop(i) {
          var table = tables[i];

          if (table === null) {
            throw new Error("Table \"".concat(info.tables[i].name, "\" could not be retrieved"));
          }

          if (keysAreIncluded(table.partitionKeys, propertiesInfo) !== keyMatches.all) {
            // Not all the partition keys are covered
            return "continue";
          }

          if (allPKsDefined) {
            if (keysAreIncluded(table.clusteringKeys, propertiesInfo) !== keyMatches.all) {
              // All clustering keys should be included as allPKsDefined flag is set
              return "continue";
            }
          }

          if (propertiesInfo.length > table.partitionKeys.length) {
            // Check that the Where clause is composed by partition and clustering keys
            var allPropertiesArePrimaryKeys = propertiesInfo.reduce(function (acc, p) {
              return acc && (contains(table.partitionKeys, function (c) {
                return c.name === p.columnName;
              }) || contains(table.clusteringKeys, function (c) {
                return c.name === p.columnName;
              }));
            }, true);

            if (!allPropertiesArePrimaryKeys) {
              return "continue";
            }
          } // All fields must be contained


          var containsAllFields = fieldsInfo.reduce(function (acc, p) {
            return acc && table.columnsByName[p.columnName] !== undefined;
          }, true);

          if (!containsAllFields) {
            return "continue";
          } // CQL:
          // - "ORDER BY" is currently only supported on the clustered columns of the PRIMARY KEY
          // - "ORDER BY" currently only support the ordering of columns following their declared order in
          //   the PRIMARY KEY
          //
          // In the mapper, we validate that the ORDER BY columns appear in the same order as in the clustering keys


          var containsAllOrderByColumns = orderByColumns.reduce(function (acc, order, index) {
            if (!acc) {
              return false;
            }

            var ck = table.clusteringKeys[index];
            return ck && ck.name === order[0];
          }, true);

          if (!containsAllOrderByColumns) {
            return "continue";
          }

          return {
            v: table.name
          };
        };

        for (var i = 0; i < tables.length; i++) {
          var _ret = _loop(i);

          if (_ret === "continue") continue;
          if (_typeof(_ret) === "object") return _ret.v;
        }

        var message = "No table matches the filter (".concat(allPKsDefined ? 'all PKs have to be specified' : 'PKs', "): [").concat(propertiesInfo.map(function (p) {
          return p.columnName;
        }), "]");

        if (fieldsInfo.length > 0) {
          message += "; fields: [".concat(fieldsInfo.map(function (p) {
            return p.columnName;
          }), "]");
        }

        if (orderByColumns.length > 0) {
          message += "; orderBy: [".concat(orderByColumns.map(function (item) {
            return item[0];
          }), "]");
        }

        throw new Error(message);
      });
    }
    /** Returns the name of the first table */

  }, {
    key: "getForSelectAll",
    value: function getForSelectAll(info) {
      return info.tables[0].name;
    }
    /**
     * Gets the tables that should be used to execute the INSERT query.
     * @param {Client} client
     * @param {ModelMappingInfo} info
     * @param {Array} propertiesInfo
     * @return {Promise<Array<TableMetadata>>} A promise that resolves to an Array of tables.
     */

  }, {
    key: "getForInsert",
    value: function getForInsert(client, info, propertiesInfo) {
      return Promise.all(info.tables.filter(function (t) {
        return !t.isView;
      }).map(function (t) {
        return client.metadata.getTable(info.keyspace, t.name);
      })).then(function (tables) {
        var filteredTables = tables.filter(function (table, i) {
          if (table === null) {
            throw new Error("Table \"".concat(info.tables[i].name, "\" could not be retrieved"));
          }

          if (keysAreIncluded(table.partitionKeys, propertiesInfo) !== keyMatches.all) {
            // Not all the partition keys are covered
            return false;
          }

          var clusteringKeyMatches = keysAreIncluded(table.clusteringKeys, propertiesInfo); // All clustering keys should be included or it can be inserting a static column value

          if (clusteringKeyMatches === keyMatches.all) {
            return true;
          }

          if (clusteringKeyMatches === keyMatches.some) {
            return false;
          }

          var staticColumns = staticColumnCount(table);
          return propertiesInfo.length === table.partitionKeys.length + staticColumns && staticColumns > 0;
        });

        if (filteredTables.length === 0) {
          throw new Error("No table matches (all PKs have to be specified) fields: [".concat(propertiesInfo.map(function (p) {
            return p.columnName;
          }), "]"));
        }

        return filteredTables;
      });
    }
    /**
     * Gets the tables that should be used to execute the UPDATE query.
     * @param {Client} client
     * @param {ModelMappingInfo} info
     * @param {Array} propertiesInfo
     * @param {Array} when
     * @return {Promise<Array<TableMetadata>>} A promise that resolves to an Array of tables.
     */

  }, {
    key: "getForUpdate",
    value: function getForUpdate(client, info, propertiesInfo, when) {
      return Promise.all(info.tables.filter(function (t) {
        return !t.isView;
      }).map(function (t) {
        return client.metadata.getTable(info.keyspace, t.name);
      })).then(function (tables) {
        var filteredTables = tables.filter(function (table, i) {
          if (table === null) {
            throw new Error("Table \"".concat(info.tables[i].name, "\" could not be retrieved"));
          }

          if (keysAreIncluded(table.partitionKeys, propertiesInfo) !== keyMatches.all) {
            // Not all the partition keys are covered
            return false;
          }

          var clusteringKeyMatches = keysAreIncluded(table.clusteringKeys, propertiesInfo); // All clustering keys should be included or it can be updating a static column value

          if (clusteringKeyMatches === keyMatches.some) {
            return false;
          }

          if (clusteringKeyMatches === keyMatches.none && !hasStaticColumn(table)) {
            return false;
          }

          var applicableColumns = propertiesInfo.reduce(function (acc, p) {
            return acc + (table.columnsByName[p.columnName] !== undefined ? 1 : 0);
          }, 0);

          if (applicableColumns <= table.partitionKeys.length + table.clusteringKeys.length) {
            if (!hasStaticColumn(table) || applicableColumns <= table.partitionKeys.length) {
              // UPDATE statement does not contain columns to SET
              return false;
            }
          } // "when" conditions should be contained in the table


          return when.reduce(function (acc, p) {
            return acc && table.columnsByName[p.columnName] !== undefined;
          }, true);
        });

        if (filteredTables.length === 0) {
          var message = "No table matches (all PKs and columns to set have to be specified) fields: [".concat(propertiesInfo.map(function (p) {
            return p.columnName;
          }), "]");

          if (when.length > 0) {
            message += "; condition: [".concat(when.map(function (p) {
              return p.columnName;
            }), "]");
          }

          throw new Error(message);
        }

        return filteredTables;
      });
    }
    /**
     * Gets the tables that should be used to execute the DELETE query.
     * @param {Client} client
     * @param {ModelMappingInfo} info
     * @param {Array} propertiesInfo
     * @param {Array} when
     * @return {Promise<Array<TableMetadata>>} A promise that resolves to an Array of tables.
     */

  }, {
    key: "getForDelete",
    value: function getForDelete(client, info, propertiesInfo, when) {
      return Promise.all(info.tables.filter(function (t) {
        return !t.isView;
      }).map(function (t) {
        return client.metadata.getTable(info.keyspace, t.name);
      })).then(function (tables) {
        var filteredTables = tables.filter(function (table, i) {
          if (table === null) {
            throw new Error("Table \"".concat(info.tables[i].name, "\" could not be retrieved"));
          } // All partition and clustering keys from the table should be included in the document


          var keyNames = table.partitionKeys.concat(table.clusteringKeys).map(function (k) {
            return k.name;
          });
          var columns = propertiesInfo.map(function (p) {
            return p.columnName;
          });

          for (var _i = 0; _i < keyNames.length; _i++) {
            if (columns.indexOf(keyNames[_i]) === -1) {
              return false;
            }
          } // "when" conditions should be contained in the table


          return when.reduce(function (acc, p) {
            return acc && table.columnsByName[p.columnName] !== undefined;
          }, true);
        });

        if (filteredTables.length === 0) {
          var message = "No table matches (all PKs have to be specified) fields: [".concat(propertiesInfo.map(function (p) {
            return p.columnName;
          }), "]");

          if (when.length > 0) {
            message += "; condition: [".concat(when.map(function (p) {
              return p.columnName;
            }), "]");
          }

          throw new Error(message);
        }

        return filteredTables;
      });
    }
  }]);

  return ObjectSelector;
}();

function contains(arr, fn) {
  return arr.filter(fn).length > 0;
}
/**
 * Returns the amount of matches for a given key
 * @private
 * @param {Array} keys
 * @param {Array} propertiesInfo
 */


function keysAreIncluded(keys, propertiesInfo) {
  if (keys.length === 0) {
    return keyMatches.all;
  } // Filtering by name might look slow / ineffective to using hash maps
  // but we expect `keys` and `propertiesInfo` to contain only few items


  var matches = propertiesInfo.reduce(function (acc, p) {
    return acc + (contains(keys, function (k) {
      return p.columnName === k.name;
    }) ? 1 : 0);
  }, 0);

  if (matches === 0) {
    return keyMatches.none;
  }

  return matches === keys.length ? keyMatches.all : keyMatches.some;
}

function hasStaticColumn(table) {
  return staticColumnCount(table) > 0;
}

function staticColumnCount(table) {
  return table.columns.reduce(function (acc, column) {
    return acc + (column.isStatic ? 1 : 0);
  }, 0);
}

var objectSelector = ObjectSelector$1;

var errors$1 = errors$s;
var utils$2 = utils$V;
/**
 * Provides utility methods to adapt and map user provided docInfo and executionOptions to a predictable object format.
 * @ignore
 */

var DocInfoAdapter$2 = /*#__PURE__*/function () {
  function DocInfoAdapter() {
    _classCallCheck(this, DocInfoAdapter);
  }

  _createClass(DocInfoAdapter, null, [{
    key: "getPropertiesInfo",
    value:
    /**
     * Returns an Array where each item contains the property name, the column name and the property value (to obtain
     * the operator).
     * When docInfo.fields is specified, it uses that array to obtain the information.
     * @param {Array<String>} docKeys
     * @param {null|{fields}} docInfo
     * @param {Object} doc
     * @param {ModelMappingInfo} mappingInfo
     * @returns {Array}
     */
    function getPropertiesInfo(docKeys, docInfo, doc, mappingInfo) {
      var propertyKeys = docKeys;

      if (docInfo && docInfo.fields && docInfo.fields.length > 0) {
        propertyKeys = docInfo.fields;
      }

      return propertyKeys.map(function (propertyName) {
        return {
          propertyName: propertyName,
          columnName: mappingInfo.getColumnName(propertyName),
          value: doc[propertyName],
          fromModel: mappingInfo.getFromModelFn(propertyName)
        };
      });
    }
    /**
     * @param {{orderBy}} docInfo
     * @param {ModelMappingInfo} mappingInfo
     * @returns {Array<String>}
     */

  }, {
    key: "adaptOrderBy",
    value: function adaptOrderBy(docInfo, mappingInfo) {
      if (!docInfo || !docInfo.orderBy) {
        return utils$2.emptyArray;
      }

      return Object.keys(docInfo.orderBy).map(function (key) {
        var value = docInfo.orderBy[key];
        var ordering = typeof value === 'string' ? value.toUpperCase() : value;

        if (ordering !== 'ASC' && ordering !== 'DESC') {
          throw new errors$1.ArgumentError('Order must be either "ASC" or "DESC", obtained: ' + value);
        }

        return [mappingInfo.getColumnName(key), ordering];
      });
    }
    /**
     * Returns the QueryOptions for an INSERT/UPDATE/DELETE statement.
     * @param {Object|String|undefined} executionOptions
     * @param {Boolean} isIdempotent
     */

  }, {
    key: "adaptOptions",
    value: function adaptOptions(executionOptions, isIdempotent) {
      var options = {
        prepare: true,
        executionProfile: undefined,
        timestamp: undefined,
        isIdempotent: isIdempotent
      };

      if (typeof executionOptions === 'string') {
        options.executionProfile = executionOptions;
      } else if (executionOptions !== null && executionOptions !== undefined) {
        options.executionProfile = executionOptions.executionProfile;
        options.timestamp = executionOptions.timestamp;

        if (executionOptions.isIdempotent !== undefined) {
          options.isIdempotent = executionOptions.isIdempotent;
        }
      }

      return options;
    }
    /**
     * Returns the QueryOptions for a SELECT statement.
     * @param {Object|String|undefined} executionOptions
     * @param {Boolean} [overrideIdempotency]
     */

  }, {
    key: "adaptAllOptions",
    value: function adaptAllOptions(executionOptions, overrideIdempotency) {
      var options = {
        prepare: true,
        executionProfile: undefined,
        fetchSize: undefined,
        pageState: undefined,
        timestamp: undefined,
        isIdempotent: undefined
      };

      if (typeof executionOptions === 'string') {
        options.executionProfile = executionOptions;
      } else if (executionOptions !== null && executionOptions !== undefined) {
        options.executionProfile = executionOptions.executionProfile;
        options.fetchSize = executionOptions.fetchSize;
        options.pageState = executionOptions.pageState;
        options.timestamp = executionOptions.timestamp;
        options.isIdempotent = executionOptions.isIdempotent;
      }

      if (overrideIdempotency) {
        options.isIdempotent = true;
      }

      return options;
    }
    /**
     * Returns the QueryOptions for a batch statement.
     * @param {Object|String|undefined} executionOptions
     * @param {Boolean} isIdempotent
     * @param {Boolean} isCounter
     */

  }, {
    key: "adaptBatchOptions",
    value: function adaptBatchOptions(executionOptions, isIdempotent, isCounter) {
      var options = {
        prepare: true,
        executionProfile: undefined,
        timestamp: undefined,
        logged: undefined,
        isIdempotent: isIdempotent,
        counter: isCounter
      };

      if (typeof executionOptions === 'string') {
        options.executionProfile = executionOptions;
      } else if (executionOptions !== null && executionOptions !== undefined) {
        options.executionProfile = executionOptions.executionProfile;
        options.timestamp = executionOptions.timestamp;
        options.logged = executionOptions.logged !== false;

        if (executionOptions.isIdempotent !== undefined) {
          options.isIdempotent = executionOptions.isIdempotent;
        }
      }

      return options;
    }
  }]);

  return DocInfoAdapter;
}();

var docInfoAdapter = DocInfoAdapter$2;

var utils$1 = utils$V;
var QueryGenerator = queryGenerator;
var ResultMapper$1 = resultMapper;
var Result$1 = result;
var Cache = cache;
var Tree = tree;
var ObjectSelector = objectSelector;
var DocInfoAdapter$1 = docInfoAdapter;
var cacheHighWaterMark = 100;
/**
 * @ignore
 */

var MappingHandler$1 = /*#__PURE__*/function () {
  /**
   * @param {Client} client
   * @param {ModelMappingInfo} mappingInfo
   */
  function MappingHandler(client, mappingInfo) {
    var _this = this;

    _classCallCheck(this, MappingHandler);

    this._client = client;
    this._cache = {
      select: new Tree().on('add', function (length) {
        return _this._validateCacheLength(length);
      }),
      selectAll: new Tree().on('add', function (length) {
        return _this._validateCacheLength(length);
      }),
      insert: new Tree().on('add', function (length) {
        return _this._validateCacheLength(length);
      }),
      update: new Tree().on('add', function (length) {
        return _this._validateCacheLength(length);
      }),
      remove: new Tree().on('add', function (length) {
        return _this._validateCacheLength(length);
      }),
      customQueries: new Map()
    };
    /**
     * Gets the mapping information of the document.
     * @type {ModelMappingInfo}
     */

    this.info = mappingInfo;
  }
  /**
   * Gets a function to be used to execute SELECT the query using the document.
   * @param {Object} doc
   * @param {{fields, orderBy, limit}} docInfo
   * @param {Boolean} allPKsDefined Determines whether all primary keys must be defined in the doc for the query to
   * be valid.
   * @return {Promise<Function>}
   */


  _createClass(MappingHandler, [{
    key: "getSelectExecutor",
    value: function getSelectExecutor(doc, docInfo, allPKsDefined) {
      var _this2 = this;

      var docKeys = Object.keys(doc);

      if (docKeys.length === 0) {
        return Promise.reject(new Error('Expected object with keys'));
      }

      var cacheKey = Cache.getSelectKey(docKeys, doc, docInfo); // Cache the executor and the result mapper under the same key
      // That way, those can get evicted together

      var cacheItem = this._cache.select.getOrCreate(cacheKey, function () {
        return {
          executor: null,
          resultAdapter: null
        };
      });

      if (cacheItem.executor !== null) {
        return Promise.resolve(cacheItem.executor);
      }

      var propertiesInfo = DocInfoAdapter$1.getPropertiesInfo(docKeys, null, doc, this.info);
      var fieldsInfo = DocInfoAdapter$1.getPropertiesInfo(utils$1.emptyArray, docInfo, doc, this.info);
      var orderByColumns = DocInfoAdapter$1.adaptOrderBy(docInfo, this.info);
      var limit = docInfo && docInfo.limit;
      return this._client.connect().then(function () {
        return ObjectSelector.getForSelect(_this2._client, _this2.info, allPKsDefined, propertiesInfo, fieldsInfo, orderByColumns);
      }).then(function (tableName) {
        // Part of the closure
        var query = QueryGenerator.getSelect(tableName, _this2.info.keyspace, propertiesInfo, fieldsInfo, orderByColumns, limit);
        var paramsGetter = QueryGenerator.selectParamsGetter(propertiesInfo, limit);
        var self = _this2;

        cacheItem.executor = function selectExecutor(doc, docInfo, executionOptions) {
          return self._executeSelect(query, paramsGetter, doc, docInfo, executionOptions, cacheItem);
        };

        return cacheItem.executor;
      });
    }
  }, {
    key: "getSelectAllExecutor",
    value: function getSelectAllExecutor(docInfo) {
      var cacheKey = Cache.getSelectAllKey(docInfo);

      var cacheItem = this._cache.selectAll.getOrCreate(cacheKey, function () {
        return {
          executor: null,
          resultAdapter: null
        };
      });

      if (cacheItem.executor !== null) {
        return cacheItem.executor;
      }

      var fieldsInfo = DocInfoAdapter$1.getPropertiesInfo(utils$1.emptyArray, docInfo, utils$1.emptyObject, this.info);
      var orderByColumns = DocInfoAdapter$1.adaptOrderBy(docInfo, this.info);
      var limit = docInfo && docInfo.limit;
      var tableName = ObjectSelector.getForSelectAll(this.info); // Part of the closure

      var query = QueryGenerator.getSelect(tableName, this.info.keyspace, utils$1.emptyArray, fieldsInfo, orderByColumns, limit);
      var paramsGetter = QueryGenerator.selectParamsGetter(utils$1.emptyArray, limit);
      var self = this;

      cacheItem.executor = function selectAllExecutor(docInfo, executionOptions) {
        return self._executeSelect(query, paramsGetter, null, docInfo, executionOptions, cacheItem);
      };

      return cacheItem.executor;
    }
    /**
     * Executes a SELECT query and returns the adapted results.
     * When a result adapter is not yet created, it gets a new one and caches it.
     * @private
     */

  }, {
    key: "_executeSelect",
    value: function _executeSelect(query, paramsGetter, doc, docInfo, executionOptions, cacheItem) {
      var _this3 = this;

      var options = DocInfoAdapter$1.adaptAllOptions(executionOptions, true);
      return this._client.execute(query, paramsGetter(doc, docInfo, this.info), options).then(function (rs) {
        if (cacheItem.resultAdapter === null) {
          cacheItem.resultAdapter = ResultMapper$1.getSelectAdapter(_this3.info, rs);
        }

        return new Result$1(rs, _this3.info, cacheItem.resultAdapter);
      });
    }
    /**
     * Gets a function to be used to execute INSERT the query using the document.
     * @param {Object} doc
     * @param {{ifNotExists, ttl, fields}} docInfo
     * @return {Promise<Function>}
     */

  }, {
    key: "getInsertExecutor",
    value: function getInsertExecutor(doc, docInfo) {
      var _this4 = this;

      var docKeys = Object.keys(doc);

      if (docKeys.length === 0) {
        return Promise.reject(new Error('Expected object with keys'));
      }

      var cacheKey = Cache.getInsertKey(docKeys, docInfo);

      var cacheItem = this._cache.insert.getOrCreate(cacheKey, function () {
        return {
          executor: null
        };
      });

      if (cacheItem.executor !== null) {
        return Promise.resolve(cacheItem.executor);
      }

      return this.createInsertQueries(docKeys, doc, docInfo).then(function (queries) {
        if (queries.length === 1) {
          return _this4._setSingleExecutor(cacheItem, queries[0]);
        }

        return _this4._setBatchExecutor(cacheItem, queries);
      });
    }
    /**
     * Creates an Array containing the query and the params getter function for each table affected by the INSERT.
     * @param {Array<String>} docKeys
     * @param {Object} doc
     * @param {{ifNotExists, ttl, fields}} docInfo
     * @returns {Promise<Array<{query, paramsGetter}>>}
     */

  }, {
    key: "createInsertQueries",
    value: function createInsertQueries(docKeys, doc, docInfo) {
      var _this5 = this;

      var propertiesInfo = DocInfoAdapter$1.getPropertiesInfo(docKeys, docInfo, doc, this.info);
      var ifNotExists = docInfo && docInfo.ifNotExists; // Get all the tables affected

      return this._client.connect().then(function () {
        return ObjectSelector.getForInsert(_this5._client, _this5.info, propertiesInfo);
      }).then(function (tables) {
        if (tables.length > 1 && ifNotExists) {
          throw new Error('Batch with ifNotExists conditions cannot span multiple tables');
        } // For each tables affected, Generate query and parameter getters


        return tables.map(function (table) {
          return QueryGenerator.getInsert(table, _this5.info.keyspace, propertiesInfo, docInfo, ifNotExists);
        });
      });
    }
    /**
     * Gets a function to be used to execute the UPDATE queries with the provided document.
     * @param {Object} doc
     * @param {{ifExists, when, ttl, fields}} docInfo
     * @return {Promise<Function>}
     */

  }, {
    key: "getUpdateExecutor",
    value: function getUpdateExecutor(doc, docInfo) {
      var _this6 = this;

      var docKeys = Object.keys(doc);

      if (docKeys.length === 0) {
        return Promise.reject(new Error('Expected object with keys'));
      }

      var cacheKey = Cache.getUpdateKey(docKeys, doc, docInfo);

      var cacheItem = this._cache.update.getOrCreate(cacheKey, function () {
        return {
          executor: null
        };
      });

      if (cacheItem.executor !== null) {
        return Promise.resolve(cacheItem.executor);
      }

      return this.createUpdateQueries(docKeys, doc, docInfo).then(function (queries) {
        if (queries.length === 1) {
          return _this6._setSingleExecutor(cacheItem, queries[0]);
        }

        return _this6._setBatchExecutor(cacheItem, queries);
      });
    }
    /**
     * Creates an Array containing the query and the params getter function for each table affected by the UPDATE.
     * @param {Array<String>} docKeys
     * @param {Object} doc
     * @param {Object} docInfo
     * @returns {Promise<Array<{query, paramsGetter, isIdempotent}>>}
     */

  }, {
    key: "createUpdateQueries",
    value: function createUpdateQueries(docKeys, doc, docInfo) {
      var _this7 = this;

      var propertiesInfo = DocInfoAdapter$1.getPropertiesInfo(docKeys, docInfo, doc, this.info);
      var ifExists = docInfo && docInfo.ifExists;
      var when = docInfo && docInfo.when ? DocInfoAdapter$1.getPropertiesInfo(Object.keys(docInfo.when), null, docInfo.when, this.info) : utils$1.emptyArray;

      if (when.length > 0 && ifExists) {
        throw new Error('Both when and ifExists conditions can not be applied to the same statement');
      } // Get all the tables affected


      return this._client.connect().then(function () {
        return ObjectSelector.getForUpdate(_this7._client, _this7.info, propertiesInfo, when);
      }).then(function (tables) {
        if (tables.length > 1 && (when.length > 0 || ifExists)) {
          throw new Error('Batch with when or ifExists conditions cannot span multiple tables');
        } // For each table affected, Generate query and parameter getters


        return tables.map(function (table) {
          return QueryGenerator.getUpdate(table, _this7.info.keyspace, propertiesInfo, docInfo, when, ifExists);
        });
      });
    }
    /**
     * Gets a function to be used to execute the DELETE queries with the provided document.
     * @param {Object} doc
     * @param {{when, ifExists, fields, deleteOnlyColumns}} docInfo
     * @return {Promise<Function>}
     */

  }, {
    key: "getDeleteExecutor",
    value: function getDeleteExecutor(doc, docInfo) {
      var _this8 = this;

      var docKeys = Object.keys(doc);

      if (docKeys.length === 0) {
        return Promise.reject(new Error('Expected object with keys'));
      }

      var cacheKey = Cache.getRemoveKey(docKeys, doc, docInfo);

      var cacheItem = this._cache.remove.getOrCreate(cacheKey, function () {
        return {
          executor: null
        };
      });

      if (cacheItem.executor !== null) {
        return Promise.resolve(cacheItem.executor);
      }

      return this.createDeleteQueries(docKeys, doc, docInfo).then(function (queries) {
        if (queries.length === 1) {
          return _this8._setSingleExecutor(cacheItem, queries[0]);
        }

        return _this8._setBatchExecutor(cacheItem, queries);
      });
    }
    /**
     * Creates an Array containing the query and the params getter function for each table affected by the DELETE.
     * @param {Array<String>} docKeys
     * @param {Object} doc
     * @param {{when, ifExists, fields, deleteOnlyColumns}} docInfo
     * @returns {Promise<Array<{query, paramsGetter}>>}
     */

  }, {
    key: "createDeleteQueries",
    value: function createDeleteQueries(docKeys, doc, docInfo) {
      var _this9 = this;

      var propertiesInfo = DocInfoAdapter$1.getPropertiesInfo(docKeys, docInfo, doc, this.info);
      var ifExists = docInfo && docInfo.ifExists;
      var when = docInfo && docInfo.when ? DocInfoAdapter$1.getPropertiesInfo(Object.keys(docInfo.when), null, docInfo.when, this.info) : utils$1.emptyArray;

      if (when.length > 0 && ifExists) {
        throw new Error('Both when and ifExists conditions can not be applied to the same statement');
      } // Get all the tables affected


      return this._client.connect().then(function () {
        return ObjectSelector.getForDelete(_this9._client, _this9.info, propertiesInfo, when);
      }).then(function (tables) {
        if (tables.length > 1 && (when.length > 0 || ifExists)) {
          throw new Error('Batch with when or ifExists conditions cannot span multiple tables');
        } // For each tables affected, Generate query and parameter getters


        return tables.map(function (table) {
          return QueryGenerator.getDelete(table, _this9.info.keyspace, propertiesInfo, docInfo, when, ifExists);
        });
      });
    }
  }, {
    key: "getExecutorFromQuery",
    value: function getExecutorFromQuery(query, paramsHandler, commonExecutionOptions) {
      // Use the current instance in the closure
      // as there is no guarantee of how the returned function will be invoked
      var self = this;
      var commonOptions = commonExecutionOptions ? DocInfoAdapter$1.adaptAllOptions(commonExecutionOptions) : null;
      return function queryMappedExecutor(doc, executionOptions) {
        // When the executionOptions were already specified,
        // use it and skip the ones provided in each invocation
        var options = commonOptions ? commonOptions : DocInfoAdapter$1.adaptAllOptions(executionOptions);
        return self._client.execute(query, paramsHandler(doc), options).then(function (rs) {
          // Cache the resultAdapter based on the query
          var resultAdapter = self._cache.customQueries.get(query);

          if (resultAdapter === undefined) {
            var resultAdapterInfo = ResultMapper$1.getCustomQueryAdapter(self.info, rs);
            resultAdapter = resultAdapterInfo.fn;

            if (resultAdapterInfo.canCache) {
              // Avoid caching conditional updates results as the amount of columns change
              // depending on the parameter values.
              self._cache.customQueries.set(query, resultAdapter);

              if (self._cache.customQueries.size === cacheHighWaterMark) {
                self._client.log('warning', "Custom queries cache reached ".concat(cacheHighWaterMark, " items, this could be caused by ") + "hard-coding parameter values inside the query, which should be avoided");
              }
            }
          }

          return new Result$1(rs, self.info, resultAdapter);
        });
      };
    }
  }, {
    key: "_setSingleExecutor",
    value: function _setSingleExecutor(cacheItem, queryInfo) {
      // Parameters and this instance are part of the closure
      var self = this; // Set the function to execute the request in the cache

      cacheItem.executor = function singleExecutor(doc, docInfo, executionOptions) {
        var options = DocInfoAdapter$1.adaptOptions(executionOptions, queryInfo.isIdempotent);
        return self._client.execute(queryInfo.query, queryInfo.paramsGetter(doc, docInfo, self.info), options).then(function (rs) {
          return new Result$1(rs, self.info, ResultMapper$1.getMutationAdapter(rs));
        });
      };

      return cacheItem.executor;
    }
  }, {
    key: "_setBatchExecutor",
    value: function _setBatchExecutor(cacheItem, queries) {
      // Parameters and the following fields are part of the closure
      var self = this;
      var isIdempotent = queries.reduce(function (acc, q) {
        return acc && q.isIdempotent;
      }, true); // Set the function to execute the batch request in the cache

      cacheItem.executor = function batchExecutor(doc, docInfo, executionOptions) {
        // Use the params getter function to obtain the parameters each time
        var queryAndParams = queries.map(function (q) {
          return {
            query: q.query,
            params: q.paramsGetter(doc, docInfo, self.info)
          };
        });
        var options = DocInfoAdapter$1.adaptOptions(executionOptions, isIdempotent); // Execute using a Batch

        return self._client.batch(queryAndParams, options).then(function (rs) {
          return new Result$1(rs, self.info, ResultMapper$1.getMutationAdapter(rs));
        });
      };

      return cacheItem.executor;
    }
  }, {
    key: "_validateCacheLength",
    value: function _validateCacheLength(length) {
      if (length !== cacheHighWaterMark) {
        return;
      }

      this._client.log('warning', "ModelMapper cache reached ".concat(cacheHighWaterMark, " items, this could be caused by ") + "building the object to map in different ways (with different shapes) each time. Use the same or few object " + "structures for a model and represent unset values with undefined or types.unset");
    }
  }]);

  return MappingHandler;
}();

var mappingHandler = MappingHandler$1;

var tableMappings = {};

/**
 * Contains a set of methods to represent a row into a document and a document into a row.
 * @alias module:mapping~TableMappings
 * @interface
 */


var TableMappings$1 = /*#__PURE__*/function () {
  function TableMappings() {
    _classCallCheck(this, TableMappings);
  }

  _createClass(TableMappings, [{
    key: "newObjectInstance",
    value:
    /**
     * Method that is called by the mapper to create the instance of the document.
     * @return {Object}
     */
    function newObjectInstance() {
      return {};
    }
    /**
     * Gets the name of the column based on the document property name.
     * @param {String} propName The name of the property.
     * @returns {String}
     */

  }, {
    key: "getColumnName",
    value: function getColumnName(propName) {
      return propName;
    }
    /**
     * Gets the name of the document property based on the column name.
     * @param {String} columnName The name of the column.
     * @returns {String}
     */

  }, {
    key: "getPropertyName",
    value: function getPropertyName(columnName) {
      return columnName;
    }
  }]);

  return TableMappings;
}();
/**
 * A [TableMappings]{@link module:mapping~TableMappings} implementation that converts CQL column names in all-lowercase
 * identifiers with underscores (snake case) to camel case (initial lowercase letter) property names.
 * <p>
 *   The conversion is performed without any checks for the source format, you should make sure that the source
 *   format is snake case for CQL identifiers and camel case for properties.
 * </p>
 * @alias module:mapping~UnderscoreCqlToCamelCaseMappings
 * @implements {module:mapping~TableMappings}
 */


var UnderscoreCqlToCamelCaseMappings = /*#__PURE__*/function (_TableMappings) {
  _inherits(UnderscoreCqlToCamelCaseMappings, _TableMappings);

  var _super = _createSuper(UnderscoreCqlToCamelCaseMappings);

  /**
   * Creates a new instance of {@link UnderscoreCqlToCamelCaseMappings}
   */
  function UnderscoreCqlToCamelCaseMappings() {
    _classCallCheck(this, UnderscoreCqlToCamelCaseMappings);

    return _super.call(this);
  }
  /**
   * Converts a property name in camel case to snake case.
   * @param {String} propName Name of the property to convert to snake case.
   * @return {String}
   */


  _createClass(UnderscoreCqlToCamelCaseMappings, [{
    key: "getColumnName",
    value: function getColumnName(propName) {
      return propName.replace(/[a-z][A-Z]/g, function (match, offset) {
        return match.charAt(0) + '_' + match.charAt(1);
      }).toLowerCase();
    }
    /**
     * Converts a column name in snake case to camel case.
     * @param {String} columnName The column name to convert to camel case.
     * @return {String}
     */

  }, {
    key: "getPropertyName",
    value: function getPropertyName(columnName) {
      return columnName.replace(/_[a-z]/g, function (match, offset) {
        return offset === 0 ? match : match.substr(1).toUpperCase();
      });
    }
  }]);

  return UnderscoreCqlToCamelCaseMappings;
}(TableMappings$1);
/**
 * Default implementation of [TableMappings]{@link module:mapping~TableMappings} that doesn't perform any conversion.
 * @alias module:mapping~DefaultTableMappings
 * @implements {module:mapping~TableMappings}
 */


var DefaultTableMappings$1 = /*#__PURE__*/function (_TableMappings2) {
  _inherits(DefaultTableMappings, _TableMappings2);

  var _super2 = _createSuper(DefaultTableMappings);

  /**
   * Creates a new instance of {@link DefaultTableMappings}.
   */
  function DefaultTableMappings() {
    _classCallCheck(this, DefaultTableMappings);

    return _super2.call(this);
  }
  /**  @override */


  _createClass(DefaultTableMappings, [{
    key: "getColumnName",
    value: function getColumnName(propName) {
      return _get(_getPrototypeOf(DefaultTableMappings.prototype), "getColumnName", this).call(this, propName);
    }
    /** @override */

  }, {
    key: "getPropertyName",
    value: function getPropertyName(columnName) {
      return _get(_getPrototypeOf(DefaultTableMappings.prototype), "getPropertyName", this).call(this, columnName);
    }
    /**
     * Creates a new object instance, using object initializer.
     */

  }, {
    key: "newObjectInstance",
    value: function newObjectInstance() {
      return _get(_getPrototypeOf(DefaultTableMappings.prototype), "newObjectInstance", this).call(this);
    }
  }]);

  return DefaultTableMappings;
}(TableMappings$1);

tableMappings.TableMappings = TableMappings$1;
tableMappings.UnderscoreCqlToCamelCaseMappings = UnderscoreCqlToCamelCaseMappings;
tableMappings.DefaultTableMappings = DefaultTableMappings$1;

var tableMappingsModule$1 = tableMappings;
var TableMappings = tableMappingsModule$1.TableMappings;
var DefaultTableMappings = tableMappingsModule$1.DefaultTableMappings;
/**
 * Represents the parsed user information of the table mappings of a model.
 * @ignore
 */

var ModelMappingInfo$1 = /*#__PURE__*/function () {
  /**
   * @param {String} keyspace
   * @param {Array<{name, isView}>} tables
   * @param {TableMappings} mappings
   * @param {Map<String,ModelColumnInfo>} columns
   */
  function ModelMappingInfo(keyspace, tables, mappings, columns) {
    _classCallCheck(this, ModelMappingInfo);

    this.keyspace = keyspace;
    this.tables = tables;
    this._mappings = mappings;
    this._columns = columns; // Define a map of column information per property name

    /** @type {Map<String, ModelColumnInfo>} */

    this._documentProperties = new Map();

    var _iterator = _createForOfIteratorHelper(columns.values()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var modelColumnInfo = _step.value;

        this._documentProperties.set(modelColumnInfo.propertyName, modelColumnInfo);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  _createClass(ModelMappingInfo, [{
    key: "getColumnName",
    value: function getColumnName(propName) {
      var modelColumnInfo = this._documentProperties.get(propName);

      if (modelColumnInfo !== undefined) {
        // There is an specific name transformation between the column name and the property name
        return modelColumnInfo.columnName;
      } // Rely on the TableMappings (i.e. maybe there is a convention defined for this property)


      return this._mappings.getColumnName(propName);
    }
  }, {
    key: "getPropertyName",
    value: function getPropertyName(columnName) {
      var modelColumnInfo = this._columns.get(columnName);

      if (modelColumnInfo !== undefined) {
        // There is an specific name transformation between the column name and the property name
        return modelColumnInfo.propertyName;
      } // Rely on the TableMappings (i.e. maybe there is a convention defined for this column)


      return this._mappings.getPropertyName(columnName);
    }
  }, {
    key: "getFromModelFn",
    value: function getFromModelFn(propName) {
      var modelColumnInfo = this._documentProperties.get(propName);

      return modelColumnInfo !== undefined ? modelColumnInfo.fromModel : null;
    }
  }, {
    key: "getToModelFn",
    value: function getToModelFn(columnName) {
      var modelColumnInfo = this._columns.get(columnName);

      return modelColumnInfo !== undefined ? modelColumnInfo.toModel : null;
    }
  }, {
    key: "newInstance",
    value: function newInstance() {
      return this._mappings.newObjectInstance();
    }
    /**
     * Parses the user options into a map of model names and ModelMappingInfo.
     * @param {MappingOptions} options
     * @param {String} currentKeyspace
     * @returns {Map<String, ModelMappingInfo>}
     */

  }], [{
    key: "parse",
    value: function parse(options, currentKeyspace) {
      var result = new Map();

      if (!options || !options.models) {
        return result;
      }

      Object.keys(options.models).forEach(function (modelName) {
        var modelOptions = options.models[modelName];
        result.set(modelName, ModelMappingInfo._create(modelName, currentKeyspace, modelOptions));
      });
      return result;
    }
  }, {
    key: "_create",
    value: function _create(modelName, currentKeyspace, modelOptions) {
      if (!currentKeyspace && (!modelOptions || !modelOptions.keyspace)) {
        throw new Error('You should specify the keyspace of the model in the MappingOptions when the Client is not using a keyspace');
      }

      if (!modelOptions) {
        return ModelMappingInfo.createDefault(modelName, currentKeyspace);
      }

      var tables;

      if (modelOptions.tables && modelOptions.tables.length > 0) {
        tables = modelOptions.tables.map(function (item) {
          var table = {
            name: null,
            isView: false
          };

          if (typeof item === 'string') {
            table.name = item;
          } else if (item) {
            table.name = item.name;
            table.isView = !!item.isView;
          }

          if (!table.name) {
            throw new Error("Table name not specified for model '".concat(modelName, "'"));
          }

          return table;
        });
      } else {
        tables = [{
          name: modelName,
          isView: false
        }];
      }

      if (modelOptions.mappings && !(modelOptions.mappings instanceof TableMappings)) {
        throw new Error('mappings should be an instance of TableMappings');
      }

      var columns = new Map();

      if (modelOptions.columns !== null && _typeof(modelOptions.columns) === 'object') {
        Object.keys(modelOptions.columns).forEach(function (columnName) {
          columns.set(columnName, ModelColumnInfo.parse(columnName, modelOptions.columns[columnName]));
        });
      }

      return new ModelMappingInfo(modelOptions.keyspace || currentKeyspace, tables, modelOptions.mappings || new DefaultTableMappings(), columns);
    }
  }, {
    key: "createDefault",
    value: function createDefault(modelName, currentKeyspace) {
      return new ModelMappingInfo(currentKeyspace, [{
        name: modelName,
        isView: false
      }], new DefaultTableMappings(), new Map());
    }
  }]);

  return ModelMappingInfo;
}();

var ModelColumnInfo = /*#__PURE__*/function () {
  function ModelColumnInfo(columnName, propertyName, toModel, fromModel) {
    _classCallCheck(this, ModelColumnInfo);

    this.columnName = columnName;
    this.propertyName = propertyName;

    if (toModel && typeof toModel !== 'function') {
      throw new TypeError("toModel type for property '".concat(propertyName, "' should be a function (obtained ").concat(_typeof(toModel), ")"));
    }

    if (fromModel && typeof fromModel !== 'function') {
      throw new TypeError("fromModel type for property '".concat(propertyName, "' should be a function (obtained ").concat(_typeof(fromModel), ")"));
    }

    this.toModel = toModel;
    this.fromModel = fromModel;
  }

  _createClass(ModelColumnInfo, null, [{
    key: "parse",
    value: function parse(columnName, value) {
      if (!value) {
        return new ModelColumnInfo(columnName, columnName);
      }

      if (typeof value === 'string') {
        return new ModelColumnInfo(columnName, value);
      }

      return new ModelColumnInfo(columnName, value.name || columnName, value.toModel, value.fromModel);
    }
  }]);

  return ModelColumnInfo;
}();

var modelMappingInfo = ModelMappingInfo$1;

var ModelMapper = modelMapper;
var MappingHandler = mappingHandler;
var DocInfoAdapter = docInfoAdapter;
var errors = errors$s;
var Result = result;
var ResultMapper = resultMapper;
var ModelMappingInfo = modelMappingInfo;
var ModelBatchItem = modelBatchItem.ModelBatchItem;
/**
 * Represents an object mapper for Apache Cassandra and DataStax Enterprise.
 * @alias module:mapping~Mapper
 * @example <caption>Creating a Mapper instance with some options for the model 'User'</caption>
 * const mappingOptions = {
 *   models: {
 *     'User': {
 *       tables: ['users'],
 *       mappings: new UnderscoreCqlToCamelCaseMappings(),
 *       columnNames: {
 *         'userid': 'id'
 *       }
 *     }
 *   }
 * };
 * const mapper = new Mapper(client, mappingOptions);
 * @example <caption>Creating a Mapper instance with other possible options for a model</caption>
 * const mappingOptions = {
 *   models: {
 *     'Video': {
 *       tables: ['videos', 'user_videos', 'latest_videos', { name: 'my_videos_view', isView: true }],
 *       mappings: new UnderscoreCqlToCamelCaseMappings(),
 *       columnNames: {
 *         'videoid': 'id'
 *       },
 *       keyspace: 'ks1'
 *     }
 *   }
 * };
 * const mapper = new Mapper(client, mappingOptions);
 */

var Mapper = /*#__PURE__*/function () {
  /**
   * Creates a new instance of Mapper.
   * @param {Client} client The Client instance to use to execute the queries and fetch the metadata.
   * @param {MappingOptions} [options] The [MappingOptions]{@link module:mapping~MappingOptions} containing the
   * information of the models and table mappings.
   */
  function Mapper(client, options) {
    _classCallCheck(this, Mapper);

    if (!client) {
      throw new Error('client must be defined');
    }
    /**
     * The Client instance used to create this Mapper instance.
     * @type {Client}
     */


    this.client = client;
    this._modelMappingInfos = ModelMappingInfo.parse(options, client.keyspace);
    this._modelMappers = new Map();
  }
  /**
   * Gets a [ModelMapper]{@link module:mapping~ModelMapper} that is able to map documents of a certain model into
   * CQL rows.
   * @param {String} name The name to identify the model. Note that the name is case-sensitive.
   * @returns {ModelMapper} A [ModelMapper]{@link module:mapping~ModelMapper} instance.
   */


  _createClass(Mapper, [{
    key: "forModel",
    value: function forModel(name) {
      var modelMapper = this._modelMappers.get(name);

      if (modelMapper === undefined) {
        var mappingInfo = this._modelMappingInfos.get(name);

        if (mappingInfo === undefined) {
          if (!this.client.keyspace) {
            throw new Error("No mapping information found for model '".concat(name, "'. ") + "Mapper is unable to create default mappings without setting the keyspace");
          }

          mappingInfo = ModelMappingInfo.createDefault(name, this.client.keyspace);
          this.client.log('info', "Mapping information for model '".concat(name, "' not found, creating default mapping. ") + "Keyspace: ".concat(mappingInfo.keyspace, "; Table: ").concat(mappingInfo.tables[0].name, "."));
        } else {
          this.client.log('info', "Creating model mapper for '".concat(name, "' using mapping information. Keyspace: ").concat(mappingInfo.keyspace, "; Table").concat(mappingInfo.tables.length > 1 ? 's' : '', ": ").concat(mappingInfo.tables.map(function (t) {
            return t.name;
          }), "."));
        }

        modelMapper = new ModelMapper(name, new MappingHandler(this.client, mappingInfo));

        this._modelMappers.set(name, modelMapper);
      }

      return modelMapper;
    }
    /**
     * Executes a batch of queries represented in the items.
     * @param {Array<ModelBatchItem>} items
     * @param {Object|String} [executionOptions] An object containing the options to be used for the requests
     * execution or a string representing the name of the execution profile.
     * @param {String} [executionOptions.executionProfile] The name of the execution profile.
     * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times without
     * changing the result beyond the initial application.
     * <p>
     *   The mapper uses the generated queries to determine the default value. When an UPDATE is generated with a
     *   counter column or appending/prepending to a list column, the execution is marked as not idempotent.
     * </p>
     * <p>
     *   Additionally, the mapper uses the safest approach for queries with lightweight transactions (Compare and
     *   Set) by considering them as non-idempotent. Lightweight transactions at client level with transparent retries can
     *   break linearizability. If that is not an issue for your application, you can manually set this field to true.
     * </p>
     * @param {Boolean} [executionOptions.logged=true] Determines whether the batch should be written to the batchlog.
     * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the
     * unix epoch (00:00:00, January 1st, 1970).
     * @returns {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result}.
     */

  }, {
    key: "batch",
    value: function batch(items, executionOptions) {
      var _this = this;

      if (!Array.isArray(items) || !(items.length > 0)) {
        return Promise.reject(new errors.ArgumentError('First parameter items should be an Array with 1 or more ModelBatchItem instances'));
      }

      var queries = [];
      var isIdempotent = true;
      var isCounter;
      return Promise.all(items.map(function (item) {
        if (!(item instanceof ModelBatchItem)) {
          return Promise.reject(new Error('Batch items must be instances of ModelBatchItem, use modelMapper.batching object to create each item'));
        }

        return item.pushQueries(queries).then(function (options) {
          // The batch is idempotent when all the queries contained are idempotent
          isIdempotent = isIdempotent && options.isIdempotent; // Let it fail at server level when there is a mix of counter and normal mutations

          isCounter = options.isCounter;
        });
      })).then(function () {
        return _this.client.batch(queries, DocInfoAdapter.adaptBatchOptions(executionOptions, isIdempotent, isCounter));
      }).then(function (rs) {
        // Results should only be adapted when the batch contains LWT (single table)
        var info = items[0].getMappingInfo();
        return new Result(rs, info, ResultMapper.getMutationAdapter(rs));
      });
    }
  }]);

  return Mapper;
}();
/**
 * Represents the mapping options.
 * @typedef {Object} module:mapping~MappingOptions
 * @property {Object<String, ModelOptions>} models An associative array containing the
 * name of the model as key and the table and column information as value.
 */

/**
 * Represents a set of options that applies to a certain model.
 * @typedef {Object} module:mapping~ModelOptions
 * @property {Array<String>|Array<{name, isView}>} tables An Array containing the name of the tables or An Array
 * containing the name and isView property to describe the table.
 * @property {TableMappings} mappings The TableMappings implementation instance that is used to convert from column
 * names to property names and the other way around.
 * @property {Object.<String, String>} [columnNames] An associative array containing the name of the columns and
 * properties that doesn't follow the convention defined in the <code>TableMappings</code>.
 * @property {String} [keyspace] The name of the keyspace. Only mandatory when the Client is not using a keyspace.
 */


var mapper = Mapper;

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Module containing classes and fields related to the Mapper.
 * @module mapping
 */


mapping.Mapper = mapper;
mapping.ModelMapper = modelMapper;
mapping.ModelBatchMapper = modelBatchMapper;
mapping.ModelBatchItem = modelBatchItem.ModelBatchItem;
mapping.Result = result;
var tableMappingsModule = tableMappings;
mapping.TableMappings = tableMappingsModule.TableMappings;
mapping.DefaultTableMappings = tableMappingsModule.DefaultTableMappings;
mapping.UnderscoreCqlToCamelCaseMappings = tableMappingsModule.UnderscoreCqlToCamelCaseMappings;
mapping.q = q$1.q;

var concurrent = {};

var Stream = require$$0__default$5["default"].Stream;
var utils = utils$V;
/**
 * Utilities for concurrent query execution with the DataStax Node.js Driver.
 * @module concurrent
 */

/**
 * Executes multiple queries concurrently at the defined concurrency level.
 * @static
 * @param {Client} client The {@link Client} instance.
 * @param {String|Array<{query, params}>} query The query to execute per each parameter item.
 * @param {Array<Array>|Stream|Object} parameters An {@link Array} or a readable {@link Stream} composed of {@link Array}
 * items representing each individual set of parameters. Per each item in the {@link Array} or {@link Stream}, an
 * execution is going to be made.
 * @param {Object} [options] The execution options.
 * @param {String} [options.executionProfile] The execution profile to be used.
 * @param {Number} [options.concurrencyLevel=100] The concurrency level to determine the maximum amount of in-flight
 * operations at any given time
 * @param {Boolean} [options.raiseOnFirstError=true] Determines whether execution should stop after the first failed
 * execution and the corresponding exception will be raised.
 * @param {Boolean} [options.collectResults=false] Determines whether each individual
 * [ResultSet]{@link module:types~ResultSet} instance should be collected in the grouped result.
 * @param {Number} [options.maxErrors=100] The maximum amount of errors to be collected before ignoring the rest of
 * the error results.
 * @returns {Promise<ResultSetGroup>} A <code>Promise</code> of {@link ResultSetGroup} that is resolved when all the
 * executions completed and it's rejected when <code>raiseOnFirstError</code> is <code>true</code> and there is one
 * or more failures.
 * @example <caption>Using a fixed query and an Array of Arrays as parameters</caption>
 * const query = 'INSERT INTO table1 (id, value) VALUES (?, ?)';
 * const parameters = [[1, 'a'], [2, 'b'], [3, 'c'], ]; // ...
 * const result = await executeConcurrent(client, query, parameters);
 * @example <caption>Using a fixed query and a readable stream</caption>
 * const stream = csvStream.pipe(transformLineToArrayStream);
 * const result = await executeConcurrent(client, query, stream);
 * @example <caption>Using a different queries</caption>
 * const queryAndParameters = [
 *   { query: 'INSERT INTO videos (id, name, user_id) VALUES (?, ?, ?)',
 *     params: [ id, name, userId ] },
 *   { query: 'INSERT INTO user_videos (user_id, id, name) VALUES (?, ?, ?)',
 *     params: [ userId, id, name ] },
 *   { query: 'INSERT INTO latest_videos (id, name, user_id) VALUES (?, ?, ?)',
 *     params: [ id, name, userId ] },
 * ];
 *
 * const result = await executeConcurrent(client, queryAndParameters);
 */

function executeConcurrent(client, query, parameters, options) {
  if (!client) {
    throw new TypeError('Client instance is not defined');
  }

  if (typeof query === 'string') {
    if (Array.isArray(parameters)) {
      return new ArrayBasedExecutor(client, query, parameters, options).execute();
    }

    if (parameters instanceof Stream) {
      return new StreamBasedExecutor(client, query, parameters, options).execute();
    }

    throw new TypeError('parameters should be an Array or a Stream instance');
  }

  if (Array.isArray(query)) {
    options = parameters;
    return new ArrayBasedExecutor(client, null, query, options).execute();
  }

  throw new TypeError('A string query or query and parameters array should be provided');
}
/**
 * Wraps the functionality to execute given an Array.
 * @ignore
 */


var ArrayBasedExecutor = /*#__PURE__*/function () {
  /**
   * @param {Client} client
   * @param {String} query
   * @param {Array<Array>|Array<{query, params}>} parameters
   * @param {Object} [options] The execution options.
   * @private
   */
  function ArrayBasedExecutor(client, query, parameters, options) {
    _classCallCheck(this, ArrayBasedExecutor);

    this._client = client;
    this._query = query;
    this._parameters = parameters;
    options = options || utils.emptyObject;
    this._raiseOnFirstError = options.raiseOnFirstError !== false;
    this._concurrencyLevel = Math.min(options.concurrencyLevel || 100, this._parameters.length);
    this._queryOptions = {
      prepare: true,
      executionProfile: options.executionProfile
    };
    this._result = new ResultSetGroup(options);
    this._stop = false;
  }

  _createClass(ArrayBasedExecutor, [{
    key: "execute",
    value: function execute() {
      var _this = this;

      var promises = new Array(this._concurrencyLevel);

      for (var i = 0; i < this._concurrencyLevel; i++) {
        promises[i] = this._executeOneAtATime(i, 0);
      }

      return Promise.all(promises).then(function () {
        return _this._result;
      });
    }
  }, {
    key: "_executeOneAtATime",
    value: function _executeOneAtATime(initialIndex, iteration) {
      var _this2 = this;

      var index = initialIndex + this._concurrencyLevel * iteration;

      if (index >= this._parameters.length || this._stop) {
        return Promise.resolve();
      }

      var item = this._parameters[index];
      var query;
      var params;

      if (this._query === null) {
        query = item.query;
        params = item.params;
      } else {
        query = this._query;
        params = item;
      }

      return this._client.execute(query, params, this._queryOptions).then(function (rs) {
        return _this2._result.setResultItem(index, rs);
      })["catch"](function (err) {
        return _this2._setError(index, err);
      }).then(function () {
        return _this2._executeOneAtATime(initialIndex, iteration + 1);
      });
    }
  }, {
    key: "_setError",
    value: function _setError(index, err) {
      this._result.setError(index, err);

      if (this._raiseOnFirstError) {
        this._stop = true;
        throw err;
      }
    }
  }]);

  return ArrayBasedExecutor;
}();
/**
 * Wraps the functionality to execute given a Stream.
 * @ignore
 */


var StreamBasedExecutor = /*#__PURE__*/function () {
  /**
   * @param {Client} client
   * @param {String} query
   * @param {Stream} stream
   * @param {Object} [options] The execution options.
   * @private
   */
  function StreamBasedExecutor(client, query, stream, options) {
    _classCallCheck(this, StreamBasedExecutor);

    this._client = client;
    this._query = query;
    this._stream = stream;
    options = options || utils.emptyObject;
    this._raiseOnFirstError = options.raiseOnFirstError !== false;
    this._concurrencyLevel = options.concurrencyLevel || 100;
    this._queryOptions = {
      prepare: true,
      executionProfile: options.executionProfile
    };
    this._inFlight = 0;
    this._index = 0;
    this._result = new ResultSetGroup(options);
    this._resolveCallback = null;
    this._rejectCallback = null;
    this._readEnded = false;
  }

  _createClass(StreamBasedExecutor, [{
    key: "execute",
    value: function execute() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        _this3._resolveCallback = resolve;
        _this3._rejectCallback = reject;

        _this3._stream.on('data', function (params) {
          return _this3._executeOne(params);
        }).on('error', function (err) {
          return _this3._setReadEnded(err);
        }).on('end', function () {
          return _this3._setReadEnded();
        });
      });
    }
  }, {
    key: "_executeOne",
    value: function _executeOne(params) {
      var _this4 = this;

      if (!Array.isArray(params)) {
        return this._setReadEnded(new TypeError('Stream should be in objectMode and should emit Array instances'));
      }

      if (this._readEnded) {
        // Read ended abruptly because of incorrect format or error event being emitted.
        // We shouldn't consider additional items.
        return;
      }

      var index = this._index++;
      this._inFlight++;

      this._client.execute(this._query, params, this._queryOptions).then(function (rs) {
        _this4._result.setResultItem(index, rs);

        _this4._inFlight--;
      })["catch"](function (err) {
        _this4._inFlight--;

        _this4._setError(index, err);
      }).then(function () {
        if (_this4._stream.isPaused()) {
          _this4._stream.resume();
        }

        if (_this4._readEnded && _this4._inFlight === 0) {
          // When read ended and there are no more in-flight requests
          // We yield the result to the user.
          // It could have ended prematurely when there is a read error
          // or there was an execution error and raiseOnFirstError is true
          // In that case, calling the resolve callback has no effect
          _this4._resolveCallback(_this4._result);
        }
      });

      if (this._inFlight >= this._concurrencyLevel) {
        this._stream.pause();
      }
    }
    /**
     * Marks the stream read process as ended.
     * @param {Error} [err] The stream read error.
     * @private
     */

  }, {
    key: "_setReadEnded",
    value: function _setReadEnded(err) {
      if (!this._readEnded) {
        this._readEnded = true;

        if (err) {
          // There was an error while reading from the input stream.
          // This should be surfaced as a failure
          this._rejectCallback(err);
        } else if (this._inFlight === 0) {
          // Ended signaled and there are no more pending messages.
          this._resolveCallback(this._result);
        }
      }
    }
  }, {
    key: "_setError",
    value: function _setError(index, err) {
      this._result.setError(index, err);

      if (this._raiseOnFirstError) {
        this._readEnded = true;

        this._rejectCallback(err);
      }
    }
  }]);

  return StreamBasedExecutor;
}();
/**
 * Represents results from different related executions.
 */


var ResultSetGroup = /*#__PURE__*/function () {
  /**
   * Creates a new instance of {@link ResultSetGroup}.
   * @ignore
   */
  function ResultSetGroup(options) {
    _classCallCheck(this, ResultSetGroup);

    this._collectResults = options.collectResults;
    this._maxErrors = options.maxErrors || 100;
    this.totalExecuted = 0;
    this.errors = [];

    if (this._collectResults) {
      /**
       * Gets an {@link Array} containing the [ResultSet]{@link module:types~ResultSet} instances from each execution.
       * <p>
       *   Note that when <code>collectResults</code> is set to <code>false</code>, accessing this property will
       *   throw an error.
       * </p>
       * @type {Array}
       */
      this.resultItems = [];
    } else {
      Object.defineProperty(this, 'resultItems', {
        enumerable: false,
        get: function get() {
          throw new Error('Property resultItems can not be accessed when collectResults is set to false');
        }
      });
    }
  }
  /** @ignore */


  _createClass(ResultSetGroup, [{
    key: "setResultItem",
    value: function setResultItem(index, rs) {
      this.totalExecuted++;

      if (this._collectResults) {
        this.resultItems[index] = rs;
      }
    }
    /**
     * Internal method to set the error of an execution.
     * @ignore
     */

  }, {
    key: "setError",
    value: function setError(index, err) {
      this.totalExecuted++;

      if (this.errors.length < this._maxErrors) {
        this.errors.push(err);
      }

      if (this._collectResults) {
        this.resultItems[index] = err;
      }
    }
  }]);

  return ResultSetGroup;
}();

concurrent.executeConcurrent = executeConcurrent;
concurrent.ResultSetGroup = ResultSetGroup;

var datastax = {};

/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * DataStax module.
 * <p>
 *   Contains modules and classes to represent functionality that is specific to DataStax products.
 * </p>
 * @module datastax
 */


datastax.graph = graph;
datastax.search = search;

global.regeneratorRuntime = regeneratorRuntime$1; // import events

var NFTBackend = /*#__PURE__*/function (_Events) {
  _inherits(NFTBackend, _Events);

  var _super = _createSuper(NFTBackend);

  /**
   * constructor
   */
  function NFTBackend() {
    var _this;

    _classCallCheck(this, NFTBackend);

    // run super
    _this = _super.call(this); // run build

    _this.building = _this.build();
    return _this;
  }
  /**
   * build
   */


  _createClass(NFTBackend, [{
    key: "build",
    value: function () {
      var _build = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime$1.mark(function _callee() {
        return regeneratorRuntime$1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.__server();

              case 2:
                _context.next = 4;
                return this.__database();

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function build() {
        return _build.apply(this, arguments);
      }

      return build;
    }()
    /**
     * setup server
     */

  }, {
    key: "__server",
    value: function () {
      var _server = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime$1.mark(function _callee2() {
        return regeneratorRuntime$1.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // listen
                this.server = polka().listen(9696);

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function __server() {
        return _server.apply(this, arguments);
      }

      return __server;
    }()
    /**
     * build database
     */

  }, {
    key: "__database",
    value: function () {
      var _database = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime$1.mark(function _callee3() {
        return regeneratorRuntime$1.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return");

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function __database() {
        return _database.apply(this, arguments);
      }

      return __database;
    }()
  }]);

  return NFTBackend;
}(require$$0__default$2["default"]); // export default


var backend = new NFTBackend(); // export default

module.exports = backend;
//# sourceMappingURL=index.js.map
